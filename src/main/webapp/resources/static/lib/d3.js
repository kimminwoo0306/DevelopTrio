!function(t,  n )  { "obje ct " == typeof ex po rts && "und ef ined" != type o f module ?   n(exports)  :  "function" = =  typeof def i ne && define.amd ?  de f ine( [ "exports"],  n ) : n((t = "undef i ned" != ty p e of  globalT h is ?  g lob alThis  : t || self) . d3 = t.d3 ||  {}) }(this, ( fu n ction(t) {  "u s e  stri ct " ;  fu n c t i o n  n ( t ,   n )   {  r e t u rn  n ull == t || n ul l  == n ? NaN  :   t  < n  ?  - 1  :  t   >   n  ?   1   :   t   > =  n   ?   0 :   NaN } functio n  e(t,  n)  {  return null  ==   t  | |   null == n   ?  Na N  :   n  <  t ?  -1  : n  > t ? 1  :  n  >= t ?   0   :  Na N  } funct io n   r ( t )   {   l e t   r, o,  a ;  f u nction u ( t, n, e  = 0 , i = t. l en g th )   { i f  (e  < i) {  if   ( 0 ! ==  r (n,  n ))   re t u rn  i ;  d o {   c o n st   r  =   e  +  i  >>>  1;  o(t[r] , n) < 0 ?  e  =   r  +   1 : i = r   } while   (e <  i )  }   ret urn e }  r e tu rn 2  ! ==  t. l ength ?  (r   =   n ,   o  = (e,  r) => n(t(e ),   r ),   a  = (n, e)   =>  t ( n)   -  e)  :  (r =  t  === n ||  t  = == e ?  t   :   i,  o  = t, a  =  t) ,   {   l e f t :   u ,  cent er :  f u nction(t ,   n , e = 0, r =   t.length )  { const i =  u (t, n, e, r  -  1 ) ; r e tu r n i > e   && a( t [ i - 1],  n )  > -a(t [ i ], n) ? i -  1 : i   },  right:   funct i o n(t, n, e = 0,   i = t.l e ngth)  { if  (e  <  i)  {  i f  ( 0 != =  r( n,  n) )  r et urn  i ;  d o  {  con st r  =   e  +   i  > >>  1; o (t [ r ],   n )  <=  0 ?  e  =   r  +   1  :  i  = r  } while (e <   i) } return e } }  }  f u nc t io n i()   { r et urn  0 } function o(t) { return null == =  t ? N a N :  + t }  const a = r(n), u = a.right, c = a .le f t, f  =  r(o).c en ter; va r   s  =  u ; con s t l = d(y), h  =  d(( function(t) { const n = y(t); return ( t,  e, r ,  i, o) => { n(t,  e,  ( r   < <= 2) +  0 , ( i  <<=  2) + 0, o <<= 2), n(t, e, r + 1, i + 1 ,  o),  n (t ,  e,  r  +  2, i + 2,  o), n( t ,  e , r +   3 ,  i  + 3,   o ) } })); f unction  d( t )  { re tu rn  f unc tion (n ,  e,  r  = e)  {  i f  (!( (e =  + e)  > = 0 )) t hr ow  n ew  Rang eE rr or ("i n v a lid r x" );  i f ( !((r  =  + r)  >=  0))  t hr ow  ne w   Ra ngeEr ro r( "i nva lid  ry ") ;  let  { d at a:  i , wi d t h : o, height:  a  }  =  n;   if  (!((o  =  M a t h . fl o o r(o)) > =  0) )  t hr ow   new RangeErro r( "i nv al i d w idth") ;  i f   ( ! (( a   =  Math.flo or (v o i d  0  ! == a ? a : i. l ength /   o)) >= 0)) thr ow  n ew  Ra ngeError("invalid  h eight") ;   i f   (! o || ! a | |  !e  & &  !r )  r eturn  n ;  co nst  u = e  && t( e ) ,  c =  r && t( r ) ,  f  =  i.slic e () ;   r e tu r n  u   &&  c  ?  (p(u, f, i, o , a) , p (u, i,   f,   o ,  a ),  p ( u,  f,  i , o, a), g(c,   i , f,  o,  a ) ,  g ( c,  f, i, o, a),   g (c,   i, f,  o, a))   :   u  ?   ( p ( u ,  i, f,  o,  a) ,  p( u,  f ,  i , o,  a) ,  p( u,  i, f, o , a))   :   c &&  (g(c, i ,   f ,  o ,   a ),  g( c, f,  i ,  o ,   a ),   g (c ,  i , f ,  o, a)), n } }  fun cti on p(t ,  n ,   e,   r,  i )  {  fo r  (let o = 0, a   =  r *  i;  o  <   a ; )t(n, e, o, o  + =  r,   1) } function   g (t, n ,  e ,  r , i) { for (l e t  o  =   0, a = r * i;  o   < r;  + +o )t (n, e,  o,  o  + a , r) } funct ion  y( t )  {  c ons t  n  =  Mat h.fl o or(t) ;  if  (n  === t) retu rn f un ct i on(t ) {  con st  n   = 2  *   t  + 1 ;  return  ( e, r, i, o, a )  => { if   (!((o -=   a) >= i)) ret u rn; le t u   =  t  * r[i]; cons t  c = a  * t; fo r  (let t =  i , n = i  + c;   t   < n; t += a)u   += r[Math.min (o ,  t)];  f o r  ( l et   t  =  i , f = o ; t  < = f ; t += a)u + = r[ Ma t h. mi n (o,  t   +  c) ] ,   e[ t ]  =   u /  n ,  u   -=   r[Ma th.m a x(i,  t  -  c)]  } }(t); con st e  =  t   - n,  r =  2  *  t  +  1;  r e tu rn   ( t ,  i ,  o ,  a,  u )  = >  {   if  ( !( (a   -=  u) >= o ) )  r et u rn; let c = n  *   i[o]; c o nst  f =  u * n,  s  = f + u; fo r   ( let t = o, n  =  o  + f;  t  <  n; t +=  u) c  +=  i[Math.min(a,  t)];  f o r  (let n  = o ,   l  =   a;  n   < =  l ;  n   + =  u) c  +=   i [ Ma th . min(a , n  +  f)],   t[n ] =  (c + e * (i [Mat h. ma x (o,  n -  s)]  +  i[Math .mi n ( a ,  n  +  s ) ] ) )  /  r ,   c  -=   i[M a t h .m ax ( o, n   - f)]  } }  f u nction  v (t, n) { let  e  = 0; if (void   0 === n) for (let n o f t) nu l l   != n & &  (n = + n ) >= n && ++e;  else  {  l et  r = -1 ;  f o r  (let i  o f   t)  null   != (i =   n(i,  + + r ,  t ) )  && (i = +i )  >= i && ++ e   }  r e tu r n   e  }  fu n ct ion _(t )  {  r e t u rn 0 | t.le n gt h } fun c t i on  b(t )  { return   !(t > 0 )  } function m(t ) { re tu rn   " object"  ! =  t yp eo f  t   ||  "l e ngth" i n   t  ?  t   :  A r ray.fro m ( t )  }   f u n ct i on  x(t, n )   {  l et   e ,  r =   0,   i  =   0 ,  o  =  0 ;  i f  (v oi d   0  = = =   n )  f or   ( l et  n   of  t ) null ! =   n && (n = +n) >= n && (e =  n  - i, i += e /   + +r ,  o  += e * ( n - i)); else { let a = -1; f o r (let u   of t)  null !=  ( u = n ( u, ++a ,   t))  &&  (u  =  +u ) >= u  &&  ( e = u  - i, i +=  e  /  ++r,  o  += e * (u - i)) } if (r  >  1 ) retu r n o / (r - 1) } function  w( t , n) {  c o nst e = x(t, n); return  e ?  M a th.sqrt(e )  : e } function M(t, n) { l et  e ,  r; if (void 0 === n) for ( c onst n of t) n u l l  ! =  n && (voi d 0 === e ? n >= n && (e = r  =  n) : (e   > n &&  (e = n ),  r <  n  && (r   =  n) ));  el se  {  let i = -1; fo r (let o of   t) nul l  != (o = n(o, ++i, t)) & & ( v oid 0  = == e ? o >= o && (e = r  = o )  : (e > o   && (e = o), r < o && (r = o )))   }  return [e,  r] } cla ss  T {  c on st r uctor()   { thi s._partials = n e w Float6 4 A r ray(32), thi s._n = 0  }  add( t )  {  c onst n  =  this ._partials; let   e = 0; f o r (let r  = 0 ;  r  < this._n & & r < 32 ;  r++)  {  c on s t i = n [ r], o  = t + i, a = M at h. a bs(t) < M ath.abs(i) ?  t   - (o - i) : i   - (o - t);  a & &  ( n[e++] =  a ), t = o   } return n[ e ]   = t, this._n  =  e + 1,  t his } valueOf () {  c onst t = th is ._ pa r tials; let n,  e, r ,  i = this._ n, o = 0; i f  (i   > 0) { for (o  =   t[- -i]; i   >  0   && (n = o ,   e  = t[- - i], o = n +  e,  r = e - (o - n),  !r ); ); i >  0  && (r  < 0 && t [ i - 1] < 0 ||  r  > 0  & & t[i - 1]  >  0)  & &  (e = 2 * r,  n  = o +   e, e == n -  o && (o =  n) )  }  return o } }   cl as s I nternMap  extends Map { constructor(t, n =  N) { if (su p er(), Object. de fi ne P roperties(this, { _i nt e rn :  {  value: ne w Map }, _ke y: { va l ue: n } }), nu l l  != t)  for ( c ons t [ n, e] of t) th i s.set(n ,  e)  } ge t(t )   { return  s u per.get(A ( this, t) ) }  h as( t) { r etu rn  supe r.has(A( this , t) ) } set(t,  n) {  r e turn super.se t( S (this, t), n) } dele te (t ) { re t urn super.del ete(E ( th is, t)) } }  c lass InternSet extends Set  { constructor(t, n = N) { if (super(), Object . d efinePropertie s(t his ,  {  _ in te r n:  { value:  n ew Map } ,  _ k ey: { v a lue: n } }), null ! = t)  f or  (co nst n of t) thi s . a dd ( n) } has (t ) { return  super.has(A (t hi s , t )) } add(t) {  r eturn s u per.add (S(thi s,  t) ) } dele t e(t)   {  r eturn sup er.delete(E (t hi s, t))  } } funct ion  A( {  _intern: t, _key:  n  }, e) { con s t  r  =  n (e) ;  return t. ha s(r) ? t.ge t( r) : e }  function S({ _intern: t, _key: n }, e) { const r  = n(e) ; r et ur n  t.has( r ) ?  t.g et(r) :  (t . set ( r ,   e) , e ) }  fun c ti on  E({  _in t e rn: t, _key:  n  } , e) {  cons t  r  =  n( e) ; r e turn  t. h as (r)  & & ( e  =  t . g et ( r ) ,   t . de l ete(r ) ), e } function N(t) {  return null  ! == t & &  "o b j ect" ==   typeof t ? t.v a l ueOf() : t } f u n ction k(t) {  return t } fu nc ti o n C(t,  . .. n )  {  return F(t , k ,   k, n) } function P(t, ...n )   {   return F(t,  Arr a y . fr o m ,  k ,  n )   }   f un c t i o n  z(t, n )  {  for (let   e   =  1 , r = n.leng th;   e  <   r; ++e)t = t . fla t M ap((t => t.p o p() . m a p ( (( [n,  e ] )   = >  [... t ,  n,   e] ) ))); return  t  }  f u n ction $(t, n ,  .. . e ) { return F ( t,  k ,   n ,  e ) }  f u n c t io n D(t ,   n ,  .. .e )  {   r e t urn  F( t ,  A r ray .f ro m , n, e) } fun ct io n  R (t) {   if  ( 1 ! == t.l eng th ) t h row  ne w  E rror ("dupl icat e key") ;   r et urn  t [0 ]   }  fun ct io n  F(t ,  n,  e,  r)  {  ret urn fu nct ion t(i ,   o )   {  i f  (o >= r.leng th ) r et ur n  e (i) ; cons t  a   =  n ew Inter n Ma p ,  u  =  r[o++];  let c  =  - 1 ;  f or (cons t  t   of   i)  { cons t  n  =  u( t, ++c ,  i ) ,  e  = a.get ( n) ;  e   ? e .push(t)  : a.s e t( n ,  [ t]) } fo r  ( c on s t  [n, e] o f  a) a.set(n,  t( e,   o)); retur n  n( a )  }( t ,  0) }  f unction q(t,  n)  {   r e tur n Array . fr o m(n ,  ( n  =>  t [ n ] )) }  f un c tion  U (t,  ...n)  {   if   (" f un c t i o n "  ! =  t ypeof t[Symbo l. it e rator] ) t hr ow   new Typ e Erro r( "va lu es  is   no t  it e ra ble"); t = Ar ray.fr om( t);   l e t  [ e ] = n; if (e   &&   2  ! = = e.length  | |  n .l e n g t h  >  1 ) { const r   =  U in t 3 2Array.from( t ,  ( (t,   n )   = > n)); return   n.length > 1 ? (n  = n.map((n => t.map(n))) ,  r.sort(( ( t,   e) => { for  ( const   r  o f  n )   {  const n = O(r [ t], r[e]); if (n )  re t urn n } }))) :  (e = t .m ap ( e ), r.sort ( ( (t, n) => O(e [t] ,  e [n ] ) )) ), q(t,  r ) } ret ur n t .sort ( I(e))   }  func t i on I( t   = n)  {  if  ( t === n) return O;  i f ("fun c ti o n " ! =  ty peo f  t ) th ro w  new  T ypeE rr o r("c om pare i s  n ot  a   func ti on") ; return ( n ,  e)  = >  {  co n st   r =  t ( n, e);  r etur n  r | | 0 === r ?  r  :   ( 0   = == t(e, e)) -   (0   == =   t ( n ,  n ))   } } function   O(t ,  n )  { r e turn (null = =  t  || !(t   >= t)) -  ( n ul l   ==  n | |  !(n >=  n))  | | ( t  <   n ? -1  :  t  >   n  ?  1  :  0) } var  B =   A r r ay. protot y p e.slice; fu n cti on  Y( t )  {  r et urn ()   => t   } cons t   L   =  Ma t h. s qr t(50 ) ,   j   = Ma t h. sq rt(10), H = M a th .s q rt (2) ;  f un c t io n X(t, n ,  e)   { con st   r  =  ( n  -   t)  / Math.max(0 , e), i = Mat h .f l oor(Math.log10(r )), o =  r   /  Mat h. p ow ( 1 0,  i), a  = o  >=  L   ? 10  :  o  > =  j   ?  5  :  o >= H   ? 2 : 1; let  u ,  c , f ; return i <  0   ? (f  =  Math.pow(10, -i )   / a, u =  M a th . r ou nd(t * f ),  c   = Mat h. r ou n d( n  *   f) , u /  f  <  t && ++u, c / f  > n &&  - -c, f = -f) :  ( f = Math.po w (10, i) * a, u = Math.r o un d (t / f), c  =  Math.ro u n d (n /  f) ,   u  * f < t  & & ++u, c *  f  > n && --c), c < u &&  . 5  < = e && e <  2  ? X(t,  n ,   2 * e) :  [u, c,  f ]   }  function G(t ,  n, e) { if   (!((e = +e) > 0)) retur n  [ ] ; if ((t =  + t) === ( n   =  +n)) return [t];  c onst r =  n  <  t,   [ i,   o , a] = r ? X( n,   t, e)  :  X(t, n,  e) ;  if  (!(o >= i)) re turn  [ ] ;  co n s t  u = o  - i   +  1 ,  c  =  ne w  Ar ray( u ); if   (r)  if  (a < 0) for  (le t  t  =  0;  t <  u;  ++ t) c [ t]  = (o  - t )  /   -a ;  el se   fo r  (let t  =  0; t < u; ++t )c [ t] = ( o   - t )   * a ;  else if  (a  <  0)  for (let t =  0; t  < u ;  + +t )c [ t ]  = (i +  t)   /  - a;  e ls e  f or   ( let  t = 0;  t < u; ++t)c [t]  =  (i   + t)  * a ; r et ur n   c  } func tio n  V ( t,  n ,  e)   {  r e tur n X(t =  + t, n = +n, e =  + e )[2] }  f unction  W( t,  n,  e) { e = +e;  cons t  r  =  ( n   =  +n) <  (t  =  + t ),  i  =  r   ? V (n,  t , e)  :  V( t,  n, e); retur n (r  ?  - 1  : 1 ) *  (i  <  0  ?   1  / -i :  i)   }  f un ct io n  Z (t ,  n, e) {   let r; for (;  ;)   { cons t   i =   V (t,  n , e); i f ( i  ===  r || 0 === i  || ! isFi ni t e( i) )   re turn [ t,  n ];   i  >  0  ?  ( t  =   Mat h.floor( t / i) * i,  n =  Ma th . ceil (n /  i)  *  i )   :  i < 0  &&  ( t  =  M at h. ce i l( t   * i ) / i, n   = Math.floor(n  *   i )  /   i ) ,  r  =  i  }   } function K(t )   { return Math.max(1, M ath. c e il(Math.log(v(t)) / Math.LN2 )  +  1)  } f un c ti o n  Q()  { var t  = k ,  n  = M,  e =   K ;   funct i o n r ( r)  {   A r ray. i sArray( r )   | |  ( r   =   A r ra y . from(r)); va r   i,   o, a, u =  r . l eng t h ,  c  = new Arra y ( u );   fo r  ( i  =   0 ;   i   <  u ;  ++ i)c[i ]  = t(r[i], i , r); var f  =   n ( c ) ,  l =  f[0], h =  f[1], d = e( c ,  l ,  h ) ;   i f (! Ar r ay.isAr r ay(d) ) { c o ns t   t  = h , e =  +d ; i f (n == =  M   &&  ([l,  h ] =   Z (l,   h,  e)), ( d  = G (l,  h, e ))[0] < =  l  && (a  = V (l , h, e) ),   d[d.le n g th  - 1] >=  h )  if ( t  >=   h &&  n ===  M ) {  c on s t  t  =   V (l,   h,   e) ;  i s F in i te(t) &&   (t > 0 ? h = ( Ma th . floor(h   / t)  + 1)   * t :  t <   0   && (h = (Math. c e il ( h * -t )   + 1 )  /  -t) ) } else  d .pop()  }  for (var p = d . length,   g = 0 ,  y  = p ;  d [ g ]  <=  l;) ++g ;  fo r  ( ;   d[ y   - 1 ]   > h;)--y ; (g || y < p)  & &  (d  =  d . s l ice (g,  y),  p  =   y  -   g);  var v, _   = new Array(p  +  1) ;  f or   (i = 0; i <= p; ++i)(v = _[i]  =  [ ]) .x0 = i  >  0  ? d [i - 1] : l,  v.x 1  =  i  <   p ?  d [ i]  : h; if ( isFi n ite(a ) ) {  if  (a > 0) for  (i  =  0;   i <  u; + +i) nu ll   !=  (o   =  c[i]) &&  l  <=  o &&  o   <= h && _ [M ath.min( p , Ma t h. fl oo r (( o   -  l) / a))].pus h( r[ i] );  else if (a  < 0) f o r  ( i  =   0;   i  < u; ++i)if ( n u ll != ( o = c[i]) && l   < = o  && o <=  h ) { const t = Ma t h.f l oo r (( l  -   o ) * a); _[Math .m i n (p ,  t  +  ( d[t] <= o )) ].push(r [ i])  }  }  e ls e  f o r  ( i = 0;  i < u;  ++ i)n ul l  !=  ( o = c[ i]) &&   l < =   o  &&  o <= h   & &  _ [s ( d,   o , 0, p)].push( r [ i]); ret ur n _  } retur n  r.valu e  =  f u nc ti o n( n )  {  r e t urn arguments. le n g th   ?  (t = "fun c tion "  = =  t ypeof n ? n : Y(n),  r) :  t  } , r.domai n  = func t io n( t) { return a rg um en ts .length ? (n  = "fun c t ion" == typeof t ?  t :  Y( [t [0],   t [1]]), r )  :   n  }, r.thresh o lds  = function( t)  {  r etur n  ar guments .length  ?  ( e = "function" = =   typ eo f  t ? t :  Y ( A r r ay . i sArray(t) ? B. c all(t) : t), r) : e }, r } fun c tio n J(t, n) { le t e; i f  (voi d  0 === n) for  (c o nst n  of  t)   null != n && ( e  <  n   | | v o i d 0   = ==   e && n >= n) && ( e   =  n ) ;  e l se  {   l e t   r   = - 1;  for (l e t i   o f   t) null !=  (i = n(i, ++ r ,  t )) & &   (e < i || voi d 0   === e & &   i   > =  i) && (e   = i) } return  e   }  f un ct ion  tt(t, n)  { let e, r  = - 1, i =   - 1;  i f  (v oid  0 === n) for  (con st   n   o f t ) ++ i,   null  ! =  n  & &  ( e  <   n | | void 0   === e  & & n >= n) && (e  = n, r = i); e l se for (let o of t )   nu l l  != (o =  n (o, + + i ,  t ) ) &&  (e  <  o  | | void  0  == =  e  & &  o   >=  o ) & & ( e  =   o,  r  =  i);   re t u r n r } fu n c tion nt(t, n)  {  l et e ;  if (void  0 ===  n)  for  (cons t  n  o f  t) n ull  ! =  n && (e > n  ||  v oid 0  === e & &   n > =   n) & &  (e = n); els e {   let r =   -1; for  (let i o f  t) null != (i   = n(i, ++r, t))   && (e > i || v o id 0 === e && i >= i) && (e =   i )  } return e } fu n ction et(t, n)  {   let e,  r  = -1, i = -1; if (vo i d  0 === n ) f or (const n of   t) ++i,   null ! =  n && (e >  n || void  0 ===  e  &&  n  > = n) & &  (e =  n ,   r = i); els e  f or  (let o  of  t) nul l  != (o  =  n(o, ++i,  t)) && (e >  o  || vo i d  0 ===  e   && o >= o) &&  ( e = o, r =  i);   re turn r }  f unction  r t(t, n, e =   0 ,  r = 1 / 0, i)   { if (n  =  Math. f lo or ( n) ,  e  =  M a th .f l oor(M ath.max(0, e)) ,  r = M ath.floor(Ma t h . min(t . length - 1, r) ) , !(e  <= n && n <= r ) )   ret u rn t; for (i =   void 0 = ==  i ?  O  : I(i); r > e ;)   { if (r  -  e > 600) {  const o = r  -   e  +   1,  a = n -  e  +  1 , u = Math.log( o ),  c =  . 5   * Math.exp(2  *  u / 3 ), f = .5 *  M ath.sqrt(u * c  *   (o -  c ) /   o ) * ( a   - o /   2  <   0  ?   - 1  :   1); rt(t, n ,  Math.max(e, M at h.floor(n - a * c / o +   f ) ) ,  Ma t h . min (r ,  M ath .f l oo r (n   +   (o  -  a)   * c  /   o +   f)),   i )  }  co ns t  o  =  t [n ] ; l et a = e, u =   r; fo r  (it (t ,   e, n),  i (t[r], o) > 0 &&  i t (t, e, r);   a  <   u;)  {  f o r (it(t, a,  u ), ++a, --u; i(t[a],  o)   <  0 ;) + + a; for (; i (t [ u] ,   o) > 0;)-- u   } 0 = = =  i ( t[e], o) ?  i t( t ,  e ,  u) : (++u,  i t( t , u, r)), u < = n   & & (e = u +  1 ), n <= u &&  ( r  =   u - 1) } return t } function it(t, n ,   e) { const r = t[n]; t[n] =  t[e], t[e]  =   r } funct i o n ot(t, e = n) { let r, i = !1; if  (1 === e . l ength) { let o; f o r  (const a of t) {   c onst t = e(a); (i ? n(t, o) > 0  : 0 === n(t, t)) && (r  = a, o = t, i = !0) } }  else for (const  n   of t) (i ?  e ( n, r) > 0 : 0 === e(n, n)) && (r = n, i  = !0); return r } fun c tion   a t(t,   n , e) { if (t = Float64Array.from(func tion*(t, n) { if (void  0   === n) for (l e t n  o f  t) n u l l ! =  n  && (n =   +n) >= n &&   (yi e ld  n ) ; else { let e =   - 1; for (let r of   t ) null != (r = n ( r , ++e, t)) && (r   =  +r) >= r && (yield r) } }(t, e )), (r = t.length) &&  !isNaN(n =  + n)) { if (n <= 0  | | r <   2)  r et u rn nt(t); if (n >= 1) return J (t);  var r, i = (r -  1) * n, o = Math.floo r(i), a = J( r t(t,  o ).subarray(0, o + 1));  return a +  (n t(t.subarr a y(o +   1 ) ) - a )  *  (i -  o) } } fun ction ut(t,   n,  e  =  o ) {  i f   ( (r  =   t . l eng t h )  &&   ! i sNa N ( n  =  + n ) )   { i f   ( n < =   0  ||   r   <   2)  r e t urn   + e ( t [0] ,   0 , t ) ;   if  ( n   > =  1)   r e tur n   + e(t [ r -  1], r - 1, t); v ar r, i = (r - 1) *  n, a = Math. f loor(i), u =  + e( t[a] , a, t);   retu r n  u  + (+e(t[a   +  1], a + 1,  t) - u) * (i - a) } } fu nction ct(t, n, e = o) {  if (!isNaN(n = +n)) { i f (r = Float64Array.from(t, ((n,  r ) = >  o (e(t[r] ,   r,  t) ) )), n   <= 0) retu rn et(r); if (n >=   1) return t t ( r);   var r, i = Uin t 32Array.fro m (t, ((t, n) => n)), a =   r. l en gt h   -  1, u =  M ath.floor( a  * n); r e turn rt(i, u, 0, a, (( t ,  n) => O(r[t], r [ n]))), (u =   ot(i.subarray(0, u + 1) ,  ( t  =>  r[ t ] )) )  >= 0 ? u : -1  }   } functio n  ft(t) { retu r n Array.fro m (function*(t) { for (co n st   n of  t )   yiel d * n }(t)) } fu nc t i on  st(t, n)  {  return [t,  n ] } functio n  lt(t, n, e) { t = +t,  n  =   +n ,  e   =  (i = argum e nts.length)   < 2 ? (n = t, t = 0, 1)   :  i   <  3  ?  1   :  +e; for (var r  =  -1, i = 0  |  Math.max(0, Math.ceil( ( n  -  t)  /   e )) , o = new Array ( i); ++r < i ; )o[r] = t + r * e; retu r n  o  }  fu n c ti on ht(t, e =  n ) { if (1 = = = e.length) return et(t ,  e ) ; l et   r ,  i = -1,  o  = -1; for  ( const n of t) ++o, (i <   0  ?  0  == =   e( n ,  n) :  e ( n, r)  <  0)   & &  (r = n, i = o ) ; r eturn i   }  v a r  dt = pt(Math.ran d o m);   f un ctio n  p t(t)   { return fun c tio n( n, e =  0 , r = n.length)  { let i = r - (e = +e); for (; i ; ) {  con s t  r  = t() * i-- | 0 ,  o = n[i + e];   n[i +  e ]   = n[r + e], n[ r  +  e]  = o }  r e tu r n  n } } fu n c ti on gt( t)  {  if (!(i =  t. le ngth)) return  [ ]; for (var n  =  -1 ,  e  = nt(t ,  y t ) , r = new   A rr ay(e);  ++n < e;) for  ( v ar i ,  o  =   -1, a = r[ n] = new Array(i);  + +o <  i;)a [ o] = t[o][n ];   re turn r }  func ti on yt( t ) {   r eturn t.leng t h } function   v t(t) { retur n t  in stanceof In te r nSet ?  t   :  new In t e rn S et (t )  } function _t(t, n) { const e = t[Symbol. i terat o r]( ) ,  r = new Set; f or  ( co n st  t   of n) { c o nst   n  = bt(t);  if ( r .h as(n)) continue; let  i, o; for (; ({ value: i, done:  o  }  = e.ne x t()); )  { if  ( o ) ret u r n ! 1 ;  const t  =  bt(i); if (r.add(t) ,  Ob j ec t.is( n,   t) ) break }  }  return !0  } function bt(t) { return null !==  t  &&  "o bj ect "  == t yp e of   t ? t.value Of()   : t } fu nction  mt( t) { re turn  t  }  var  xt = 1,  wt  =  2, Mt =  3, Tt  = 4, A t = 1e-6; f u nct io n S t (t) {  re t ur n  "translate ("  +   t + ",0) " } funct ion Et(t )  { ret urn "trans l ate(0 , " +   t  + ")"  } f unction Nt(t ) {  r eturn n => +t (n) } function k t( t, n)  { return n  =   Ma th. m ax(0, t.bandwidt h ()   -  2 *  n) / 2 ,  t . round() && (n   =  M a t h. round(n) ) , e => +t(e )  +  n  } function Ct() { return !t his.__axis } function Pt(t, n) {   var  e  =  [ ],   r  =   null, i = null, o  =   6,  a = 6, u = 3, c = "und ef in ed" !=  typeof win do w  & &  window.devicePixelRatio > 1  ? 0 : .5, f = t === xt || t ===   Tt  ? - 1 : 1,   s = t ===  T t  | |   t === wt  ?   "x " : "y", l = t === xt | |  t  = == Mt  ?  St : Et; function h(h) { var d  =   n ull  == r ? n.ticks ? n.ticks.appl y(n, e ) :  n.dom ain() : r, p = null == i ? n.ti ckFo rmat ? n.tickFormat.apply(n, e) : mt :  i, g =  Math.max(o, 0) + u, y = n.rang e( ), v = +y[0] +   c, _  =   +y [y. l e ngth - 1] + c,  b = (n.b an d wi dth ? k t :  N t )(n.copy() , c ),  m   = h.selec t ion  ? h.selection() : h,   x  = m.s electA ll(".d o m a i n ").data([null] ) , w = m.selectAll ( ".tic k ").data(d, n).order ( ) , M = w.exit(), T  = w.ente r() .a pp end("g").attr("class", "tick") , A  =   w.select("line"),  S  = w.select("text");  x   =  x.merge(x.ent e r().insert("path" ,  ".tick").attr("class", "domain").attr("stroke", " currentC o l or")), w = w.m e rge(T ) , A =  A.merg e(T.appe n d( " line") . attr("stroke" ,   "currentColor" ) .attr(s + " 2" ,   f  *  o)), S =  S .merge(T.append("text").attr ( " fill", "curren t Color").att r( s ,  f   * g).attr("dy",  t   = == xt ? "0em"   : t === Mt ?  " 0.71em "  :  "0.32em")), h   !== m && (x  =   x .t r ansition(h ) , w = w.transition(h), A = A.tr a n sition(h), S =   S.transition(h),  M  = M.transition(h).att r ( "opacity", At) . attr("transform",  ( function(t) { retur n   isFini t e(t = b(t)) ? l(t + c ) : this.getA t tribute("transform") })), T.a t tr("op a city", At).attr("transf orm", (functi o n(t) { var n = this.parentNode._ _ axis; return l ( (n && isFinite(n = n(t)) ?   n : b(t)) + c)  } ) )), M.remove(), x. a ttr("d", t === T t || t === wt ? a   ? "M" + f * a +  "," + v +   "H" +  c + "V" + _   +  "H" + f * a :   " M " + c + "," +  v  +  "V "  +  _  :  a ? "M"   +  v   +  "," + f  *   a + "V" +   c  +  "H" +   _ + " V " + f * a :   "M" +  v +   ", "  + c   + "H" + _ ), w.a ttr (" o p ac ity",  1 ).att r( "tran s fo r m", (function( t)  {  r et ur n  l (b(t)  +  c)   } )), A.at t r (s + "2",   f  * o), S. a t tr(s, f * g). tex t( p ),   m .f ilter( C t).at tr ("fil l " ,  "none"). attr("font- si ze " , 1 0).attr( " font - f a mily", " sans -se ri f ") . a tt r("te x t-anchor" , t = ==  w t  ?  "s t art" : t  = == Tt   ?  "end" : "m i ddle" ), m.each((f u ncti o n() { thi s.__ax is  =  b  } ) )  }  retur n  h.sc al e = functio n(t )  {  retu r n  a rguments.lengt h  ? (n = t, h) : n   }, h.ticks = f u nction () { ret ur n e = Ar ra y.from(a rgum e n t s), h }, h.ti c kArguments = f un c tion(t)  {   r et u r n   a r g u me n t s . len g th ? (e = null   == t ? [] : Array . from(t), h) : e.slice()   } , h.tickValues   = function(t) { r e turn arguments.length ? (r = nu ll == t  ?   null : Array.f ro m (t), h) : r && r. s lice() }, h.tickForm at   =  function(t) {  r e turn arguments.le n gth ? (i = t, h) : i }, h.ti ckSize =  f u n ction(t) { ret ur n  arguments.length   ? (o  =  a = +t, h) :  o }, h.tic kSiz eI n n er = function(t) { retu r n arguments.length ?  ( o   = +t, h) : o } ,  h .tickSizeOuter =  f uncti o n(t) { return  arguments. leng th   ?  (a = +t, h) : a }, h.tickPaddi ng = fun c tion(t) { return arguments.l ength ?  (u   =  +t, h) : u },   h.offset = function(t)  {  return arguments.length ?  (c  = +t, h)  :  c  } , h } var zt  =  { value: () = >  { } }; function  $ t() { for (var t, n = 0, e =   a rguments.lengt h,  r   = {}; n < e; ++n)   { if (!(t = arguments[n]  +  "" )   || t in r || / [\ s. ] /.test(t)) throw  n ew Er r or("illegal t ype: " + t) ; r[ t]   =  [] } return new Dt(r) } fun c tion Dt(t) { this._ = t }  f un c t ion Rt(t, n) {  f o r (var e, r = 0, i = t.length; r <  i ; ++r)if ((e = t[r]).name  === n) return e.value }  f unction Ft(t,  n , e) { for (var r   = 0, i = t.len g t h; r < i; ++r) if   (t[r].name === n)   { t[r]  =   z t , t = t.slice( 0,   r).concat(t.slice ( r + 1 ) ); break } re turn null ! = e  &&   t .push({ name:  n , value :   e   }), t } Dt.pro t otype = $t.prototype = { const r uctor: Dt, on:   function(t, n) { v ar  e, r, i  =  this._, o = ( r  = i, (t +   "" ).trim().sp l it(/^|\s+/).map((function( t)  {  v ar n = "", e =  t . ind exOf(" . "); if   ( e > =   0 && (n =  t. s lice(e + 1), t   = t.slice(0, e )) ,  t  && !r. h asOwnP r o per t y (t)) thro w n e w Error("unknown  t ype: " + t); r e turn { type: t, n a me: n }  }) ) ) , a = -1, u =  o .length; if (!(ar g uments.l en g t h < 2)) { if ( nu l l != n && "functi o n" != typeof n ) throw ne w  E r ror("inva li d   callback: " +   n); for (; ++a <   u; ) if (e = (t = o [ a]).type) i[e] =  F t(i[e], t.name,  n ) ;   else if (null  = = n) for (e in i)   i[e]  =  Ft(i[e], t.n ame, null);  return this } f o r (;  + + a  <   u ; ) if ((e = (t =   o[a]).type) &&   (e   = Rt(i[e], t.n a me))) return e },   copy: function ( )   {  var t = {}, n   = this._; for (va r  e in   n) t[e] = n[e ].slice();  return new Dt( t ) },  c a l l:   f u n ction(t, n) {   if ((e = argumen ts .length - 2) > 0) for (var e, r,  i  = new Array( e ), o = 0; o < e; ++o )i [o] = arguments[o + 2]; if (!this. _.hasOwnProperty(t)) throw  n ew Error("unk n own type: "   + t); for (o  =  0, e   = (r = this._[t] ) .l ength; o < e; ++o)r [ o].value.appl y (n, i )  }, apply: function ( t , n, e) { if (!t his._.ha s OwnProperty(t)) t hrow new Error("u n k n own type: " +   t); f o r (var r = this._[t ] ,  i = 0, o = r.le ngth; i  <  o; ++i)r[i].valu e.apply(n, e) } } ;   v ar qt = "http: / /www.w3.org/1999/ x html" ,  Ut = { sv g:  "h t tp: //www.w 3 . or g / 200 0 / svg", xht m l :  qt, x l ink:  "http: // www.w3 .or g/1999 /x link",  xm l: "ht t p://ww w . w 3.org/XML/1998/namespace", xmlns : "http://w ww.w3.org/2 000 / xmlns/"  } ;   function It(t) {   v a r n = t += "",  e  =   n.indexOf(":"); r e turn e   > = 0 && "xm l n s" !== (n =   t.slice(0, e)) &&  ( t = t.slice( e  + 1)), Ut.hasO w nProp er ty( n)  ? { sp a ce :   Ut[n], lo c a l:  t } :  t  }  function  Ot( t) { r et urn fu nct ion() {  var n = this.ownerDocument, e = this.n amespaceURI ; return e  === qt && n.documentElement.n amespaceUR I  = == qt ? n . cre ateE lement(t )  :  n.createElementNS(e, t) } } f un cti o n   Bt(t)  { retu rn fu nction( ) { re tu rn this.o wn erDocume n t. c r eateEleme n tNS(t.spa c e,  t . local) } } fun ct io n  Yt(t )  { var   n  = It(t); retu rn (n.loca l  ? Bt : O t ) ( n) } fun ct i on   Lt() { } function jt(t) { return   n ull == t ? Lt :  function( ) { return thi s.queryS e lector(t)   } } function H t(t ) { r eturn null == t ?  [ ] : Array.isAr ra y (t) ? t : Array.f r om(t) } functio n  Xt ( )  { return [] }  f u nction Gt(t) { re t urn null == t ?  X t : function( ) { return  t h is.querySele c t orAll(t) } }  fu nction Vt(t)  { return f u nction() { return this.matches(t) }  } function  W t(t) { return  function(n )  {  return n.matches(t) } } var Zt = A rr ay .prototype.fin d; function   Kt() { return this.firstElementChild  }  var Qt = Array.p rototype.fi l ter; function Jt() { return Array.from( t hi s.children)  }   func tion tn(t)  {  return new Array(t.le n g th ) } function nn(t, n)  { this.ownerDocument = t.ownerD ocument, this.namespace UR I = t.n amespaceURI ,  this . _next = null, this._par e nt   =  t, this.__data__ = n }  fu nction en(t, n, e, r, i, o) { fo r (var a, u = 0, c = n. le ngth, f =  o.length;  u  < f; ++u)(a = n[u]) ? (a.__d at a _ _  = o[u] ,  r[u] =  a) : e[u] = n ew   nn(t, o[u]);   fo r (; u < c; + + u ) (a = n[u]) &&   (i[u] = a) } function rn(t, n, e, r, i, o,  a)  {  var u, c, f,  s  = new  Map, l  =  n.length ,  h = o.length, d = new Array(l); for  (u = 0; u < l; ++u)(c = n[u ] ) && (d[u] =  f =   a.call(c, c. _ _data__, u,  n )  + "", s.has (f)  ? i[u]  = c : s.se t (f, c)); f or  (u = 0;  u  <   h; ++u) f =  a.cal l (t, o[u], u,  o )  + "", (c   =  s.get(f)) ?  ( r [u ]   =  c, c.__ data__  =  o [ u], s . d elete(f))   :  e[u ]  = new nn(t,  o [ u] ) ;  f or (u  =  0; u  <  l ;  ++u)(c =  n[u]) && s .g et( d[ u]) === c & & (i [u ] = c) } fu n ction on(t)  { re t urn  t.__data__ } fu nction an(t) {  r eturn "obj ect" == typ e o f  t && "len gt h" in t  ?  t : Array. f rom(t) } function   un(t, n) { return t < n  ? -1 : t >   n ?  1  : t > = n  ? 0 :   NaN } functio n   cn(t) { r e t urn   f unc t i on ( )  {  this.r emoveAt t r ibute ( t ) } } fun c t io n   fn (t) {  r eturn  f unction() { this. removeAttri bu teNS (t.space, t .local) } } func ti on  sn(t, n) {  return func t ion() { this.setAttribu te ( t ,  n ) } } funct i on ln(t, n) { ret u rn function() { this.setAttri bu t eNS(t.space,  t .local,  n )   } } fun ct ion hn(t, n) {  return func t ion() { var e = n.apply(th is ,   ar g uments); nu l l == e ? this.rem o veAttribute(t) : this.setAttr ib u te(t, e) } }  f unction  d n ( t, n) {  r eturn f unction() {   var e = n. ap ply(this ,  ar g uments) ; n ull ==   e ? this.remo v e Attribute N S (t.space, t.l o c al )   :  this.se tAttrib u t eNS(t . s pace, t.l o c al,  e ) }   }  f u n ct ion pn ( t) {  re turn t.ow nerDocument  & &  t. ownerDocum ent.defaultView  || t.document  &&  t ||  t.defaultV ie w  }  function gn(t) { r eturn function() { this .sty le.re m o v eP r ope r t y(t) } } funct i o n yn(t, n, e)  { return  fu nction()  {  t h is.style.se t Property(t, n, e)   } } func t ion vn (t,  n, e)   { return  f u nction() { va r   r = n.apply(t h i s, arguments) ;   nu l l  = = r  ?  this . style . r emove P r operty(t)   :  this.style. s et Property(t,  r , e)   }  } functi o n  _n( t , n) { return   t .sty l e.getProperty Valu e( n)  | | pn ( t).getCompute dS tyl e(t , null) .g e t Pr o p er t y Va lue(n)  }   funct i on  bn (t )  {  r e t u rn  fun c tion( )  { d e lete  this[t ]   }  } fu n c tion m n( t , n) { re turn funct i on () { th i s[ t ]  = n }  } function   xn(t, n) { return functio n( ) { var e = n.apply(t his, arguments );  null  == e ? de l ete this[t] : this[t] =  e  } } function wn(t) {  return t.trim( ). split (/^|\s+/) }  f un c tion  M n(t) { return   t .clas s L ist || new T n(t) }  function  Tn (t) { th i s. _ node  =  t,   this._names =  w n ( t.getAttri b ute( "cla ss " )  ||   "") }  f un c tion An(t, n) {  for  ( v a r e = Mn(t ) , r =   -1 ,   i = n.length; ++r  <   i; )e.add (n[r]) } fu n cti on Sn( t , n) { for  ( var e = Mn(t) ,  r   =  -1, i = n.le n g th; ++r <  i ; )e.remove ( n [r]) } fu n c tion En(t)  { r e t urn function( )   {  A n (t his, t)  } } fu n c tion  N n (t) {   r eturn fun c t ion( )  { Sn(this, t )   }  }   fu nction   kn(t ,  n) {  re turn  f unc tio n( )   {  (n.apply ( this,  arguments) ? An  : Sn)(this, t )  } } functi on Cn() {  t his.textCon te nt = " " } functi o n P n(t) {   return functi o n ()  {   this.text Con t ent =  t } } f u n ction   z n(t) { r e tu r n  func tio n( ) { v a r n =  t .a pp l y (this, arguments); this.text Co ntent = null == n ? "" : n }  }  f u nct ion $n() {  th is.in nerHTML = " "  } function D n( t ) { retu rn   f unction() { t his.innerHT M L  =  t   }  }  f u ncti on  Rn(t)  {  return funct i o n() { var   n  = t.apply(th i s ,  a r gu ment s );  this.in n e rHTML   =  null ==  n   ? ""   : n } } funct i o n  F n ()  { thi s .next Si bling   &&  this.pare n tNode.appendChil d(this) } function qn( )  { thi s.previous S iblin g  && this.pare ntNode.insertBefore ( this,  this.parentN ode.firstCh ild)  }  funct ion Un() {   return null } function  In () {  var t = th i s.p arentN o de; t && t.re m o ve C h ild(this)   }  f unction  On()  {  var  t   =  t h is.cloneN o d e( !1),   n = t h is.pa re ntN ode; ret u rn n ? n.in se rtBef ore(t, thi s .next S ib lin g) : t } function  Bn( ) { var  t  = this .cloneNode ( !0), n  = this.pare nt Node;  return n ?   n.i nsertB e fore(t, this. n e xt S i bling) :  t   }  functio n Yn(t)   {  retu r n  f u n ction() {   v ar  n = t h is.__ on ; if (n)  { for (var  e,  r  = 0, i = -1 ,  o = n .length; r  <  o ; ++r ) e = n[ r] , t.type && e.typ e  ! = = t.t y pe || e.name  !== t.name ?  n [++i] = e : this.removeEv entListe n er(e.type, e.list e ner, e.options); ++i ?  n . l ength =   i  :  d e lete this. __ on } } }   functio n  L n (t ,  n, e)  {  r e turn f unc ti on() {  var r, i =  t hi s .__on, o = function(t)  {   r eturn function( n)   {  t . call(this,  n , this._ _ da t a__) }  } (n);  i f   (i )  fo r  (var a = 0, u  =  i. length; a  < u; ++a)i f  ( (r = i[a]).type === t.t y p e  && r.name ===  t. n a me )  return th is .removeE v en t Listen er( r .type, r.liste ne r, r.opt ions), this .a d dEven t List e ner( r. type, r.listener  =  o ,  r. option s  = e), void (r.v a l ue  =   n); this. add E ventL istener(t.type, o,  e), r  = {  type:  t . type, name: t.name, value: n ,  listener :  o ,   o pt i ons: e  },  i  ? i. push(r) : t h is.__on = [r] } } funct i on jn(t, n, e)  {   v ar   r = pn(t),  i  = r.Cust o mE v ent; "f u nction" == typeof i ? i  =  new  i(n, e) : ( i  = r.document.createEve n t("Event"), e  ?  ( i .i n itEvent(n,  e. bubbles,   e. c ancelab l e), i.detail = e.deta il ) : i. initEvent( n , !1, !1)), t.dispat ch Event( i) } funct i on Hn(t, n) { return  f unction () { return   jn(th i s, t, n) }  }  functio n   X n(t, n ) { return function() { return   jn(this, t, n.apply(this, arguments))  } } nn.pro tot yp e = { c onstructor:  n n , app e ndChild: f un ction(t)   {   return   t his. _p a r en t .insertBef or e(t, thi s . _ next)  }, insertBefore: function(t, n )  { return this._parent.insertBefore(t,  n) }, quer ySelector: fu nction(t)  {  retur n t hi s._pare nt.querySe l ector(t) }, querySel ec torAll : function( t ) { return this._par e nt . que ry Select orAll(t) }  } , Tn.prototype = { add:   function(t) { this._names .i n dexOf(t) < 0 && (thi s. _na mes.push(t) ,  th i s._nod e. s e tAttribute( " class", this._names.join(" "))) }, remove: func t ion(t )  {  v a r n = this._nam es.index Of ( t) ;  n  >= 0 &&  ( thi s . _names.spl ice( n , 1),  t his._ n o de. set A ttri b u te("class ",  this._names.join("   ")) )  },  c o n t ai n s:  f u nc t i on (t) { return this._na me s.in dexOf(t) >=   0 } } ;  var Gn = [null];  f unc tio n Vn(t,   n )  {   this._gro u p s  = t, th is . _p a r ents  =   n  } func tio n  Wn() { re tur n new  Vn ([[doc ume nt.docu mentElement]],  G n) } func tion Zn(t)  {  r eturn "string" == typeof t ?  n ew Vn([[ d oc u ment.q uer yS elector(t)]], [doc ument.docum e ntE lement ] ) : new Vn([[ t ] ],   G n) } Vn.p r o to type =  Wn.prot o t ype =   {  c o n structor:   V n,  selec t : fun ct ion(t) {  " fu nction "  ! = typeof t &&   (t = jt(t));  f or (var n = t h is._gr o ups ,  e = n.length, r =  n ew Array(e), i   = 0; i  <  e;   + +i)for (var o, a ,  u  = n[i],   c = u.length,  f  =  r [i ]  = new  Array (c) ,  s  =   0; s < c; ++s)(o  =  u [s])  & & (a = t.call(o,  o. __ da ta__, s, u)) && (" _ _data _ _" in o && (a.__dat a__ = o.__ d ata__), f[ s]  =  a); retur n n e w Vn(r, this._parents) }, selectAll: function(t)  { t  =  " function" == typeof t ? f u nctio n (t) { return function() {  return  Ht(t.appl y (this,   arguments)) }  }(t) : G t (t);  f or (var n =  t h is._gr oups, e =  n.lengt h , r = [], i  =  [], o = 0;  o   < e; ++o)for  (v ar a , u = n[o],   c =  u.len g th, f =  0; f < c; ++ f)(a   = u[f]) && (r. push(t. call(a, a._ _d ata_ _, f, u)),  i. p ush(a)); return  n e w  Vn(r, i ) }, select C hild: function(t)  {  return this.sele ct (null ==  t ? Kt : f u nction(t) { r e tu rn funct i o n() { re tu rn  Z t . call(thi s.c hildren,  t )  } }("function"   == typeof t ? t : Wt(t))) },   selectChildren :  function(t) { retu rn this.selectAll(null == t  ?  Jt : function ( t) {  r eturn function() { return Q t . call(this.children, t) } } ("f unct ion" == typeof  t ?  t  : Wt(t))) }, filter: fu nct ion ( t) { "functio n " != typeof t && (t =  Vt(t)); for (var n =  t his._gr o ups, e = n.len gt h , r =   new Array(e), i = 0; i < e;   + +i)for (var o, a = n[i], u  = a.l e ng th, c = r[i] = [],  f =  0;  f < u; ++f)(o = a[f])  & & t.call(o, o.__da ta__,  f,  a)  && c.push(o); r etur n  new Vn(r, this._parents ) },  d ata: function(t, n) {  i f (!arguments .length) return Arra y .from( t h is ,  on );  var e = n ? r n  : en, r = t hi s._paren ts , i = t hi s._groups;  "f unction "  !=  t yp eo f t  & & ( t  = functio n (t )  { return function() { return   t } } ( t)); f or  (var o = i .le ngth, a = new  A rr ay(o), u = n e w Arra y( o), c = new  Ar ray(o), f = 0 ;  f  < o; ++f )  { var  s  = r[f], l  = i [f], h = l.le ng th , d = a n (t.cal l( s, s && s._ _da ta__, f, r)),  p  =  d.length,  g  = u[f ]  = new Array (p) , y = a[f] =  ne w  Array(p ) ; e(s,  l , g, y, c[f ] =  new Array(h) ,  d,  n ) ; for  (v ar v, _, b  = 0 , m = 0; b <  p;  + +b ) if (v  =  g[b]) { for  (b  >= m && (m =  b  +  1) ;  !(_ =  y [m]) && ++m  <  p;); v._next  =  _  ||  n ull }  }  return (a =  ne w Vn(a, r))._ en te r  =  u, a. _ e xi t  = c, a }, ent e r: fun ction() {  re turn new  V n(this._enter   || this._groups.map(tn ) , this._parent s)   }, exit: fu nc t i o n( ) {  re tur n   n e w Vn(this._ex i t || this._groups.map(tn), this ._ parents) }, jo in: fun c tion(t, n, e)  {  va r  r = this.e n ter(), i =  t hi s, o = this.e x i t (); return "fu nc t ion"  = = typeof t ? (r = t(r)) &&  (r  = r.selectio n())   : r =  r.appen d (t + ""), nul l   != n && (i = n( i )) && (i =   i.sel e ction()), null == e ? o .remove() :  e(o), r  &&  i ? r . merg e ( i) .order ( ) :  i   } ,  me rg e : function(t) { for (v ar   n = t.selection ? t.selection() : t, e = this._group s,   r = n._groups, i = e.length, o = r.length, a = Math.m in ( i, o), u = new Array( i) ,  c = 0; c < a; ++c)for (var f, s = e[c], l  =  r [c], h = s.length, d = u[c] = new Array(h),  p   = 0; p < h; ++p)(f = s[p] || l[p]) && (d[p] = f);  fo r  (; c < i; ++c)u[c] = e[c]; return new Vn(u, this. _p a rents) }, selection: function() { return th is   }, order: function() { for (var t = this._groups,  n  =   -1, e = t. length; + +n < e;)for ( var r, i  = t[n ], o =  i.length -  1, a =  i[o];  --o >= 0; )(r =  i[o]) &&  (a && 4  ^ r.comp areDoc um entPosition(a)  && a.pare ntNod e.in sertBefore( r, a), a  = r);  return t his }, sor t: functi on(t) { fu nction n (n, e) { re turn n & & e ? t(n. __data__,  e.__d ata__) :  !n - !e } t ||  (t = un) ; for (va r e = thi s._group s, r = e. lengt h, i =  new Arra y(r) , o = 0;  o < r;  ++o) { for (v ar a, u =  e[o], c  = u.lengt h, f = i[o ] = ne w Array(c ), s = 0;  s < c; ++ s)(a = u[ s]) && (f[s]  = a); f .sort(n) } retu rn new V n(i, this._ parents). order() },  call: fun ction()  { var t  = arguments [0]; retu rn arguments[ 0] = thi s, t.apply(nul l, argum ents), this },  nodes:  function() { r eturn Ar ray.from(this)  }, no de: functio n() { fo r (var t  = this._g roups, n = 0 , e =  t.length ; n < e;  ++n)for  (var r  = t[n], i =  0, o =  r.length;  i < o; ++ i) { var a =  r[i]; if  (a) return  a } retu rn null  }, size:  function()  { let t  = 0; for (c onst n of  this ) ++t; re turn t },  empty: fu nctio n() { re turn ! this.n ode() }, eac h: functi on(t)  { for ( var n = t his._grou ps, e =  0, r = n. length; e  < r; ++e) for (va r i, o =  n[e],  a = 0, u  = o.l ength; a  < u; ++a) (i = o[a] ) && t.call(i,  i.__data __, a, o);  return  this }, attr:  function (t, n) { v ar e = It (t); if (ar guments.l ength < 2)  { var r  = this.node(); return  e.local  ? r.getAtt ributeNS( e.space, e. local) :  r.getAttr ibute(e)  } return t his.each( (null == n ?  e.local  ? fn : cn : "f unction"  == typeof n  ? e.loca l ? dn : hn : e .local ?  ln : sn)(e, n) ) }, sty le: function(t,  n, e) {  return argum ents.leng th >  1 ? th is.each((n ull == n  ? gn  : "functi on" == t ypeof n ?  vn : y n)(t, n,  null == e ? "" :  e)) : _ n(this.node (),  t) }, propert y: functi on(t, n) { re turn arg uments.length >  1 ? thi s.each((null ==  n ? bn :  "function" == typ eof n  ? xn : mn)(t, n) ) : this .node()[t] }, cl assed: fu nction(t, n)  { var e  = wn(t + " "); if (a rguments.l ength < 2 ) { for ( var r = M n(this.node( )), i = - 1, o  = e. length;  ++i < o;) if (!r .contain s(e[i])) r eturn !1 ; retur n !0 } re turn this. each(("fu nction"  == typeo f n ? kn : n ?  En : Nn) (e, n)) },  text: fu nction(t) { re turn argu ments.length ?  this.eac h(null == t  ? Cn : ( "function"  == typeo f t ?  zn : Pn) (t))  : this.no de(). textConte nt }, html:  function (t) { r eturn ar guments.length  ? this. each (null ==  t ? $n : ( "function " == typeo f t ? Rn  : Dn)(t)) :  this.no de().in nerHTML } , raise: fu nction()  { return  this.eac h(Fn) },  lower: fu nction( ) { retur n this. each(qn)  }, appen d: funct ion(t) { v ar n = " function"  == typeo f t ? t :  Yt(t); r eturn  this.sel ect((functio n() {  return thi s.append Chil d(n.apply (this , argu ments))  })) }, in sert: f unction(t , n) { var  e = "fu nction"  == typeo f t ?  t : Yt(t) , r =  null == n  ? Un : "fu nction" = = typeo f n ? n :  jt(n); retu rn this. se lect((functio n () { return this.insertBefore ( e.apply(this,   arguments), r.apply(this, arg u ments) || null )  })) } ,  remove:  f un c tion() { return this.each (I n ) }, clone:   fu n ction(t) { r e t urn this.selec t(t  ?  Bn   :  On)  } ,  da t u m: funct io n ( t)   {  r e t urn  a rg u m en t s.l e ng th  ?  t hi s . pr o pe rt y ( "__ d a ta__ ",  t )  : t h is .n o de() . __ d a ta__  },  o n:   func t i on( t ,  n,  e)  {   va r   r,   i , o  =  f u n ct i o n( t )  { r e tu r n  t . tri m () .spl i t( /^ | \ s+ / ). m ap(( f uncti o n( t ) { var n =   "", e = t.in dexOf (".") ;  r et u rn e >= 0 & &  (n = t.sl i ce(e   + 1) , t   = t. s lice (0,   e)),   { ty pe :  t ,  name: n }  } )) }(t +  ""),  a =  o.len g th ;  if (!(argu m ents.l e ngth   < 2) ) {   for  ( u =  n ?   Ln :   Yn,  r = 0 ;  r   < a; ++r)th i s.each(u (o[r ] , n,  e)) ;  ret ur n  t h is } var u  =  this.no de() . __on ; if   (u)  for ( v ar c, f = 0, s = u.l e ngth; f <   s; ++f)for (r  =  0 ,  c = u[f];  r <  a; + +r ) if ( ( i = o[r]).type   === c.type && i .n am e  ===   c. n a me)  ret u rn  c . value }, dispa tc h:  f u nction(t ,  n )  {  r e t u r n thi s.each((" fu nc ti o n" == typeof n   ? Xn : Hn)(t, n)) }, [ Sy mb o l.itera t o r]: funct i on*() { for  (va r t  = this._gr o ups, n   = 0, e = t.len gt h;  n   < e; ++n )fo r (var r, i = t[ n ], o  =  0, a = i .l en gth;  o   <   a ;  + +o)(r = i[o])  &&  ( yi e ld r)  }  };  var K n  =  0; fun c tio n Qn() { ret u rn   new Jn } func t ion Jn () { this._ = "@" + (++Kn).toString(36) }  f unction te(t)   { let n ;  for (; n = t.sou rceEve nt;) t =   n ; retu r n t } function ne(t, n) { if (t = te(t), void 0 === n  &&  ( n  =  t .currentTar g et), n) { var  e  = n.ownerSVGEl e m e nt || n; if  (e.createS VGP o int) { var r =   e.createSVGPoint() ; return r.x  = t.clientX,  r. y =   t.clientY, [(r   = r.ma tri x Transf o rm ( n.g e tSc r eenCTM().inver s e())).x, r.y]  }  if  ( n .getBoun di n g C l i e n t Rec t )  {   va r  i   =   n . g etB o u nd i ng Cl i entRe ct(); ret ur n  [t . clientX - i.le f t  - n.clientLeft, t .clientY - i.top -  n.c lien tTop] } } r et urn [t.pageX, t. pa ge Y ] } Jn. pro totype = Qn.pr ot otype = { constru ctor: Jn,  get:   fu n ction(t) {   for  ( v ar  n  = t h i s._ ;  !(n   i n t);)if (! (t  =  t . parentNode) )  ret u r n; r e t u r n  t [ n]   },   se t: funct i on ( t , n )   {  r et u r n   t [t h is . _ ] =   n  } ,  r e m o v e :  f un c t i on ( t)   {  r e t u r n   t h i s. _  i n t   & &   d e le t e   t [ t hi s._] }, t oS tr ing: funct i on() { return  th is ._   } }; con st  ee = { passive:  ! 1 },  r e = { cap tu re : !0 ,  p a s s iv e : !1 }; functi on  i e( t ) { t. s top Immedi a teP ropaga t ion () } functio n  o e (t) { t.preven t Defaul t( ) ,  t. st o pImm e d i a t ePr o p a gation() } fun c tion ae(t) { var n  = t.docume n t. doc u mentElement, e  =  Z n (t).on("dr a gs t ar t . d ra g ",   o e ,  r e ) ; " o n s e l ect s t a rt "  i n  n ?   e. o n( " se l ectsta rt. d rag", o e , re) : (n.__noselect = n.style.MozUserSel ect,  n. st yle.MozUserSe l ect = "none") } function ue(t,  n)  { v ar  e = t.docu men t.documentE lement, r  =  Zn(t).on("dragstart.drag", nu ll ); n && (r .on("click . drag", oe, re), setTimeout( (f unction()  { r .on("clic k. dra g", nu ll)  }), 0 ) ), "onselec t start" i n  e ?  r . o n( " selectstart. dra g", null) : ( e .s tyle.M o zU serSel e ct  = e.__nosele ct , delete  e .__nosel e ct)  }  v a r  c e = t => ()  =>  t; function f e (t , { so u rc eEvent :  n , subject: e,  t arget :  r, identif ie r: i, a c tive: o, x: a, y: u, dx:  c, dy: f, d ispatch: s  }) { Object.defin eP roperties(thi s , { ty pe:  {  value :  t, enu m erabl e:  !0 ,  config ur able:  ! 0 },  so urc eE vent:  {  value:   n, en um e ra ble: !0, con fi gurable: !0  },   su bjec t:  { value: e , e numerable:  !0, config u rable:  !0 }, target: { value: r, enumerable: !0, config u rable: !0 }, identif i e r : { value: i, en um erable: !0 , c onfigurab le : !0  }, ac tiv e: { v a lue: o, enu m erable:  ! 0, c on f i gu r able: !0 },  x:  { value: a, en umerabl e: !0,   co nfigurable: ! 0  }, y: { v a lue: u,  e nume ra b l e:   !0, configur abl e: !0 }, dx: {  value:  c, en u me rable: !0, co nf igura b le: ! 0  }, dy :  {  v alu e : f, en u mer a b le: !0,  co nfigurable: ! 0   } , _: {  v a lue: s  }   } )  }   fu n c t i o n  s e( t )   {   r et urn !t.ctrlKey &&  !t .bu t t o n }   f u ncti on  le () {  re tur n th i s.p a r e ntN o d e  } f un cti on he(t, n) {  r eturn n u ll == n ? { x: t.x, y: t. y } : n } f unction de( ) { return naviga to r.maxTouchPoi n ts ||  "o nt ouchst ar t" in  th i s  } function pe( t,   n,  e) {  t. protot yp e  =   n. prototype =  e,  e.construct or   =  t } functio n  ge(t,  n ) { var e = Objec t.crea te(t .pr o t otype) ;  for (var r in n) e[r] = n[r ] ; return e } functi o n ye() { } fe.p rot o t ype . on = functi o n()  { var t  =  this._ . on.a pp l y(t h is._, ar gu m ents);  re t ur n  t  === th is . _   ? t hi s   :  t  };   v a r  v e =  . 7 ,  _ e  =  1  / ve, be = "\\ s *( [+-]?\\d+)\\s*",  me = "\\s*([+-]?(? :\\d *\\. )?\\d+(?:[e E] [+-]?\\d+)?)\\s*" , xe = "\\s*( [+-]?(?:\\d*\\. )? \\ d +(?:[eE ][+-]? \\ d + )?)%\\s* " ,  we = /^ # ( [0-9a-f] { 3 ,8})$/, Me =   n e w RegExp ( ` ^ rgb\\(${ b e} , ${be },${be}\ \)$ ` ),   Te  =   n e w   R e gE x p(`^rgb\\(${ x e } ,${xe},$ { x e }\\)$`),   Ae   = ne w   RegExp(`^rgb a \ \ (${be},$ { b e },${be}, $ {m e }\\)$ `), Se = n e w   Reg Exp ( `^ r gba \\( $ {x e },$ {xe},${xe} , ${me}\\)$`), E e  =  ne w  RegExp( `^h sl\\(${me},${xe} , ${xe} \ \)$`), Ne  =  n ew R eg E x p ( `^ h sla\\(${me},${ xe }, ${ x e},${m e }\\ )$`),  k e =  { ali c ebl ue: 15792383 ,  a n tiquewhite: 16 4 44375, a q ua :  65535, aqu a m ar i n e :  8 38 8 564, azure: 15 7 94175, b e ig e :   1 6 1 1 92 6 0,   bis q ue: 16770244,  b lack: 0, b l an ch edalmond :  1677 2 0 4 5, bl u e: 255, blu e v iole t : 905 5 202, brown: 10 8 24234,  b ur lywo od : 1459 6 2 3 1, ca d etblue: 626 6 528,  c hartre use:   8388352, choco l at e: 13789470, cora l: 16744272, cornf lowe rblu e: 6591981,  c ornsilk: 1677538 8,  c r imson:  1 442 310 0,   cya n: 6 5535, darkblue: 13 9 ,  da rk cya n : 3 5 7 2 3, d arkg oldenrod: 1 20929 3 9, darkgray: 11 1190 1 7,  darkgreen: 2560 0 ,   d a rkg r ey : 11119017, d a rkk h aki :  1243 3259 , darkmage n ta: 9109643, d ar ko li v egreen:  559 7999, darkorange :  1674 7 520, dark or ch id:  10 0 4 0 0 12 ,  darkred: 9109 50 4,  d a rksalm o n:  153084 1 0,  darkse a gre en: 9419919,   da r kslateblue: 47 3 43 47, darkslat egray: 3100495, da rk sl ategrey: 31 00495 ,  da r ktu rquoise: 52945, da rkviolet: 9 6 9953 9, deeppink :  167 16947, dee p skyblu e:  49151,   dimgray: 69 0 8265, dimgrey: 69082 6 5,   dodge rb l u e :  20 03199,  firebri ck: 11674146,  f loralwhit e : 16775920, forestgr e en :  2263 84 2 ,   f uch sia: 16 711935,  gainsboro: 1 44 74460 ,  ghos t white:  1 631 6 671,   g old: 16766720 ,   g o l denrod :  143 2 9 120, gray: 84 2 1 5 0 4 , gree n : 32 768, greenyellow: 11403055 ,  g r ey :  84215 0 4, honeyd e w:   15 7 94160,   hotpink:   16 7 38 7 40, indi anred: 13458 5 2 4 , indigo:   4 9 15330,  i vor y: 16777200 ,   k haki: 15 7 8 7 660, lave n der : 15132410, l a vend erblus h:  167733 6 5, lawngree n : 8190976, lemonchiff on: 167 75885,   li g htblu e:   1 1 3 932 54, lightcora l:  15761536 ,  lightcyan: 14745599,  lightg oldenr o dy e llow:  1 6 4 4 8 210 , lightgray:  13 88232 3 , lightgreen: 9498256 ,  lig htgrey :  1388232 3,   lightpin k:   16758465 ,  l ightsalm on :  1675276 2,   li g hts ea g re e n:  21 4 28 9 0,   li g hts kyblue: 890034 6,  l ig h tslategr ay:  7833753, lights l ategrey: 78 3 37 53, lightsteelblu e: 11584734, light yell ow:  16777184, l ime: 65280, lim eg re e n: 3329 330,  l ine n : 16 4 4 567 0 , ma g e nta :  167 1 1 935 ,   m ar o o n :  8 38 8 608 ,  m e dium a q u a ma r i ne:   67 3 73 2 2,   me d ium b l ue: 205, me d i u m o rc h id:   1 2 21 1 667,   m e d iumpurple: 96 62 6 83 ,  me d iums eagreen: 397809 7 ,   m e diu m sl at eb lue: 80877 90,  m ediumspri ng gr een:  6 4 1 5 4 ,  m ediumturquoise :  47 72 3 00, me d ium violet r ed:  13047 1 73,  midnightblu e :  1 644912, mintcr ea m:  1 61 2 1850,   m i st y r o s e:  16770 273 ,   m o c c a s i n:   1 6 77 0 2 2 9 ,   n av a j o wh i t e :   1 6 7 6 8 6 85 ,   n a v y:   1 2 8, oldlace: 16 6 43558 ,  olive:  8 42 1376, olivedrab: 7 0 48739 ,   or a n g e :   1 67 5 3 92 0 ,  o r an g ered: 167293 4 4,  o r chid:   1 431 5 734 ,   p a l e gol d en r o d :   15 6 5 7 1 3 0 ,   pal e gr e e n :   10 025880, pale t u r qu o is e:  1 15 29 9 6 6, palevioletr e d: 14 3 81203, pa payawhip: 16773077 ,  peac h puff: 16767673 ,  pe r u :  13 4 68 9 91,   p ink:   1 6 76 1 035 ,   plu m : 1 4 5 2463 7 ,  p owd e r blue :  1 1 591 910, purple:   8 3 88 7 36 ,  re be cc a p urple:  66 97881,   red: 167116 8 0, rosyb r own:  1 2 3 57 5 19, royalblu e:  4286945, saddl ebrown:  91271 8 7,  salmon: 1641 68 82, sandy b rown: 16 0 3286 4,   s ea g reen: 305032 7,  seashell: 1677 4638, s ienna:   10 506797, silve r:  1263 2 256,  s kyblue: 89003 3 1 ,  slateb l ue:  6 970 0 6 1, slate g r ay: 7372944,  s l a tegrey :   7 37 2 944 ,   snow: 167759 3 0 , springgree n: 65407, steelbl u e:   4 6 209 8 0 ,  t a n: 1 380 8 78 0 ,   tea l :   32 8 96,  thi s tl e :   142 0 4888 , tomato: 167 3 7095 , turq u o is e:  4 25 1856, violet:  15 6 31086, wheat: 1611 3 331, whi t e :   1 6 777215, whites mo k e: 16 1 1 9 28 5, yello w : 167 7 6 960 ,  y e llow g r e en:   10145074 };  f unct i on   Ce() { retu r n   th i s.rgb().format H ex() } f un ct i on  P e( )  { return t hi s .rgb().f o r m atRgb() } f un ct i on ze(t)   { var n, e;  re t u rn t = (t +  " " ). t r i m () .toLowerCas e (), (n = we.exec( t ) )  ?  ( e  = n [1 ]. l ength, n =  p a r se I n t(n[1], 16), 6  = = = e ?   $ e (n ) : 3 == =  e ?  ne w  qe(n >> 8  &   1 5  |  n >>  4  & 240, n >>  4  & 15   | 240  & n, (15 & n)  < <  4 |  1 5 &  n , 1) : 8  == =  e ? De(n  > >  24 &  255,  n   >> 16  & 255 ,   n >> 8 & 255,  (255 & n)  / 255) : 4 === e ?   De(n >> 12   & 15  | n   >> 8  & 2 4 0, n  >> 8 & 15   | n > >   4  &   240, n >> 4 &  1 5  |  240  & n, ((15 & n)   << 4 | 15 & n) / 2 5 5) : n ul l )  : (n = M e . exec(t)) ? ne w   qe(n[1], n[2] ,   n[3], 1) : (n  =  Te . ex e c (t )) ?  n ew qe(255  * n [ 1]  /  10 0, 2 5 5 *  n [2 ] /  1 00,  2 55  * n[3]  /  100,   1 ) : ( n   = Ae. exec(t))  ?  D e(n[1], n[2 ] , n[3], n[ 4 ]) :  (n  =  Se.e xec ( t)) ?   D e( 2 5 5  * n[1 ]  / 100,  2 5 5 * n[2 ] / 100, 255 *  n [ 3 ]  /  1 00,  n[4])  :   ( n  = Ee.exec(t)) ? L e(n[1], n [ 2]   /  100, n[3]  / 100, 1) : (n =  N e.e xe c (t ) )  ?  Le(n[1] ,  n[2 ]  /   10 0 , n[ 3 ]  / 100, n [ 4 ]) : ke.hasOwn P roperty(t) ? $e(ke[t]) : "tr an sparent" === t ? new qe( N aN, NaN, NaN,  0)   : null   }   f unction  $ e( t )   {  return new  qe(t >>  1 6  &   255, t >> 8 &   2 55, 255 & t,  1)  }  f un c t io n De(t,  n , e, r)  { retu rn  r  < =  0  && (t =   n = e  = NaN), new qe(t,   n,  e,   r)   }  f unction  R e(t) { r eturn t  i n stanceof ye ||  ( t  = ze ( t)), t ?  new qe(( t  =  t . rgb ()).r, t.g,   t.b, t.opacity) :  n ew   qe   }   fun c t i on Fe(t, n, e,  r )  { retur n  1  = = = a rguments.le n gth ? Re ( t)   :  n e w   q e (t, n, e, null  = =  r ? 1   :  r)   }  fu nct ion qe(t,  n,  e ,  r) { thi s. r = +t,  th is . g =  +n,  thi s .b  = +e, t hi s.opacit y  =  + r }  fu nction   Ue()   { return  `#${ Y e(th i s.r)} ${Ye(this.g)}${Ye( t his .b)}` }  func t ion Ie()  { const   t  = Oe( t his.opacity); return `${1 === t ? "rgb(" : "rg ba ( "}${Be(this.r)}, ${Be (this .g)}, ${Be(thi s. b )}${1  == =  t   ? ")" : `, $ { t})`}` } fun c ti o n  Oe ( t ) {   r etu rn  is Na N(t )  ?  1  :  M ath.max(0,  Ma th . min(1, t)) } fu n ction Be ( t )  {  r eturn Math .ma x(0,   Math .m i n (255,  M ath .r o und(t ) | |  0 )) }  f unct i on Y e( t )  { ret u r n  ((t =  B e(t))  < 16 ?  "0 "  :  "") +  t .toS t r ing(16) } fun ction Le ( t, n, e,  r )  {  return r < = 0  ?  t =  n   =  e = N a N :  e <= 0  | |   e >=   1 ? t = n =   NaN : n <= 0 && (t   = NaN), new   Xe ( t, n, e,  r ) } functio n  je(t) { if (t in s tanceof  X e) r e tu r n new Xe( t.h, t.s, t . l,  t.opaci t y );   i f  (t insta n ceof ye  | | (t =  ze(t)), !t) retur n  n ew Xe; if (t i ns t anceof   X e) return  t; var n =  ( t  =  t.rgb()) .r  /   255,  e  = t.g /  255 ,   r  =  t.b / 2 55,   i  =   Math.m i n( n ,  e,  r ),   o = Math.max(n,   e,   r), a = NaN, u =  o  -   i, c  =  ( o  + i) / 2; retur n  u   ? (a = n = ==  o ? (e - r) / u  +  6 * (e <  r)  : e === o ? (r -  n ) / u +  2  :   (n - e )  /  u + 4, u /= c  <   .5 ? o +   i :   2  -  o - i, a *=   60) : u = c > 0 &&  c  <   1  ?   0  :   a , new X e( a , u ,  c, t.op ac i t y) } functi on  He(t, n, e ,  r) { re tu rn 1 = ==  argume nt s.lengt h  ?  je(t) : new X e( t,  n ,  e,   null = =  r  ? 1 :  r)   } function  X e ( t ,  n,  e ,  r)  {   th is. h  =   + t ,   t hi s. s  =  + n ,  t hi s . l =  + e , this.opac i t y   =  +r  }  f un ct i on  G e (t ) {   r e t u r n  ( t  =  (t   | | 0 )   % 3 6 0 ) <  0  ? t + 360  :  t } functio n  Ve(t) {  return Math. ma x (0,  Math. min(1, t ||  0 ))  } funct io n We(t,   n ,  e) { return 2 55  *  ( t  < 60 ? n + ( e  - n) * t / 60  :  t < 18 0  ?  e  :   t < 240 ? n + (e -  n )  * (2 4 0 -   t ) /  60 : n)   } pe( y e , ze,  { copy(t)  {  re tu rn  O b je ct .as s ig n (ne w  t his.c o nstructor, this, t)  }, di sp layab le( ) { retu rn   t hi s. rgb() .d is p la y a bl e( ) },  he x:   Ce,  fo rm at He x: Ce, formatHex8:  f u n c t i o n( ) { return this .rgb().format Hex8() }, for matHsl: funct io n()  { return j e( th is ) . for m a tH s l ( ) } ,   fo rma t R g b :  Pe ,  to St ring:  Pe }),  pe (qe, Fe, ge ( ye, { brig hter( t)   {  re turn  t  = n u l l  == t ? _e :   Math.pow( _ e ,  t ), new qe(t his.r * t ,  thi s.g * t, th is .b  *   t , t h i s.opacit y)  }, darker( t ) { retur n t =  n u ll  = = t ?  v e  :   Ma th.pow(ve,  t ), new q e ( t hi s.r * t, t his.g *  t,  th is.b * t, t hi s. op ac it y )  },  rg b ()   { r et u rn th i s }, clamp( )  { return  new  qe(B e(thi s.r),  Be(this .g ) ,  B e( this. b) ,  O e( t h is .o pacit y) )  } , disp lay a bl e ()  {  r eturn -.5 < =  this.r  & &   thi s . r  < 2 55.5 && -.5  <= this. g && this .g < 255. 5  &&  - . 5   <= th is.b && thi s .b  < 255.5   & & 0   < = this.op aci t y && th i s.opacit y  <= 1 } , hex: Ue, format H e x : Ue,  f ormatHex8: func t ion() {   ret urn `#${Ye( th is.r)}${Ye(this. g )}${Ye(th i s.b)}${Ye(255 * (i s NaN( this.opacity) ? 1 :   th i s.opaci ty)) }` } , fo rmat Rgb:  Ie , toStr ing: I e })), p e( X e, He, ge(ye, {   brighter(t)  {   r et u rn  t  = n u ll == t ? _e : Math.pow(_e, t), new Xe(this.h, this.s,  this. l * t, this.opacity) }, dark er( t)   { return t = null == t ? ve : Math. p ow(ve ,  t), new Xe( this .h,  this .s,  this . l *  t,  this .opa city)  }, rgb() { va r  t = t his . h % 360 + 36 0   *  ( t h i s.h <  0 ), n = isNaN( t)  | |  isNaN(this.s )  ?  0 : t hi s . s, e  =   this. l ,  r =  e   + (e  <   .5 ?  e   : 1 -   e )   *  n ,   i  =   2   *   e   -  r ;  re t urn ne w   qe(We(t >=   24 0  ?   t  - 240 : t  +  120,  i,   r ) ,  W e ( t ,  i ,  r), We(t  <   1 20  ?  t +  2 40 :  t  - 120, i, r) ,   th i s . o p a c i t y)   },   c l a m p()   {  r e t u r n   n e w  X e (G e ( t h i s.h ) ,  Ve(this.s), Ve(this . l ) ,  O e(t h i s.opacity)) }, displ a y a bl e ()  {   re t ur n  ( 0   <= this.s & &  this . s   <=   1  || is N a N ( th i s. s ))   && 0 <= thi s .l &&  thi s .l <= 1 &&   0 < =  t h is . op aci t y   &&   this.opacit y  <= 1  },  f ormatHsl() {   c o ns t   t = Oe (this. op a c i ty ) ;   r et u r n   `${1   = = = t   ?  "hsl(" : "hsla(" } ${G e ( t h i s.h)}, ${10 0   * Ve(this.s) } %, ${100 *  V e(thi s .l)}%${1 === t  ? " ) "   :  ` , ${t})`}`  }  } ) );  c o nst Ze = Math .P I /  180, Ke = 180   / Math.PI, Qe = .9 64 2 2, Je   = 1,   tr = .825 21 ,  nr = 4 /  2 9 , er =  6 / 2 9 ,  rr = 3  * er   *  er, ir = er  * er * er;  function or(t) { i f  (t instan c eof u r)  r eturn  ne w  ur(t .l, t.a,  t .b, t . o pa c i t y); if   (t inst an c eof pr)  return gr(t);   t instanceof qe ||  ( t  = Re ( t));   var n, e,  r   = lr(t.r),   i  = lr(t .g),  o   = lr(t. b), a   =  cr((.2225045  * r + .716 8786 * i + .060616 9  * o) / Je ) ; ret urn   r ===  i  & & i = == o ? n  =  e =  a   :  ( n   = cr(( . 4360747  *   r + .38 50649 * i + .1 4 30804 * o) / Qe), e  =  cr((.0139322  *   r + . 0 9710 4 5 * i + . 71 4 1733 * o)  /   tr)), n ew ur ( 1 16 * a  - 16,   5 00 * (n - a),  200 * (a -  e), t.opacity) }  f unction ar ( t, n,  e,   r) {  ret u rn 1 === argu ment s.length  ?  or(t )   :  n e w ur(t,  n , e , null  = =  r  ? 1   : r) }   functio n  u r(t, n,  e, r) { this. l  =  +t, t his . a  =  + n,   t his. b =  +e, t h is . o pacity =   +r   }  func t i on cr(t) {  r e t u r n t   >  ir ? M a th.p o w (t, 1 /  3) : t / rr + nr }   funct i on fr(t) {  return t >   er  ? t * t * t  :  rr *  (t - nr) } f u nc t i on sr(t ) {  r e tu rn   25 5  *  ( t  < = .0 03 1 30 8  ?  1 2. 9 2  *  t  : 1.055  *  Math.pow(t, 1 / 2 .4 ) - .055) } fun c tion lr(t)  {  retu rn   (t /= 25 5)  <= .04045 ?  t  / 12.92 : Math.pow((t + .055 )  / 1.055, 2.4) } function hr(t) { if (t i n stanceof pr )  return new p r(t .h , t.c, t.l, t . opacity);  i f (t ins ta n ceof ur  | | ( t  = or(t)), 0  = ==   t . a && 0 === t. b ) return n e w pr(NaN,  0  < t.l &&  t .l <   100 ? 0 : NaN,  t .l ,  t.op a city);  var n = Math.atan2( t. b,  t . a) * Ke; retu r n new  pr(n  <  0 ? n +   3 60  : n,  M at h .sqrt(t. a  *  t .a + t.b * t.b), t.l , t . o pacity)  } fu n ction dr(t, n ,  e ,  r)   { return  1  == =  a rg u me nts . leng t h ? hr( t )  :  n ew pr(t, n ,  e, nu ll   = = r   ?   1  :  r)  }  function  p r( t , n, e,  r )  {  this.h =   + t,   t his.c =  + n,   this.l =  +e, th i s.opa c i t y  = +r }   f u nc t ion  g r (t ) { i f (i sN a N ( t .h)) return n e w ur( t .l, 0, 0,   t . o pac i t y) ;  var  n  =  t . h  *  Ze; return ne w  u r( t.l ,  Mat h .cos(n) * t.c, Mat h . si n (n )  *   t . c ,  t.o p acity) } pe(ur ,   ar, ge(y e , { b ri gh ter ( t) { return new ur( t his .l  +  1 8 * (null  = =  t ? 1 : t), th is.a,  t h is .b, this . opacity) }, da rk er ( t) {  r eturn n ew ur(th i s.l  -  1 8   *  (n ull == t ? 1  :   t), this. a,  t hi s.b ,  thi s . opacity) },  r gb() { var t   =  (this.l + 1 6)  / 116, n  = isNaN(th is .a )  ?  t : t + th is .a / 500,  e = isNaN(this.b) ? t : t - this.b / 200; return  n e w qe( sr ( 3 .133 8 561   * (n  =  Q e   *  fr( n)) - 1.61 68 66 7 *  (t  =  Je  *  fr(t))  -  .49 0 61 4 6 * ( e  =  tr *  fr(e))), s r (- .9787684 *   n  + 1. 91 61415  * t + .03 3 454 * e),  sr (.0719453 *   n - . 2289914 *  t   +  1 .4052 4 27  * e),   this.opacit y) } } )), pe(pr , dr, ge(ye,  {  b rig ht e r( t)   {  re t ur n  n ew  p r (t hi s .h ,  t hi s.c, this.l +  18  *  ( nu ll   == t  ?  1 : t), this.o pa cit y )  }, darke r(t) {   return new pr(this. h , t his.c, this. l  -  1 8 * (n u l l == t ? 1 : t) , this.opacit y ) }, rg b ()  { return gr(this). rgb() }  })); var  yr = - .1 4 86 1,  v r = 1.78 2 77, _r = -.29 2 27, br  =  - .9 06 49, mr =  1. 972 94, xr = mr  *  br, wr =  m r *   vr, Mr = v r *  _r - b r  *  yr; fun cti on  Tr(t, n, e, r ) { ret urn  1   === argu m ent s.length ? func tion(t) { if (t instan ce of Ar) retu rn new A r(t.h, t. s, t.l, t.op a ci t y );  t insta n ceo f qe || (t = Re (t)); var n = t.r /  2 55, e = t.g  / 255,  r = t.b /  255, i = (M r  *  r + xr * n - w r  * e) /  (M r  +  xr - wr) ,  o  = r - i, a = (mr *  (e - i)  - _r *  o) /  br,  u = Mat h .sq rt(a * a + o * o)  /  (mr * i * ( 1 - i)),  c = u ?  Math.at an2 (a,   o)  * Ke - 1 2 0 :   N aN; return  n ew Ar(c < 0 ? c  +   36 0   : c ,   u,  i, t. o pacity) }(t) : new Ar(t,  n, e, null  == r ?  1 : r) }  fu nction  A r(t , n, e,  r )   {   t his.h = +t, t h is. s = +n ,   t his.l = +e ,  this.opacity = + r   } function  S r(t, n, e, r, i) { v ar o =  t  *  t,  a   = o   *  t; retur n ( ( 1 - 3 * t + 3 *  o  - a) *  n +  ( 4  - 6 * o + 3 * a)  *  e + (1 + 3  * t + 3  * o - 3 *  a)  *  r + a * i)  /  6  } function Er(t)  {  va r n = t.length  - 1; return  fu nction( e) { var r = e <= 0 ?   e =  0  :  e >= 1   ? (e  =  1, n -  1) :  M a th.fl oo r(e *  n) , i =  t[ r],  o  = t[r  + 1 ], a  = r > 0  ? t[r  - 1] :  2 * i - o , u = r < n  - 1  ? t[r +  2] :  2 * o  - i;  re tu r n Sr((e - r /  n)   * n,  a , i,  o,  u)  } } fun c tio n Nr(t) { var n = t.length; return function(e)  { var r  =  Math.floor((( e  % = 1)  <  0 ?  ++e  :  e) * n) ,  i  = t[(r + n - 1) % n], o = t[r % n], a = t[(r  + 1) % n ] , u = t[(r + 2 )  %  n];  r eturn Sr((e - r  /  n)  *  n,   i, o,  a, u) } } pe(Ar, Tr, ge(ye, { brighter(t ) { retu r n t = null ==  t  ?  _e :  Ma th . p ow(_e, t), new  A r (th is .h,   thi s.s, th i s.l  *  t ,  thi s . o pac it y)   }, darker( t)  {   re t urn t =   nu ll  == t ?   ve  : Math. p ow( ve, t), new Ar( this.h, thi s .s, this.l  *  t, this. op acity) }, r gb() { v ar t = is NaN(this.h)  ?   0  :  ( th is.h + 120) * Ze, n =   + this.l, e = is Na N (this. s)  ? 0 : this.s * n   * (1  -  n), r =  Ma t h .cos(t),  i  =  Ma th .si n(t);  r et u r n  n e w  qe(255 *  ( n  +  e * ( yr * r + v r *  i ) ),   255 * (n + e * (_r *  r  + br  *  i)), 2 5 5   *  (n + e * (mr  *  r) ) , this .o pa city) } })) ;  var kr =  t => () => t; fu nction Cr(t, n) {   retur n  functio n(e )   { return  t  +  e  *  n   }  }   function Pr (t,  n) {  v a r e =  n  - t;  r et u r n  e   ? Cr(t, e   >  1 80 ||  e < -180 ?  e  -  3 60 *   Ma th.ro u n d(e   /  360) : e)   : kr(is N a N ( t) ? n : t) }  fu nc t ion z r (t) {  return 1 == (t = +t) ? $r   : fun c tion(n,  e)  { return  e  - n ? f u nction( t , n, e) { ret urn t = Ma th.p ow(t, e), n   = Math.pow(n , e) - t, e   =  1 / e, functi on ( r) { r eturn  Math.pow( t  + r * n,   e)   } }(n, e, t) :  k r( i sN a N(n) ?   e  :  n ) }   } func ti o n $r(t, n) { v a r e = n - t; retu r n e ? Cr(t, e) : kr(isN a N (t) ? n : t) }   var Dr = function   t(n) { var e = zr(n); function  r(t, n)  {   var r = e((t =  F e( t )).r,  (n   =   F e(n )).r), i = e(t.g,   n.g),   o = e(t.b, n.b), a =  $r(t.opa cit y ,  n.o p a cit y ) ;   r e tur n  f un c t ion(n) { retur n  t. r  = r(n ),   t . g  =  i(n), t.b = o(n),   t.opa c ity = a(n), t + "" } } retur n r.gamma  = t, r  }(1 ) ;  fun c t ion   R r ( t )  {  r et ur n   function(n) {  va r  e , r, i  =  n .length, o = new  A rray(i ),   a  = new A rr ay(i) ,  u  = new  Ar r ay(i); for (e = 0; e  < i ;  + + e )r  =  Fe( n [ e]) ,  o [ e]  =   r . r  | |  0 ,  a[ e ]  = r. g || 0, u[e] = r.b || 0 ;   return o = t(o ),  a   = t(a) ,  u  = t(u), r.opacity   = 1, f un c t ion(t) {  r eturn  r .r  = o(t ),   r.g = a(t), r.b = u(t), r +  "" } } }  var  F r   =  Rr ( Er),   q r =   Rr ( Nr) ;   f u nc t io n   Ur( t ,  n) {  n || (n = []); var e, r = t ?  Math.min ( n .length, t.len gt h ) : 0,  i  = n.slice() ;  retu r n function(o)  { for (e =  0; e <  r;  + +e )i [ e]   =  t[ e] * (1 - o )  +  n[e] * o; return  i  } } function Ir(t) { return  ArrayBu ffer.isView( t)  & & !( t in s t anceof DataView )  }   f unction Or(t,  n)   { var  e,  r = n ? n.l e ngth  :  0, i = t ? M ath.min(r,  t.length ) :   0,  o   =  n ew  A rray(i), a  =  n ew Array(r); for ( e  = 0; e < i; ++e)o[e ] = Gr(t[e],  n[ e ]);  for  ( ;  e < r; ++e)a[e ]  =   n [e]; return fu nc t ion(t) { for (e =   0; e < i ; ++e)a[ e ] = o[e](t); r eturn a }  }   function Br(t,  n )  { var e   = n ew Date; r e turn t =  +t, n =   + n ,  function(r) {  r e turn e.setTime(t  *  (1 - r)  + n * r),  e  } } function  Yr(t, n) {   r eturn t = +t,  n  =  +n, fun c tio n(e) { ret u rn t * ( 1 - e) + n  *   e   } } fu n ction Lr(t, n) { var e, r  = {}, i = {};   for (e in null != =  t && "object" == typeof t | |   (t = { } ),  null !== n &&  " ob je c t" == typeof   n  || (n = {}),  n )  e in t ? r [ e]  = Gr(t[ e ] ,  n[e]) : i[e]  =  n[e]; return function(t)   { for (e in r )  i[e]  = r[ e ](t);  r eturn i } } v ar jr = /[-+ ] ?(?:\d+\.?\d * | \.?\d+)(?:[e E][ -+]?\d+ )?/g, Hr =  n ew Re g Exp(jr.sour c e , "g"); f unction Xr (t , n) { v ar  e ,  r, i,  o =  jr.la s tIndex = Hr.l a s tIndex =  0 ,  a = -1, u =  [ ] ,  c   =  []; for  (t +=  "" ,   n +=  " " ; (e = jr . e xec( t )) && (r = Hr . e xe c ( n) );)(i  =  r.in de x)   > o && (i  = n.slice( o,  i) ,  u[a] ? u[a]  +=  i  : u[++a] =  i ), (e = e[0] ) == =  ( r = r[0] )  ?  u[ a]  ? u[ a] +=  r : u[++a] = r  : (u[++a] = nu ll ,  c. push({ i:  a, x: Yr(e,   r) }) ) , o = Hr.la s t Index; re turn o < n .l ength &&  ( i  =  n.slic e(o ), u[a ]  ? u[a] += i  :   u[++a] =  i ) , u . l eng t h  <   2  ?  c[0] ?  functi o n (t) {   r eturn fun c t io n ( n)  { ret ur n  t(n)   + " " } }(c [ 0 ].x) : fu nction(t) {  r etu r n  func tio n ( )  {   return t  }   }( n) : ( n  = c. le ngth,  f un ct io n(t ) { for (v ar e, r =   0; r < n; ++r)u[ (e  =  c [r ]).i] = e.x( t); return u.jo in("") }) } fun ction Gr(t, n) { v ar e, r  = typeof n ;  return nu ll  == n ||  " bo o lean" = ==  r ? kr ( n) : ("number "   === r ? Y r   : "string" == =   r  ?   (e  = ze(n )) ? (n   =  e, D r )  : Xr : n   i nsta n ceo f   ze   ?  D r : n  i nstan ce of Date ?  Br : Ir(n)  ?  U r  : Array.is Array(n) ? Or :  "function" !=  typeof n.va lueOf &&  "f unctio n" != typeo f  n .toStr ing  || isNaN (n) ? Lr : Yr)(t , n ) } fu n ction Vr(t, n )   { return t   =  +t, n =  + n , functio n ( e) { return  Ma t h .round(t * (1   -  e )   +  n * e)  } } var   W r, Zr   =  180  /   Math.PI,  K r  = {   translateX: 0 ,   tr a n sl ateY:  0 , ro ta te: 0 ,  skewX :  0,  sc al e X :  1, scale Y : 1 } ; function Qr(t,  n, e, r, i, o ) { var a,  u, c; ret ur n (a = Mat h.sqrt(t *   t + n * n)) && (t /= a, n / = a), (c = t *  e  + n * r) & & (e -= t  *  c,  r -=  n  * c), (u =   M ath.sqrt( e   * e +   r  * r)) && (e  / =  u, r /=  u ,  c   / =  u), t *  r < n  *   e &&  ( t  = -t, n  =   -n ,   c  = -c,  a  =  -a),   { tra n slate X:  i, tr an sl at eY :  o, r otate:   Math.at a n2(n, t) *  Zr, sk ew X: Math.a tan(c) * Zr , sca leX: a ,  s caleY: u } } fun ction Jr(t, n,  e ,  r)  { fu nction i (t) {  return t. lengt h ? t.po p() +  " " : " " } re turn func tion( o, a) {  var  u = [], c  =  [ ]; re t urn o = t (o), a = t(a), function ( t ,  r, i, o, a, u)  { if (t != =  i || r !== o) { var  c  =  a .push( "t r a nslate(", n u ll, n,  n u ll, e); u.push({ i: c - 4, x: Yr(t, i) }, {  i : c -   2, x: Yr(r, o)  }) } els e  ( i  ||   o) && a.pu sh(" tr an slate("  +  i  +  n +  o  +   e)  }(o.translateX, o . trans l ateY, a .tr a n slate X , a . tr an s la t eY, u, c), funct ion (t,  n ,   e, o )  { t  ! == n  ? (t - n >  18 0  ? n  + = 360  :   n - t > 180  &&   ( t  + = 3 60), o.push({ i: e.push( i(e) + "ro ta te(", nu l l, r) -  2 ,  x : Yr(t ,  n) })) :  n && e . pu sh( i (e)  +  " r otate("  +  n   + r) } ( o.rotate ,  a . rotate ,  u,  c) , function (t, n, e, o )  {  t != =  n ? o. p us h( { i: e.push(i(e)  +  " skewX( ",   null, r) - 2,  x:  Yr(t, n)  } ) : n  & &  e.push(i(e) + "skewX (" + n  +  r) }(o.ske wX , a.skewX , u, c), functio n(t,  n , e, r , o, a) { if (t !==  e || n ! = =  r ) { va r u  =  o.pus h(i(o) + "s ca le ( ", nu l l, ",", nul l,  " )" );  a .p u sh( { i: u - 4,  x :   Yr(t, e) }, { i: u  - 2, x: Yr (n ,  r) })  }  e lse 1 === e && 1  = == r  | | o.push (i( o )  + "scale(" + e + "," + r + ") ") }(o.s cale X, o.sca leY ,   a.sc a l eX,   a. s cal e Y ,   u ,  c) ,  o   =  a   = nu ll, function(t) { f o r  (var n ,  e = -1, r  =  c.lengt h ; ++e < r;)u[(n =  c[e]).i] =  n. x( t ); ret ur n  u.join("") } } }  v ar ti   = Jr((fu nct i o n(t) { c o n s t  n  = new ("fun ct i on " == typeof DOMMatrix ? DOMMat r i x   : WebKit CSSM a tri x ) (t +   " ");   re t urn   n . i sI d en t i ty  ?  K r :   Qr(n .a , n.b, n .c, n.d,   n. e, n.f) }), "px, ", " px ) ", "de g) ") ,  n i  = Jr((f u nc t i on(t)  {  r eturn null == t ?   Kr :  ( Wr || (W r =   d ocume n t .cre at eElementNS ( " ht tp : //www. w 3.org/2 0 00/ s vg " , " g ") ),   Wr . setAttribute("tr a n sfo rm",   t ) , (t = Wr.t ran s form.baseVal.conso lidate()) ?  Q r( ( t = t. ma t r i x ).a , t.b, t.c, t.d,  t .e, t . f) : Kr)  }) , ", ",  ")" ,   ")") ;   fun c t i o n   ei( t )  {  r etur n  ((t  = Math.exp(t)) +  1  /  t) /  2  } var ri =  function t (n ,  e , r)  {  functio n  i (t , i)  {  var o, a, u = t[ 0 ],  c = t [1 ] , f = t[2], s  =  i[0], l =  i [1],  h  =  i[2], d = s - u, p =  l - c ,  g = d * d +  p  * p; if  (g < 1e-12) a =  Math.log(h / f) / n,  o = functi on (t )  { ret ur n [u + t * d ,  c +  t  * p, f * Mat h.exp(n * t  * a)] } ; e l se  {   va r  y  =  Math.sqrt( g) ,  v  = (h * h - f * f  +  r * g) / (2 * f * e * y) , _ = (h * h  -  f  *  f -  r  * g )   / (2 * h * e *  y ),   b =  Ma th.l og ( M at h .sq rt (v *  v + 1) - v) ,  m = Math.log(Math.sqrt(_  * _ + 1)  -  _); a =  ( m - b) / n,   o = function(t) {   var r   = t * a,  i = ei(b), o =  f  / ( e  *   y)   *   (i * funct ion(t)  { r e turn ((t =  M ath.exp(2 * t)) -   1) / (t + 1) }(n   *   r + b)  -   f un c t i on(t )  { return ( (t = Math.e x p(t))   - 1 / t )  / 2 }(b)); return   [u  + o *  d ,  c + o * p, f  *  i / ei(n  *  r + b )]  }  } return o.duration  = 1e3  *  a * n / Ma th .SQRT2, o  } return i.rho  = function(n) { var  e = Math.ma x (.001,  + n), r = e *  e ; ret u rn t(e, r, r  * r) }, i } (Math.SQ RT2 ,  2 ,  4 );   fu nc tion ii(t)  {  return function(n ,  e) { var r = t( ( n = He(n)).h ,  ( e = He ( e )).h), i = $r(n . s,   e.s),  o  = $r(n .l, e.l),  a  = $r(n.opacity, e.opacity);  return fun c tion(t) { return  n .h =  r (t), n.s = i(t),  n. l = o(t), n.opacity = a(t),  n  + " " }  }  } var  o i  = ii(Pr), ai = ii($ r ); function  ui (t) {  return func ti o n(n,  e ) { var r  =  t (( n =  dr(n)).h, (e =  d r( e )). h), i =   $ r(n.c, e.c), o  = $r(n.l,   e .l ) ,  a = $r(n . o pa city,  e.o p acity); re tur n  function(t) { r eturn n.h =   r(t), n.c = i(t), n.l  =  o ( t) ,  n.opa ci ty  =  a(t),  n + "" } }  }  var  c i = ui(Pr ), fi = ui($r); functio n  si(t) { return funct io n n(e) {   fu n ction  r(n ,  r) { var i = t ((n = Tr (n )).h, (r  = Tr(r)).h) ,  o =  $ r(n.s, r. s), a = $r(n.l, r.l), u   = $r(n.opacity, r.opa ci ty); ret u rn   functi on( t ) { return n.h  = i(t), n.s  =  o(t) , n.l = a(M a th.po w (t, e)),  n.opacity = u(t), n + " "  } } return e = +e, r .g a mm a = n, r }( 1)  } var li  = si(Pr), hi =  si($r); function  d i(t, n)  { void  0   = == n  &&   (n = t, t = Gr) ; for ( va r e = 0, r =  n.length -   1,  i = n[0],  o  = new Arr ay(r < 0 ? 0 : r ); e < r;)o[e] = t(i, i = n[ ++ e ]); return functi o n(t)  {  var n = Math .max(0, Mat h. min(r - 1,  Ma th.floor( t *= r))); retur n o[n](t  - n) }   }   var pi, gi,  yi  =  0,  vi = 0, _i   = 0, b i  =   1e3,  m i  = 0,  x i  = 0, wi  = 0, Mi = "object" == typeof pe rf o rmanc e   && per f or m a n ce.now  ? perform a n ce  :  Da te,   Ti  = "object" == typ e of wi n dow && w ind o w .requ e stA n im ati o nF r ame ? window.requestAnimatio nFrame.bind(window) :  function(t) { set Time o u t(t,   17)   };  fu nct io n Ai() { return xi  || (Ti(Si), xi = M i. now() + wi) }  f unctio n S i( )  {  x i   =   0  }  f un c ti o n  E i ( ) { this._call   = this ._t im e  =  t h i s . _ n e xt  =  n u l l   }  f u n c tion N i (t, n, e) { v a r r = new Ei;   return r.restart(t ,  n , e), r  }  fu nction ki( )  {   Ai(),  + + yi; for (var  t , n = pi; n;) ( t = xi -   n._time) > =  0  & &  n._call . cal l(void 0,  t ),   n = n ._ n ext; --yi } f u nction Ci() {   xi = ( mi  =  Mi .n o w ()) + wi, y i  =   v i = 0; try   {  ki( )   }  finally   { y i = 0, fun c ti o n() {  v a r t, n,  e  =  p i ,  r = 1 / 0; for   (; e;) e. _ call ? (r >   e._ t i m e && (r = e._t i me), t = e, e = e._next)  :  (n = e._nex t,  e ._ n ext = null,  e  = t ? t._next   = n :  pi  =  n) ;  g i  = t ,  z i ( r ) }( ) , x i   =  0 } } functio n  Pi()  { v ar  t  =   M i . now(), n =  t   -  m i ; n > bi &&   (w i  -=   n,   mi   =   t) } f u n c tio n  z i ( t)  {  y i   ||  (v i   & &  (v i   =  cl ea r Ti m eou t( v i) ) , t  -   xi   > 2 4  ?  ( t  <  1  /   0  & &  (v i = setTimeout ( Ci, t  -  M i.n o w( )  -   w i ) ) ,   _i   &&   (_ i  = c l e a rI n t e rv a l( _ i) ))  :  ( _ i  | |  ( m i  =  Mi. n o w () ,  _i =  s etInterv al ( Pi, bi)), yi  =  1, Ti(Ci)))  }  funct io n  $i ( t ,  n ,  e )  {   va r  r = new   Ei;  return n =   nu l l == n  ?   0 : +n, r.res t art((e => { r . stop() , t ( e   + n )  } ) ,   n,   e ) , r } Ei . pro totype = Ni . pr o totype  =   { constructor :  Ei, restart:   functi on( t,  n ,   e )   {   if  ( "f u n c ti o n"  ! =  t y p eof   t)   t h ro w  n e w   TypeErro r ("c allback is  n ot   a func ti o n " ); e = ( nu l l == e ? Ai()  :   +e) +   (null == n  ?  0   : +n), this ._ne x t  ||  gi  === this || ( g i ? gi._ n ext = thi s  : pi = thi s ,  g i  =  this), this._call   = t, this._ t ime = e, zi ( )  },  s top: fun c tion() { th i s._call &&  (t hi s ._ca ll =  n u ll, this._tim e  =  1 /  0 , zi()) } } ;  v a r Di = $t(" star t ",  " end" , "cancel", " i nterrupt " ) ,  Ri  =  [] ,  Fi = 0, qi   =  1 ,  U i = 2, Ii = 3, Oi  =  4, Bi = 5,   Yi = 6; fun c t ion  L i(t, n,  e , r, i, o)  {  var a = t. __ tr a nsit ion;  i f  (a) { if (e  in   a) re t urn } else  t ._ _ transition  = {} ;  ! fu ncti on(t, n, e) {   var r,  i  =   t . _ _t r a n s i tion;  f unction o(t )  {   e. s t a t e  = qi ,  e.timer.re s ta r t(a ,   e .delay, e.time), e . delay <= t  & & a(t - e.d e l ay)  }  functio n  a(o) { var   f, s, l, h;  i f  ( e.st ate  != =   qi) r eturn  c();  fo r (f in i ) if  ((h  =  i[ f]).name === e .n a me)  { if ( h.s t ate === Ii) ret ur n $ i (a); h.st ate  = == Oi ? (h.sta te = Yi, h.timer.stop(), h.on.call("interrupt ", t, t. _ _data__, h.index, h.gr o up), delete   i[f]) : +f < n && (h.state =   Yi, h.ti me r.s to p(), h.on.call("cancel" ,  t, t.__dat a __, h. in dex, h.group),  d el e te i[f ] )  } if ($ i (( f uncti on ( ) { e.st a te == =   Ii & &  ( e .sta t e   = Oi , e .timer . restart(u, e. d e lay, e.ti m e ),   u (o )) })),  e.stat e   = Ui,   e .on.call( " s ta r t ",  t, t. _ _data __ , e.i nd ex ,  e. g ro up),  e.st ate === Ui) { fo r (e.state = I i,  r  =  new A r ray(l =  e.twe e n .l en gt h) , f = 0, s = - 1 ; f < l; ++f )( h = e.t we en[f].valu e. call( t,  t.__data _ _,   e.index, e.group)) && (r[++s]   = h);   r.leng th  = s + 1 }  } f unction u(n)  {  fo r (var i = n   < e.du ra tion ? e.ea se. call(null, n  /  e. duratio n ) : (e .t imer.restar t(c ), e.state =  Bi ,  1), o = -1 ,  a = r .l ength; ++o  < a ;)r[o].call(t ,  i) ; e.s t ate == =  Bi && (e.on .ca ll("end", t,  t. __ da t a__, e . i nd e x, e.group), c ( )) } function c() {  for (var r in e.state = Yi,   e.time r . stop( ), del et e  i [ n], i ) retur n;  d e l ete t .__trans it io n   } i[n ] = e, e .t imer  =  Ni( o,  0, e .ti me)  }( t ,  e, {  name: n, inde x : r, g roup: i , on:  D i, tween: Ri,  t ime: o .time, del ay: o.del a y, dur a t ion:  o.du ration,  ease:  o.ease, time r: nul l, state: F i  } ) } functio n  j i (t,  n ) { var  e = Xi(t,  n); if  (e.state  >  Fi) th row new Err o r("too l at e; alread y schedu l ed ") ;   retur n e  } functi on Hi (t, n) { var  e = Xi (t, n); if  (e . state > Ii)  t h r ow n e w Error("t oo late ; already  runnin g" ); retu rn e } func t ion Xi(t ,  n) { var  e = t.__ t ra ns i t ion;  if (! e || !(e  = e[ n]))  thr ow n ew Er ror(" trans ition not foun d"); r eturn e } f u nction Gi(t ,  n )  { v a r e,  r,  i, o =  t.__transi t ion, a =   !0 ;  i f  (o) { f or (i in n =  null == n  ? null  :  n + "", o)  (e  = o[i]).nam e  === n ? (r =  e .state > Ui  &&  e.state < Bi,  e.s tate = Yi, e.t ime r.stop(), e.on .ca ll(r ? "inter ru pt "   :  "can ce l",  t,  t.__d ata __, e .in dex,  e.g roup ),  d e l et e o[ i] ) :  a =  !1;  a & & del ete  t.__ tra nsit io n  }   } functi on  Vi(t, n)  {  va r e,  r;  r et urn f un cti on( ) {  va r  i =  H i(t hi s,  t ) ,  o = i.t we en; if (o  != =  e)  fo r (va r  a  =  0, u  = ( r =  e  = o ).l en gth ;  a  < u; ++a)if ( r [a].na m e ===   n )  { (r = r.slic e ()).sp lice(a, 1) ;  break } i . tween = r } }   funct i on Wi(t, n, e) { var  r , i;  if ("function" != typeof e) thro w  new   Error; return functio n() {  var   o = Hi(t his ,  t), a = o . twee n;  if (a !== r) { i = (r =  a).slice(); for (var u  =  { name: n, v a lue: e }, c = 0, f = i.length;  c  < f; ++c)if (i [c].nam e  === n) { i[c]   = u ;  break } c ===  f &&   i.push(u) } o. tween =  i } } function  Z i(t, n, e) { v a r r =  t . _id ;   ret u r n t . e ach ( ( function()  { var t  = Hi(th i s ,  r); (t.value  | | (t. v alue = {}))[n] = e.ap ply(this, arguments) })), function(t) { return  Xi(t, r).value[n] } } function Ki(t, n ) { var e; return ("number" == ty peof n ? Yr : n insta nceof ze ? Dr : (e = ze(n)) ? (n = e,   Dr) :   Xr)(t, n) } func tion Qi(t) { retur n function() { thi s.removeAttribute(t) }  } func t ion Ji(t) { return func tion()  {  this.re move AttributeNS(t.space, t.local) } } function to(t, n, e) { var r, i, o = e + ""; return  function() { var a = this.g etAttribute(t); return a = == o ? null : a === r ? i :  i = n(r = a, e) }  } function no(t, n, e) { var r,  i, o = e + "" ; ret u rn function() { var a = this.getAttrib uteNS(t.spac e , t.local); r etur n a === o ? null :  a === r ? i : i = n(r = a, e) } } fun ction eo(t,  n , e) {  var r, i, o; ret u rn fun ction() { var a, u , c = e(this ) ; if (null != c)  retu rn (a = this.getAttrib ute(t)) === (u = c + "") ? nul l : a === r && u === i ? o :  (i = u, o = n(r = a, c)); this.rem oveAttribute(t) } } func tion ro(t, n, e) { var r, i, o; return fu nction() { var a, u, c =  e(this); if (null != c) return (a = this.ge tAttributeNS(t.s p ace, t.local ) ) ===   (u = c +  " " ) ? null : a === r  & &  u === i ? o : (i = u, o = n(r = a, c)); th is.removeAttrib uteNS(t.space, t.l ocal) } } function io( t, n) {   var e, r; function i()  { var i   = n.apply (this, arguments); return i !== r && (e  = (r = i) && f unction(t, n )  { ret urn  fu nction(e) { this.set A tt r ibuteNS ( t . s p ace, t. l o c a l, n.call(thi s, e)) } }(t ,  i)),  e }  re turn i._v a lue = n ,   i   }  functi o n   o o(t, n) { var e,  r; function  i () { v ar  i =  n.app ly (th is,  argum e nts); r e turn i  ! = =   r && (e = (r = i)  && function( t , n) {  re tur n func ti on( e)  { this . setAttr i bute(t,   n . c all( t his, e)) } }(t, i)), e } return i._value = n, i }  function ao(t, n)  { return funct ion() { ji(this, t) .delay = +n.apply(th is, a r guments) } }  fu nc t ion u o (t, n) { return n  = +n,  fu nc t io n() { j i (this, t ). de l a y  = n } } func ti on   co(t, n)  {  r eturn fun c ti on() { Hi( t his, t).du ration = +n . ap ply(this,  a r g uments) } } f u nc tion  f o(t, n) {  re turn n = +n,  function()  {  Hi(th is ,  t) .d ur at io n  =  n  }   } var   s o = Wn.prototype.constr u c tor; functi on  lo (t ) { retur n   f unction()   {  t hi s . st yle.remo v eP r ope r t y (t)  }   } va r  ho =  0 ;   fun ct i on p o (t, n,   e , r) {   t his._grou p s  = t, this._ p a rents =  n ,  this._n a m e = e, t h i s._id =  r   }  f u nc t i o n  g o( t )  { return Wn ( ) .transition(t) } fun ct ion  yo ()   { retur n  ++ho } var v o = Wn .p r ototy pe; po.pro t otype = go .prototype =   {  c onst ructor : po,   sele ct: functi on(t) { var n = th is ._name, e  = t hi s . _i d;   "fun ction"  ! = type of t  & & (t =  jt(t)); fo r   ( var   r  =  th i s . _groups, i  = r.lengt h ,   o =  n e w   Array(i), a  = 0; a <  i;   + +a) fo r   ( var u, c, f  = r[a],  s   =  f. le n g t h, l = o[a]  = new Arra y(s), h  =   0;  h <   s; ++h ) (u = f[h ] )  && (c =   t .call(u,   u .__data_ _ ,  h ,   f) )   &&   ( "_ _data _ _" in u && (c.__data__ = u._ _data__) ,   l[h] = c, Li(l[h], n, e, h, l, Xi(u, e ))); re tu rn new po(o , this. _ pa rents,  n ,  e) } ,  sele c tAll: function(t) { var n = this ._ name, e = this._id; "fu nc tion "  ! = typeof t && (t = Gt (t)); for (v a r r =  this._group s , i = r. l e n gt h,  o = [ ], a = [ ] , u  =  0 ;  u  <  i ;   + + u) f o r   ( v ar  c ,  f  =   r [ u ],   s   =   f .le n g th,  l = 0 ; l <  s; ++l)i f  (c  =  f [ l])  {  f or   ( v a r   h ,   d   =  t .c a l l (c,   c . _ _ d a t a _ _ ,   l,  f ) ,   p =   X i(c , e), g = 0, y =  d.length; g <  y; ++ g)(h =  d[g]) & & Li(h , n, e , g , d, p); o.push(d), a .push(c) } r e turn n ew po(o, a,   n, e) },   se le c t C h i ld:  vo.se lectCh ild, sel e ctC hi ld re n :   v o . s e l e ct Ch i ldr e n ,   f i l t e r :  f un c tio n ( t)  { "fun ction"  != type o f t  & &  (t = Vt(t ) );  f or   ( v a r  n   =   t h i s._ g ro up s ,   e   =  n . l e n g th,   r  =  n ew   A r r a y ( e ) ,  i  =   0;  i   <   e ;   + + i ) fo r  ( var   o , a  = n[i], u = a.le ngth, c  = r[i ] = [] , f = 0;  f < u ; ++f) (o  = a[ f]) && t.c a ll(o, o.__ data__, f,  a) &&  c .push(o); ret u rn  new po(r, this._parents, thi s. _nam e,  this._id) }, m erge: functi on( t) { if (t._ id  !== t h is._i d) t hr ow  n ew  E rr or ;  fo r (var n  =  this._ g roups , e = t._gr o ups,  r  = n.length ,  i =  e . l en g t h ,  o  =  Math.min(r, i) , a =  n ew Ar r ay(r), u  = 0;   u < o; ++u ) f or  (var c , f  =  n[u], s = e[ u ], l =  f .leng t h , h = a[u ] = ne w Arra y( l ), d   = 0;  d   < l;   ++d)( c  =  f[d] ||  s[d]) & &  ( h[ d ] =  c );  for   (;  u <   r ;   ++ u ) a [ u]  =  n [u ] ; re t ur n ne w  p o(a,   t h i s. _ p a r ent s, thi s._name,  thi s ._ id )  } , sel ectio n: functio n ( ) { r eturn  new so(th i s ._g r ou ps ,  this ._par ents) }, t r a nsiti on: f unction()  {   for   (v a r   t  =  thi s ._ name ,  n  = t h i s . _i d ,  e   =   y o( ),   r =  t hi s._g r ou ps,  i   =  r . l e ngt h ,   o  =   0; o   <  i; + + o) for  ( v a r  a ,   u  =   r [ o] ,  c  = u . le ngth ,  f  = 0 ;   f  <   c ;  ++f )if (a  = u[f])   {  va r  s =  Xi(a,   n ) ;  Li( a ,  t, e , f,  u ,   {  time :  s .t i me +  s.del a y   +  s.d u r ation , del a y :   0, d ur a t io n:  s .du r a ti o n ,  e a se :   s. e a se   } )  } retur n  new po(r, this._ pare n ts, t, e)   } ,  c al l:  vo . c al l ,  n o d es :   vo . n od e s ,  node: v o. node, size: vo.s ize,   empty: vo .empty, eac h:  v o .each, on: fu n ct io n (t, n) {   v ar e = th i s. _i d ; return   a rguments. length  < 2   ?  Xi(this .no d e( ), e).o n.o n (t ) : thi s.e a ch (function(t,   n, e ) {  va r r,  i, o = fu nction(t)  { return   (t + "").trim ( ). split(/^|\s+ / ).every((function(t) { var n  = t. indexOf(". " );  return n >= 0 &&  (t = t. s li ce(0, n)), !t ||   " start" === t })) }(n)  ?   j i :  Hi;  ret u rn function() {  va r a = o(this, t), u = a.on; u !== r && (i = (r = u).copy()).on( n, e),  a.on = i } }(e, t, n))  }, attr : function(t, n)  { var e = I t(t), r = " tr an s form" === e ?  ni : Ki; r e turn this.attr Twe en(t, " fu nction"  ==  typeof  n ?  ( e.local ? ro   : eo) (e, r, Zi(t his, "at tr." +  t ,  n)) : null = =  n ? (e .local ? Ji : Qi)(e )  : (e.local ?   no : to )(e, r, n)) }, attr T ween: functi o n(t,  n ) { var e =  "a t tr." + t;  if ( ar guments.length  <  2) return (e =  this.tween(e )) &&   e. _ v alue; if (nul l  == n) retu rn  t h is.twee n (e, null); if ("fun ction" != ty p eof n)  throw new Error; var r = It(t); r eturn this.tween(e, (r.local ? io :  oo)(r, n))  } , style : function(t, n,  e) { var r = "tran sform" == ( t  += " " ) ? t i   : Ki; retu r n  nul l == n ? th i s .styleTween( t ,  function(t, n) {  va r e, r,  i ; return func tion() { v a r  o = _n(thi s ,  t),  a =  (this.style. r emoveProper t y (t) ,  _ n(th is,   t ));  r eturn  o === a ?  null : o   === e && a  ===   r  ? i  : i   =   n (e =  o,   r = a) } }(t, r)). o n("en d .styl e . " + t, lo( t ) ) : "funct i o n" == typeof n ? t hi s.styleT w een(t, fun ct i on (t, n, e)  {   var  r, i, o; return f unctio n() { var a   = _n (th i s , t) ,  u  = e(this) , c = u + ""; return null  ==  u  && (thi s .style.remo ve P roperty(t ), c  =  u  = _n(this,  t ) ), a === c ?  null : a  = == r &&  c  === i ? o : ( i  = c, o = n(r = a, u ) ) } } (t, r, Zi(thi s , "s tyle ."  + t,  n))).each(f un c tion(t, n) { var e,  r , i, o, a = "s t yle ." + n, u = "end."  +  a;   return function()  { v ar c  =  Hi(th is, t), f =  c . on, s = null == c.value[a ]  ? o  ||  (o  = l o(n)) : voi d  0 ; f ===  e  && i === s ||  ( r = (e = f).copy()).on(u, i  = s), c.on = r  }  }(th is._ id , t))  : this.sty le Tw e en(t,   function(t, n, e) { va r r, i, o  = e + "";  return f u nction() { v ar  a = _n (t his, t); r eturn a === o ? null : a === r  ? i :  i  = n(r =  a , e )  }  } (t, r, n ) , e).on("en d .style." + t, null) },  s ty l eTween: fu nc tion(t,  n ,   e) { var r  =   " st yle." +  ( t += ""); i f  (arguments.length < 2)   re t urn (r = t hi s.tween( r ) )  && r._v al u e ;  if (null ==   n) return t h is.tween(r, null); if ( " fu n ction" !=  ty peof n)  t h r ow new E rr o r ;  return this. t ween(r, fun c tion(t, n, e) { var r,  i ;  f unc ti o n  o () { var o = n . apply(this,   arguments); return o != =  i   && ( r  =   (i  = o )  && functi o n(t,  n , e) { return  function(r ) { this .st y l e . s et P r operty ( t, n.call (t h is, r), e )  }  }(t, o,  e) ) , r } re tu r n  o ._ va l u e  =  n,   o }(t, n,  n u ll ==  e ? "" : e)) } ,  t ext: function(t) {  return  t h i s. twee n( "t e x t",   "function" ==  ty p eof t   ?  f u nctio n ( t) {  r e turn  function() {  v ar n =   t (this); t h i s.textContent   =  null  ==   n  ? "" : n }   }(Z i ( this, "text",   t ))   :  function(t) { retu rn func t i o n( )   { t hi s. tex t Cont e n t  =   t }  } (n ull   = =  t ?   "" :  t  + ""))   },   t ex tTwe e n: fu n ct ion (t) {  v ar   n  =  "tex t" ; i f   ( ar g u m ent s . l eng t h  < 1)   r e t u rn   (n =  th i s . tw e en ( n ) )  & &  n ._val u e;   if  (null == t )  re turn th is.tween (n,  null); if ("f u nction"   !=  t ype o f t) th r ow n e w E rror; return  t h i s . twee n ( n ,  f unc t i o n(t)  {  v ar n, e; fu nc ti on  r ( )  { va r   r  =   t.a p p l y(t h i s ,  argu m e n ts ) ; r e t u rn r ! ==  e && (n = (e =  r )  & &  f uncti o n ( t)  {  retu r n   fu n c tion(n)  { th is.text Cont ent = t.ca l l (this,  n ) } }(r)),  n  } return  r ._ valu e   =  t ,  r  }(t))  },  r e m ov e :  fun c tion ( )   {  re turn   t h is . o n("end. remov e", fun ctio n(t) { ret u r n func ti on() { var  n  = this.pa r en tNo d e ;  f o r  (var e  in   t h is . _ _tra n s ition)  i f (+e !== t )  return; n  & & n.re move C h ild( t his) }  } (this ._id)) }, tw ee n:  f u n ct io n(t ,   n ) { v a r  e = this._i d;  i f (t  + =   "",  ar g u m ents.l eng th < 2) { for  ( var r,  i  =   X i (t h is. n o d e( ),  e). t w e en ,   o = 0,  a = i .length ; o  < a ; ++o)if   ( (r = i [o ]).name ===  t ) return  r .v alu e ;   re t ur n null  }  r e t ur n  t hi s .ea c h ( (n ul l ==   n   ?  V i  : Wi)( e, t,  n)) },  del ay:  functio n ( t) { v ar  n = this._ id ; return  a rg ume n t s .l e ng th ? t his . e a ch (( " fun c ti on" == ty p eof t ? ao  : uo)(n,  t )) : Xi( th is.node(), n). d elay }, duratio n : funct i on(t) { v ar n = t h is._id; r eturn ar g u m e nts. l e ngth ?  t his.each((" fu nction" = =  typeof  t ?   c o  :   f o )(n, t ))   : Xi(this.node(), n).dur a ti o n  }, ease:   f u nction(t) { var n   = this._id;   return arguments.length   ?  t his.e ach (f u n ct ion(t, n) {  i f ("functio n " != typeof n) throw ne w  E r ro r;   r et urn function()  {  Hi(this, t ) .ease = n } }(n, t)) :  X i( t hi s. n o de (), n).ease  } , easeVaryi n g: function(t) { if ("f u nctio n"   ! =   type o f  t )  t h row new Err or ;  return this.each(funct i on(t, n) { retu rn function()  {  var e = n.appl y(th i s,  a r g um ents ); if  ( " f unction"   != typeo f  e )   thr ow   new E rr o r;   Hi( this, t).ease  =  e } } (t his._ id,  t)) } ,  e n d : functio n ( )  { var t, n ,  e = this, r  =  e._ i d, i =   e.siz e (); return new   Promise( ( function ( o, a) {  v ar u = {   value : a },   c =  { value: fu n ctio n( )   {  0  == --i &&  o () }  } ; e.each((func ti on()  {  va r e = Hi(this, r), i = e.on; i !== t &&  (( n  =  (t  = i).copy ())._.c a nc el .p ush(u), n._.interr u pt.pus h( u), n ._. end.pu s h( c ) ), e.on =   n  } )), 0 ===  i  && o() })) }, [Symbol.i t er a t o r]:  v o[Sy m bol.itera to r ] }; function _o(t) { re t urn ((t  * = 2) <= 1 ? t  *  t : --t   * (2   - t) + 1) /   2 }  fun ction bo (t ) { retur n  ((t *= 2 ) <= 1 ?   t * t * t  : (t -= 2) * t  *  t + 2) /  2   } var mo = function t(n)   { function e(t )  { r e turn Math.pow(t, n)  }  r et u rn n = +n, e.exponent = t, e }(3), x o  = function t( n ) {  f unction e(t) { r et ur n  1  -  M ath.pow(1 - t, n) } return n = +n, e.exponent =  t , e }(3), wo =   func t ion t(n)  {  f un ct i on  e ( t)  {   ret u r n ( ( t  *=  2 )  <=   1  ? Math.pow(t, n) : 2 - Math.pow(2 - t, n) ) / 2   } return  n   = +n, e.e x p o n en t   =   t,   e   } (3 ) ,   M o  =   M a t h . P I,  T o = M o /  2; funct ion Ao(t) { return (1 -  M ath.cos(Mo *  t )) /  2 } fu nc t ion  S o(t) { retu r n   1 . 00 0 97 75 17 1 06549 4   *  ( M a t h .p o w ( 2 ,   - 1 0  *   t )   -   . 00 0 9 765625) } fun c t ion Eo(t) { r e t u r n ((t *= 2)  < = 1 ? So(1 -   t )  :   2  -   S o(t  -  1) )   /   2  }   f u nc tion No(t)   {  r et ur n ((t *= 2) <= 1  ?   1  - Mat h . s qrt( 1 - t * t) : Math.sqrt(1 - (t -=  2 )   *   t) + 1) / 2 }  v a r   k o = 4 / 11, C o   =   6  /  1 1, Po = 8 / 11, zo = 3 / 4, $ o  = 9 / 11, Do   = 10  / 11 ,  Ro =  15  /  1 6,  F o  =  2 1  /  2 2 , q o   = 63  /   64,   Uo  = 1 / ko / ko; function Io(t) { return ( t = + t )   < ko ? Uo *  t   *   t : t < Po ?   U o   *  ( t   - =  C o )   *  t   +   z o   :   t  <  Do  ? U o * (t - =  $o) * t + Ro : Uo * (t  - = Fo) * t + qo } v a r  O o  =  1.70158, Bo = fun c ti o n t (n ) { function e(t) { retur n  ( t  =   +t )  *   t  *   (n *   ( t  -  1) + t) } return n = +n, e.overshoo t  = t,  e  }(Oo), Yo = function t(n) { fun c tion e(t) { r e tur n   - -t  *  t * ((t + 1) * n + t) + 1 } re tu rn n = +n, e.oversho o t   =   t, e }(Oo), Lo = functi o n   t ( n) { function  e (t) { r et ur n  ( (t *= 2) < 1 ? t * t * ( ( n + 1) *   t - n) : (t -=   2) * t *   ((n + 1 )  * t + n) + 2) /  2  } return  n  = +n, e.over s ho ot = t, e }(O o ), jo = 2 * M a th.PI, Ho =  f unction t(n,  e) { v a r r = Math.asin(1 / (n  = Math.max(1,   n))) * (e /= jo);   function   i (t) { return n   * So(- --t) * M a th.sin((r - t)   / e) } return i . amplitude = fu n ction(n) { retu r n t(n, e * jo)   }, i.period = funct i on(e) { return   t(n, e) }, i }(1,   .3), Xo = fun c tion t(n ,  e) { var r =   Math.asin ( 1 / (n = Math. m ax(1,   n)) )   * ( e   /=  j o );  f u nct i o n i ( t ) {   r eturn  1 - n * So( t  = +t)   *  Math.sin((t  + r) / e) }   r eturn i.ampli tude = func t i on(n) { retur n t(n, e *   jo )   }, i.period = funct i o n(e) { return  t(n,  e )  }, i   } (1, .3), Go =  f u nct i o n t(n, e) { v ar   r =   M ath.asin(1 / ( n = M a th .max ( 1 , n))) * (e / =  j o);   f unction i(t)  {  r etu rn  ( (t  =   2   * t -  1 )  <  0  ? n  *  S o ( - t )  *   M a t h .s in (( r  -  t )  /  e )  :  2  -   n   *   So ( t)   *  Math . si n ( ( r   +  t )   /   e) )  /  2  }  r e tu rn  i . am pl i t u d e  =   fu n cti on(n) { re t urn t( n ,  e * jo ) }, i.p er io d  = f u nct i on ( e)  {  re tur n  t(n,   e )  }, i }(1, .3) , Vo = { ti m e :  n ul l ,  delay: 0, duration: 2 50 ,   ease:  b o  }; fun ction Wo(t ,  n) {  f o r (var  e; !(e = t . __tran s i tion)  | | !(e = e[n]);)if (!(t = t .p a r entNod e ) ) throw  new Err or (` tr ans it ion ${n} not found`);  re t u rn e }   W n.proto type.interrupt  =  functio n (t) {   r et ur n th i s.each(( fu nction() { Gi ( this, t) }) )  }, Wn.prototype.transi t io n  = functio n( t) { var   n ,  e; t i ns t a nce of po ?  ( n = t._id,  t  = t._name) : (n = yo() ,  ( e   =  Vo).time  =  Ai(), t  =   n ull ==  t  ?   nu ll : t + "");  f or (var r =   this._groups, i = r.len g th ,  o = 0; o  <  i; ++o)f o r   (var a,  u   =  r [o], c = u.len g th, f = 0;  f  < c; ++f)(a = u[f]) &&   Li ( a, t, n, f ,  u, e ||  W o ( a, n));  r e t ur n new po(r,  t his._parent s , t, n) }; var Zo = [nu l l] ;  var Ko =  t  => () =>   t ;  functi on   Q o( t, { sourc e Event: n, t a rget: e, selection: r,  m od e : i, dispa tc h: o })  {   O bject.d ef i n eP roperties( t his, { type :  { value: t, enumerable :  ! 0 , configur ab le: !0 } ,   s ourceEv en t :  {  value:  n , enumerabl e : !0, configurable: !0  } ,  t ar ge t :  {  value:  e , enumerabl e : !0, configurable: !0  } ,  s el ec t i on : { value :  r, enumera b le: !0, configurable: ! 0  } ,  mod e:   {  val u e:  i ,   en u m erable :  !0, configurable: !0  }, _: { value:  o   } }) } f u n c tion J o ( t)  {  t .p reventDefault( ),   t.s topImme d i ate P r opagation ()  }  var  ta   = { n ame: " drag" },  na = { n a me: "space" },  e a  =  { name :  "han d l e" },   r a =   {  n a m e: "cente r "   } ;  c o ns t   { ab s : ia,   max:  o a , min :   aa }  =   Math;   f uncti o n  ua(t )  { retu rn  [+ t[0], +t[ 1 ] ]  }   f u nc t i on   ca ( t)   {  r et u rn   [ ua (t [ 0]) ,  ua(t[1] ) ] } var fa = {  n am e : "x",  h an dl es: ["w", "e"].map (v a) ,  input : fun c tion( t , n)  {  retu rn  null   == t  ?  null   : [[+ t[0] ,  n[ 0] [1 ] ],  [ +t[1],  n[ 1][1]]]   } , out p u t: fu n ct i on ( t)   {  r et u rn   t  &&   [t[0][0], t[1 ] [ 0]] }  } , sa  = {  name:  "y" , han dles: [ "n" , " s"].map (va), i npu t: f uncti on(t,  n)  { ret urn n ull = = t ?  nul l :  [[n[ 0][0 ], +t [0]],  [n[1 ][0] , + t[1]]]  }, ou tput : fu nctio n(t) {  re tur n t &&  [t[0 ][1],  t[ 1][1]]  } },  la  = {  name : "xy" , h and les: [" n", "w" , " e",  "s",  "nw",  "ne ", "s w", " se"]. map(v a), i nput:  funct ion (t)  { retu rn n ull == t ? nu l l : c a (t )   },   o ut p u t:  function(t)  {  retu r n t }  } , ha = { overlay:  " c rosshair", selectio n: " m ove", n :  "ns -res ize ",   e: "ew-resiz e", s : " ns- resize", w :  " ew -resize", nw:  "nw se -res i ze", ne: "nesw- r esize", se: "nw se -res ize" ,  sw: "nesw-re si z e" }, d a  = {  e :   "w" ,  w:  " e", nw: "n e", ne: "nw", se: "sw", sw: "se" }, pa  = { n :  "s " ,  s:  "n", nw: "sw", ne :  "s e ", se:  " ne ",  s w:   " nw" }, ga  =   { overlay:   1 ,   sel e c tion: 1,  n:  nul l,  e: 1, s: null , w :  -1,   n w : -1 ,  n e :  1, se :  1,  sw : -1   } ,  ya = { overlay : 1,   selection: 1,  n:  -1 , e :   n ull ,  s:  1 ,  w:   n ull, n w :   -1,  ne :   -1, se :  1,  sw : 1  };   f u nc tion va(t) { r etu r n   { ty p e:   t  } } f u n c t i o n  _a (t)   {  r e t urn !t . c t r l Key  &&  !t. b u tt o n   }  f u n ct ion ba() { var  t =   t hi s.ownerSVGEle m e n t | |   thi s ;  re tu rn t .h asAttribute("v iew Bo x")   ?   [[(t   =  t . viewBo x . b a s eVa l). x, t .y ] ,   [t .x + t.width,  t.y + t.heigh t ]] : [ [0 ,   0], [t.w i dt h.baseV a l.v a l ue, t.he i gh t.baseV a l.v a l ue]]  }   funct io n  ma()   {  r eturn   navigator.maxTouc hPoints || "ontouc h sta r t " in this } func tion xa(t)   { for (; ! t .__brush ; ) if (!( t = t.pa rent Node))  retu rn; return t.__brush  }  f unction wa(t) { v ar n, e = ba, r  = _a,  i  =   ma ,  o   = !0,   a  =  $t(" s tart", "brush", "en d"), u = 6; func t ion   c (n) { var e = n. property(" _ _brush", g ) .selectA l l (".ove rlay").d ata( [va("o verla y")]); e.enter().appe nd ( "rect").attr("class ", "overlay").attr ("pointer - ev e nt s ", " a ll") . a ttr("c ur sor" ,  ha.ov erl ay ) . merg e( e).each((func tion ()  { var t = x a (thi s) .ex tent; Zn(th i s). attr(" x ",   t [0][0]).a t t r(" y ", t[ 0 ][1]).a t tr( " width " , t[1][0 ] -   t[0] [0 ]). a ttr(" h eight",   t[1 ] [1] -   t[0][1])  })), n. sele c t A ll(".select i on").data ([va ("selection")]).enter( ) .ap pend("r e c t" ) . attr("cla s s ",  "sele cti on" ).att r ("cursor" , h a.selection).attr("fi ll",   "#777 ").attr("fill-o pacity ",  .3).attr("s t r o ke", "#fff"). a ttr("sha p e-re n deri n g" ,  " c r i spEdges"); va r  r  =  n.selectAll(".handle" ) .data ( t.han d l es, ( f u n c ti o n ( t )  {   return   t . type   } ) );   r . ex i t() . re move( ) , r.e nter() . a p p e nd(" re ct") . a t tr ( " c la s s",   (f uncti o n(t)  { retur n  " h a n dle  ha ndl e-- "  + t.type })).at t r( "curso r ", (functio n (t ) { return ha[t.typ e] })) , n .ea ch(f) . attr("fill", "non e " ).attr("pointer-e ve nts" ,  " al l ") .on ("mousedown.brush", h).filter(i) .on("tou c hs t a rt . br ush", h).on( " touchmove.b r ush", d).on("touchend.b r us h  touchcanc el .brush",   p ) .style("touch-ac t ion", "none"). s tyle(" -w e b ki t-tap-hi g hlight-colo r ", "rgba(0,0,0,0)") } f u nc t i o n   f()  {   v ar  t  =   Z n(this), n = x a (this).selection;  n   ?  (t . selectAll(".se le c tion").styl e( " di sp la y " , null).attr(" x ", n[0][0]) .a t tr ("y", n [ 0][ 1 ]) . a t t r ("width", n[1] [0 ]  -  n [0][0]) . a t tr ( " h e ig h t ", n[1][1]  -  n[0][1]), t . s e l e ctAll(".hand l e").style("di splay", null).a t t r ( " x " ,  ( function(t) {  r eturn "e" = = = t.type[t.typ e .length - 1 ]  ? n[1][0] -  u  / 2 : n [ 0][0] -  u  / 2 })).a tt r ("y", (function(t) { r eturn "s" ===  t. ty pe [0 ]  ? n[1 ][ 1]  -   u  / 2  :   n[0][ 1 ]  -   u  /   2   }) ) . at t r( " wi d t h", (fu n ct i on ( t ) { retu rn "n "  = ==  t . t yp e   ||  "s "  = = =  t . ty p e  ?   n [1 ] [ 0 ]  -   n[0 ] [ 0] + u  :  u   } ) ). a t t r (" h eig h t ", (func t i on ( t)  {  r eturn " e " = = =   t. t y pe | |   "w "   == =  t . t y pe   ?   n [1 ] [ 1 ]  -   n[ 0 ][ 1 ] +   u  : u }) ) )  :   t .s e l e c tA l l ( " .s e le c ti o n,. h a ndle").s t y le ( "di s pl ay", "n o ne" ).a tt r ( "x",   n u ll ) . a t tr ( " y " ,  n ul l ). a ttr ( " width",   n ul l ).a t tr ("heigh t ",  nul l)   }  fun c t i on   s ( t ,  n ,   e )  {  v a r  r  =  t . __brush . e mi t ter ;  r eturn ! r  ||  e && r. cle a n  ?  ne w  l (t, n,  e ) :   r  } function l( t , n, e) { this.that = t, t h is.args  =  n, this.state = t.__b ru s h, this.active = 0, th is . clean  =  e  } fun ct i on h(e)  {   if ((!n  | |  e.tou ches) && r.app ly (t hi s,  a r guments ) )  {  v a r  i , a ,   u,   c,   l,   h,  d ,   p ,  g ,  y, v, _ =   thi s, b = e.target.__ da ta__.type, m = "selec t i o n "  === (o && e .m et aK ey  ?  b   = "ove rl ay "  :  b)  ?  t a  :  o  &&  e .a lt Ke y  ?  ra : ea ,   x  =   t   = ==   s a   ?  n u l l  :   g a [ b] ,   w  =  t   = = =  f a  ?  n u l l  :   y a[ b ],   M   =  x a (_) ,   T   =  M . e x t e nt ,   A   =   M . s e l ect i o n ,  S   =  T [ 0] [ 0 ] ,  E   = T [ 0 ] [ 1] ,   N  =  T [ 1 ] [ 0] ,  k  =   T [ 1] [ 1 ] ,   C  =   0 ,   P   =   0 ,   z =   x   & &  w   & &  o  && e . s h if t Ke y ,  $  =  A r r a y. f r o m (e . t o u ch e s  | |  [ e],   ( t   =>   {   c on st n  =   t .i d en t if i er;   r e t ur n   ( t  =  ne(t ,   _ )) . po i nt 0  =  t.sli c e( ), t. i dentifier =  n ,  t }) ) ; Gi( _);  var D   =  s ( _,  argu me nts,  !0).befo rest art( ) ;  i f  ( "o ve rl a y"  = ==  b ) { A &&  (g  =   ! 0 );   c o n st   n  =  [ $ [0] ,   $ [ 1]   | |   $[ 0 ]] ;  M . sel e c t i on   =   A  =   [[ i  =   t = = =   s a  ?   S   :  a a( n [0 ] [0] ,  n[ 1 ][ 0 ]),   u  =  t  = ==   fa  ?  E : aa(n[ 0] [1 ] ,  n [ 1 ][ 1 ])], [l = t  = ==   s a   ?   N   :  o a ( n [ 0][ 0 ],   n[ 1] [0 ]) , d = t = = =   f a  ?   k  :  o a ( n [ 0] [ 1],   n [ 1 ][ 1 ] )] ] ,  $ . l e ng t h >   1   & &  I ( e )   }  e l s e   i   =   A [ 0 ][0 ] ,   u  =   A [0 ] [1 ] ,   l  =   A[1 ] [ 0 ] ,  d   =  A [1 ] [ 1 ] ;  a  =  i ,   c  =   u ,   h   =  l ,   p   =   d ;   v ar  R   =   Zn ( _ ) . at tr("p o i n te r -e v en t s",   " n o ne " ) ,   F  =   R . se l ec t Al l (". o v e r la y " ) . at tr("c u r s or " ,  h a[ b ]);   i f   (e . t o u ch es) D . m o ve d  =   U,   D.e nded  =  O ; else  {  var  q =  Z n(e .vie w ) . o n( " m ou s em o v e . br u sh" ,   U ,  ! 0 ) .o n (" m o u s eu p .br u s h " ,  O ,   ! 0 ) ;  o   & &   q . o n ( " key d o w n .b r u sh " ,  ( f u n ct i on( t )   {  s w i tc h  ( t . k e yC o de)   {   c as e   1 6 :   z  =   x   & &   w ;   b rea k ;   c as e   1 8 :  m ===   e a  & &  ( x  & &  (l   =   h  -   C   *  x ,   i   =  a  +   C  *  x) ,   w   &&   ( d   =  p - P   *   w,   u  =  c   + P   *   w ),   m   =  r a, I( t ) ) ;  b re a k;   cas e 32:   m  !== ea  & & m ! ==  ra  ||  (x  <   0   ?  l   =  h  -   C   :  x   > 0   & &   (i   =  a   -  C ) ,   w  <  0  ?   d   =  p   -   P   :  w   >   0   & &   ( u  =  c   -   P) ,   m  =  n a ,   F .a t tr( " c u r so r " ,  h a. s e l e ct i on) ,   I ( t) ) ;   b r e ak ;   d e f a u l t :   ret u r n   }J o ( t )  } ), !0 ) . o n( " ke y up . bru s h " ,  ( f u n c ti o n ( t )  {  s w it c h ( t . k e yC o d e )  {  case   1 6 :  z  & &  ( y  =  v   =   z  =   ! 1 ,  I(t)) ;   b re a k;   ca s e 1 8: m  = ==  ra &&  ( x < 0  ?  l  = h  : x  > 0 && (i  =  a ), w  <  0  ?  d  =  p   : w > 0  & & (u = c),  m = e a,   I(t)); break; case 32 : m ===  n a && (t.altKey   ?  (x   & & ( l  = h -  C  * x, i =   a  + C * x), w && (d   = p  -  P * w,   u  =   c  + P  *  w), m  =  ra)  : ( x  <   0 ? l  =  h   :  x   > 0  & & (i = a), w < 0   ? d = p : w >  0  && (u  =  c), m =  e a) ,  F. a t tr ("cursor ",  ha[b]), I(t )); break; default: return }Jo(t) }), !0), ae(e.view) }  f.call(_),   D. start(e ,  m.name) }   f u nc tio n U(t) { for (c o nst n of t.change d Tou ches || [t]) fo r  (const t of $)  t .id entifier === n . identifier && (t.cur = n e(n, _)); if ( z  && !y && !v && 1 = == $.length) {   const t = $[0]; ia( t.cur[0] - t[ 0 ]) > ia(t.cur[1] -  t[1]) ? v = !0   : y = !0 } for (const t of $) t .cur && ( t [0] = t.cur[0], t[1 ] = t.cur[1 ] ); g = !0, Jo(t), I( t) } function   I(t) { c o nst n   = $[0],  e  = n.point 0;  var r; sw it ch (C = n [0 ] - e[0],  P   =  n[1]   -  e[1], m )  {  case  n a :  c a s e   ta :   x  & &  ( C  =   oa (S  - i, a a (N   -  l , C) ) , a = i   + C ,  h  =   l +   C ) , w   & &  ( P  =  oa ( E   -  u,   aa( k   -  d ,  P )),   c   =  u  +  P,  p = d + P);   b r eak; ca s e  e a:   $[ 1 ]  ?   (x   &&  (a =  oa (S , a a(N, $ [ 0] [ 0 ] ) ),   h  =  oa( S , aa(N,   $[1][ 0] )),   x =  1) ,   w  &&  ( c   =  oa ( E,   a a( k , $[0][ 1 ])) ,  p  =   oa( E ,   aa( k,  $[1][1 ] )) ,   w   =  1 ) )  : (x   <  0  ? ( C  = oa(S -  i, aa(N   - i,  C) ),  a  =  i +   C ,  h =   l )  :   x   >  0  & &  ( C  =   oa(S  -  l,   aa( N   - l ,   C )),   a   =  i , h  = l +   C) ,   w  < 0  ?  ( P  = o a (E   - u ,  aa(k - u,  P)), c   = u +  P ,  p  = d )  :  w >   0   && ( P   =  o a( E  -   d ,  a a(k -   d,  P )),   c  =  u ,   p =  d  +  P) ) ;  b r eak ; case   ra :   x  && (a = oa(S, aa(N ,  i  -  C   * x) ),  h  =   o a( S , aa( N, l + C * x) )), w && (c  =  o a (E,  aa(k,  u  - P * w)), p = oa( E, aa ( k,  d  + P *  w )) )   }h   <  a   &&  (x  * = -1, r   = i, i = l, l   =  r, r = a, a =  h ,   h  = r, b  i n  d a  & &  F.attr("cursor" ,  ha[b = da[b] ])) , p < c && (w  * = -1, r = u, u = d,  d =  r, r = c, c =  p , p = r, b in pa &&   F. attr(" cu rs or ",  h a [b   = pa[b] ] )) ,   M. s e le c t io n   &&   ( A  =   M. s e le c t i o n), y & &  (a = A[0][ 0] ,  h  =  A[ 1 ][0]),  v   & &  ( c   =  A [ 0 ] [ 1] ,   p   =  A [ 1 ] [ 1 ] ) ,  A [ 0 ] [ 0 ]   == =   a  & &  A [ 0 ] [ 1]  = = =   c  & &   A [ 1] [ 0]   = = =  h   & &   A [1 ] [1 ] ===  p  | |  (M . s elec ti on  =  [ [a,  c], [h,   p]],  f.call( _ ), D .br ush(t,   m. n a me )) } function O(t)   { if ( f unc tio n ( t ) {  t.s topIm mediatePropag ation() }(t) ,  t . tou ches) { if (t.t o uc hes.l e ng th)  r etur n ;  n &&   clea r Ti meou t (n),   n  = se t Ti meou t (( func t io n() { n = n ull }), 500) } els e u e (t .view, g), q.on("k eyd o wn .brush keyup.brush  mo u se move.brush mouseu p .b rush", null); R.attr (" po int er- even ts" , "all" ),   F .a t t r("cursor", ha.ov erla y ), M.se l ection && (A  =   M.s e lec t i on) ,   f unc ti on ( t )  { return t [ 0] [0 ]  == = t[1][0]  | |  t[ 0][ 1] === t[ 1] [1 ]  } ( A )  & & ( M .s e lec t io n  =  nu ll, f.cal l(_)) ,  D .en d(t, m . na m e ) } } function d (t)   {  s(this, argum en ts ) .mov e d( t ) } function p(t )  { s ( th i s,  argume nts). e n ded(t ) } fu n c ti on  g( )   { var  n =  th is. _ _br ush   | |  {  sel e cti on:   n u ll  };  retu rn   n. e xte nt   =   ca( e.app l y( thi s,  ar guments)) , n.d i m = t, n } return c. mo ve =  fun cti on(n,  e, r )  { n.tween ? n.o n ("s tart . br ush" , (fu n ction (t)  {   s (this , arg um ent s ).b efo r e s tar t() . sta rt( t )   })) . on(" i nterrupt.brush end.b ru sh ", (f unc tion(t ) {  s (this, arguments ) .en d(t)   }) ).tw e e n( "b ru sh" ,  (fu nc t i on()  { var  n  =  t his , r   =   n._ _br u sh,  i  =   s (n,   argu m ents), o = r.selecti on ,  a =  t.in put("f unction" == type o f e  ? e . ap ply( t hi s, a r g um ents) : e, r.ex t ent) ,  u  = G r (o,  a );  fun c ti on c(t) { r.selection = 1 === t && null === a ? null : u(t), f.call(n), i.brush() } return null !== o && null !== a ? c : c(1) })) : n.each((function() { var n = this, i = arguments, o = n.__brush, a = t.input("function" == typeof e ? e.apply(n, i) : e, o.extent), u = s(n, i).beforestart(); Gi(n), o.selection = null === a ? null : a, f.call(n), u.start(r).brush(r).end(r) })) }, c.clear = function(t, n) { c.move(t, null, n) }, l.prototype = { beforestart: function() { return 1 == ++this.active && (this.state.emitter = this, this.starting = !0), this }, start: function(t, n) { return this.starting ? (this.starting = !1, this.emit("start", t, n)) : this.emit("brush", t), this }, brush: function(t, n) { return this.emit("brush", t, n), this }, end: function(t, n) { return 0 == --this.active && (delete this.state.emitter, this.emit("end", t, n)), this }, emit: function(n, e, r) { var i = Zn(this.that).datum(); a.call(n, this.that, new Qo(n, { sourceEvent: e, target: c, selection: t.output(this.state.selection), mode: r, dispatch: a }), i) } }, c.extent = function(t) { return arguments.length ? (e = "function" == typeof t ? t : Ko(ca(t)), c) : e }, c.filter = function(t) { return arguments.length ? (r = "function" == typeof t ? t : Ko(!!t), c) : r }, c.touchable = function(t) { return arguments.length ? (i = "function" == typeof t ? t : Ko(!!t), c) : i }, c.handleSize = function(t) { return arguments.length ? (u = +t, c) : u }, c.keyModifiers = function(t) { return arguments.length ? (o = !!t, c) : o }, c.on = function() { var t = a.on.apply(a, arguments); return t === a ? c : t }, c } var Ma = Math.abs, Ta = Math.cos, Aa = Math.sin, Sa = Math.PI, Ea = Sa / 2, Na = 2 * Sa, ka = Math.max, Ca = 1e-12; function Pa(t, n) { return Array.from({ length: n - t }, ((n, e) => t + e)) } function za(t, n) { var e = 0, r = null, i = null, o = null; function a(a) { var u, c = a.length, f = new Array(c), s = Pa(0, c), l = new Array(c * c), h = new Array(c), d = 0; a = Float64Array.from({ length: c * c }, n ? (t, n) => a[n % c][n / c | 0] : (t, n) => a[n / c | 0][n % c]); for (let n = 0; n < c; ++n) { let e = 0; for (let r = 0; r < c; ++r)e += a[n * c + r] + t * a[r * c + n]; d += f[n] = e } u = (d = ka(0, Na - e * c) / d) ? e : Na / c; { let n = 0; r && s.sort(((t, n) => r(f[t], f[n]))); for (const e of s) { const r = n; if (t) { const t = Pa(1 + ~c, c).filter((t => t < 0 ? a[~t * c + e] : a[e * c + t])); i && t.sort(((t, n) => i(t < 0 ? -a[~t * c + e] : a[e * c + t], n < 0 ? -a[~n * c + e] : a[e * c + n]))); for (const r of t) if (r < 0) { (l[~r * c + e] || (l[~r * c + e] = { source: null, target: null })).target = { index: e, startAngle: n, endAngle: n += a[~r * c + e] * d, value: a[~r * c + e] } } else { (l[e * c + r] || (l[e * c + r] = { source: null, target: null })).source = { index: e, startAngle: n, endAngle: n += a[e * c + r] * d, value: a[e * c + r] } } h[e] = { index: e, startAngle: r, endAngle: n, value: f[e] } } else { const t = Pa(0, c).filter((t => a[e * c + t] || a[t * c + e])); i && t.sort(((t, n) => i(a[e * c + t], a[e * c + n]))); for (const r of t) { let t; if (e < r ? (t = l[e * c + r] || (l[e * c + r] = { source: null, target: null }), t.source = { index: e, startAngle: n, endAngle: n += a[e * c + r] * d, value: a[e * c + r] }) : (t = l[r * c + e] || (l[r * c + e] = { source: null, target: null }), t.target = { index: e, startAngle: n, endAngle: n += a[e * c + r] * d, value: a[e * c + r] }, e === r && (t.source = t.target)), t.source && t.target && t.source.value < t.target.value) { const n = t.source; t.source = t.target, t.target = n } } h[e] = { index: e, startAngle: r, endAngle: n, value: f[e] } } n += u } } return (l = Object.values(l)).groups = h, o ? l.sort(o) : l } return a.padAngle = function(t) { return arguments.length ? (e = ka(0, t), a) : e }, a.sortGroups = function(t) { return arguments.length ? (r = t, a) : r }, a.sortSubgroups = function(t) { return arguments.length ? (i = t, a) : i }, a.sortChords = function(t) { return arguments.length ? (null == t ? o = null : (n = t, o = function(t, e) { return n(t.source.value + t.target.value, e.source.value + e.target.value) })._ = t, a) : o && o._; var n }, a } const $a = Math.PI, Da = 2 * $a, Ra = 1e-6, Fa = Da - Ra; function qa(t) { this._ += t[0]; for (let n = 1, e = t.length; n < e; ++n)this._ += arguments[n] + t[n] } let Ua = class { constructor(t) { this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = "", this._append = null == t ? qa : function(t) { let n = Math.floor(t); if (!(n >= 0)) throw new Error(`invalid digits: ${t}`); if (n > 15) return qa; const e = 10 ** n; return function(t) { this._ += t[0]; for (let n = 1, r = t.length; n < r; ++n)this._ += Math.round(arguments[n] * e) / e + t[n] } }(t) } moveTo(t, n) { this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}` } closePath() { null !== this._x1 && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`) } lineTo(t, n) { this._append`L${this._x1 = +t},${this._y1 = +n}` } quadraticCurveTo(t, n, e, r) { this._append`Q${+t},${+n},${this._x1 = +e},${this._y1 = +r}` } bezierCurveTo(t, n, e, r, i, o) { this._append`C${+t},${+n},${+e},${+r},${this._x1 = +i},${this._y1 = +o}` } arcTo(t, n, e, r, i) { if (t = +t, n = +n, e = +e, r = +r, (i = +i) < 0) throw new Error(`negative radius: ${i}`); let o = this._x1, a = this._y1, u = e - t, c = r - n, f = o - t, s = a - n, l = f * f + s * s; if (null === this._x1) this._append`M${this._x1 = t},${this._y1 = n}`; else if (l > Ra) if (Math.abs(s * u - c * f) > Ra && i) { let h = e - o, d = r - a, p = u * u + c * c, g = h * h + d * d, y = Math.sqrt(p), v = Math.sqrt(l), _ = i * Math.tan(($a - Math.acos((p + l - g) / (2 * y * v))) / 2), b = _ / v, m = _ / y; Math.abs(b - 1) > Ra && this._append`L${t + b * f},${n + b * s}`, this._append`A${i},${i},0,0,${+(s * h > f * d)},${this._x1 = t + m * u},${this._y1 = n + m * c}` } else this._append`L${this._x1 = t},${this._y1 = n}`; else; } arc(t, n, e, r, i, o) { if (t = +t, n = +n, o = !!o, (e = +e) < 0) throw new Error(`negative radius: ${e}`); let a = e * Math.cos(r), u = e * Math.sin(r), c = t + a, f = n + u, s = 1 ^ o, l = o ? r - i : i - r; null === this._x1 ? this._append`M${c},${f}` : (Math.abs(this._x1 - c) > Ra || Math.abs(this._y1 - f) > Ra) && this._append`L${c},${f}`, e && (l < 0 && (l = l % Da + Da), l > Fa ? this._append`A${e},${e},0,1,${s},${t - a},${n - u}A${e},${e},0,1,${s},${this._x1 = c},${this._y1 = f}` : l > Ra && this._append`A${e},${e},0,${+(l >= $a)},${s},${this._x1 = t + e * Math.cos(i)},${this._y1 = n + e * Math.sin(i)}`) } rect(t, n, e, r) { this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${e = +e}v${+r}h${-e}Z` } toString() { return this._ } }; function Ia() { return new Ua } Ia.prototype = Ua.prototype; var Oa = Array.prototype.slice; function Ba(t) { return function() { return t } } function Ya(t) { return t.source } function La(t) { return t.target } function ja(t) { return t.radius } function Ha(t) { return t.startAngle } function Xa(t) { return t.endAngle } function Ga() { return 0 } function Va() { return 10 } function Wa(t) { var n = Ya, e = La, r = ja, i = ja, o = Ha, a = Xa, u = Ga, c = null; function f() { var f, s = n.apply(this, arguments), l = e.apply(this, arguments), h = u.apply(this, arguments) / 2, d = Oa.call(arguments), p = +r.apply(this, (d[0] = s, d)), g = o.apply(this, d) - Ea, y = a.apply(this, d) - Ea, v = +i.apply(this, (d[0] = l, d)), _ = o.apply(this, d) - Ea, b = a.apply(this, d) - Ea; if (c || (c = f = Ia()), h > Ca && (Ma(y - g) > 2 * h + Ca ? y > g ? (g += h, y -= h) : (g -= h, y += h) : g = y = (g + y) / 2, Ma(b - _) > 2 * h + Ca ? b > _ ? (_ += h, b -= h) : (_ -= h, b += h) : _ = b = (_ + b) / 2), c.moveTo(p * Ta(g), p * Aa(g)), c.arc(0, 0, p, g, y), g !== _ || y !== b) if (t) { var m = v - +t.apply(this, arguments), x = (_ + b) / 2; c.quadraticCurveTo(0, 0, m * Ta(_), m * Aa(_)), c.lineTo(v * Ta(x), v * Aa(x)), c.lineTo(m * Ta(b), m * Aa(b)) } else c.quadraticCurveTo(0, 0, v * Ta(_), v * Aa(_)), c.arc(0, 0, v, _, b); if (c.quadraticCurveTo(0, 0, p * Ta(g), p * Aa(g)), c.closePath(), f) return c = null, f + "" || null } return t && (f.headRadius = function(n) { return arguments.length ? (t = "function" == typeof n ? n : Ba(+n), f) : t }), f.radius = function(t) { return arguments.length ? (r = i = "function" == typeof t ? t : Ba(+t), f) : r }, f.sourceRadius = function(t) { return arguments.length ? (r = "function" == typeof t ? t : Ba(+t), f) : r }, f.targetRadius = function(t) { return arguments.length ? (i = "function" == typeof t ? t : Ba(+t), f) : i }, f.startAngle = function(t) { return arguments.length ? (o = "function" == typeof t ? t : Ba(+t), f) : o }, f.endAngle = function(t) { return arguments.length ? (a = "function" == typeof t ? t : Ba(+t), f) : a }, f.padAngle = function(t) { return arguments.length ? (u = "function" == typeof t ? t : Ba(+t), f) : u }, f.source = function(t) { return arguments.length ? (n = t, f) : n }, f.target = function(t) { return arguments.length ? (e = t, f) : e }, f.context = function(t) { return arguments.length ? (c = null == t ? null : t, f) : c }, f } var Za = Array.prototype.slice; function Ka(t, n) { return t - n } var Qa = t => () => t; function Ja(t, n) { for (var e, r = -1, i = n.length; ++r < i;)if (e = tu(t, n[r])) return e; return 0 } function tu(t, n) { for (var e = n[0], r = n[1], i = -1, o = 0, a = t.length, u = a - 1; o < a; u = o++) { var c = t[o], f = c[0], s = c[1], l = t[u], h = l[0], d = l[1]; if (nu(c, l, n)) return 0; s > r != d > r && e < (h - f) * (r - s) / (d - s) + f && (i = -i) } return i } function nu(t, n, e) { var r, i, o, a; return function(t, n, e) { return (n[0] - t[0]) * (e[1] - t[1]) == (e[0] - t[0]) * (n[1] - t[1]) }(t, n, e) && (i = t[r = +(t[0] === n[0])], o = e[r], a = n[r], i <= o && o <= a || a <= o && o <= i) } function eu() { } var ru = [[], [[[1, 1.5], [.5, 1]]], [[[1.5, 1], [1, 1.5]]], [[[1.5, 1], [.5, 1]]], [[[1, .5], [1.5, 1]]], [[[1, 1.5], [.5, 1]], [[1, .5], [1.5, 1]]], [[[1, .5], [1, 1.5]]], [[[1, .5], [.5, 1]]], [[[.5, 1], [1, .5]]], [[[1, 1.5], [1, .5]]], [[[.5, 1], [1, .5]], [[1.5, 1], [1, 1.5]]], [[[1.5, 1], [1, .5]]], [[[.5, 1], [1.5, 1]]], [[[1, 1.5], [1.5, 1]]], [[[.5, 1], [1, 1.5]]], []]; function iu() { var t = 1, n = 1, e = K, r = u; function i(t) { var n = e(t); if (Array.isArray(n)) n = n.slice().sort(Ka); else { const e = M(t, ou); for (n = G(...Z(e[0], e[1], n), n); n[n.length - 1] >= e[1];)n.pop(); for (; n[1] < e[0];)n.shift() } return n.map((n => o(t, n))) } function o(e, i) { const o = null == i ? NaN : +i; if (isNaN(o)) throw new Error(`invalid value: ${i}`); var u = [], c = []; return function(e, r, i) { var o, u, c, f, s, l, h = new Array, d = new Array; o = u = -1, f = au(e[0], r), ru[f << 1].forEach(p); for (; ++o < t - 1;)c = f, f = au(e[o + 1], r), ru[c | f << 1].forEach(p); ru[f | 0].forEach(p); for (; ++u < n - 1;) { for (o = -1, f = au(e[u * t + t], r), s = au(e[u * t], r), ru[f << 1 | s << 2].forEach(p); ++o < t - 1;)c = f, f = au(e[u * t + t + o + 1], r), l = s, s = au(e[u * t + o + 1], r), ru[c | f << 1 | s << 2 | l << 3].forEach(p); ru[f | s << 3].forEach(p) } o = -1, s = e[u * t] >= r, ru[s << 2].forEach(p); for (; ++o < t - 1;)l = s, s = au(e[u * t + o + 1], r), ru[s << 2 | l << 3].forEach(p); function p(t) { var n, e, r = [t[0][0] + o, t[0][1] + u], c = [t[1][0] + o, t[1][1] + u], f = a(r), s = a(c); (n = d[f]) ? (e = h[s]) ? (delete d[n.end], delete h[e.start], n === e ? (n.ring.push(c), i(n.ring)) : h[n.start] = d[e.end] = { start: n.start, end: e.end, ring: n.ring.concat(e.ring) }) : (delete d[n.end], n.ring.push(c), d[n.end = s] = n) : (n = h[s]) ? (e = d[f]) ? (delete h[n.start], delete d[e.end], n === e ? (n.ring.push(c), i(n.ring)) : h[e.start] = d[n.end] = { start: e.start, end: n.end, ring: e.ring.concat(n.ring) }) : (delete h[n.start], n.ring.unshift(r), h[n.start = f] = n) : h[f] = d[s] = { start: f, end: s, ring: [r, c] } } ru[s << 3].forEach(p) }(e, o, (function(t) { r(t, e, o), function(t) { for (var n = 0, e = t.length, r = t[e - 1][1] * t[0][0] - t[e - 1][0] * t[0][1]; ++n < e;)r += t[n - 1][1] * t[n][0] - t[n - 1][0] * t[n][1]; return r }(t) > 0 ? u.push([t]) : c.push(t) })), c.forEach((function(t) { for (var n, e = 0, r = u.length; e < r; ++e)if (-1 !== Ja((n = u[e])[0], t)) return void n.push(t) })), { type: "MultiPolygon", value: i, coordinates: u } } function a(n) { return 2 * n[0] + n[1] * (t + 1) * 4 } function u(e, r, i) { e.forEach((function(e) { var o = e[0], a = e[1], u = 0 | o, c = 0 | a, f = uu(r[c * t + u]); o > 0 && o < t && u === o && (e[0] = cu(o, uu(r[c * t + u - 1]), f, i)), a > 0 && a < n && c === a && (e[1] = cu(a, uu(r[(c - 1) * t + u]), f, i)) })) } return i.contour = o, i.size = function(e) { if (!arguments.length) return [t, n]; var r = Math.floor(e[0]), o = Math.floor(e[1]); if (!(r >= 0 && o >= 0)) throw new Error("invalid size"); return t = r, n = o, i }, i.thresholds = function(t) { return arguments.length ? (e = "function" == typeof t ? t : Array.isArray(t) ? Qa(Za.call(t)) : Qa(t), i) : e }, i.smooth = function(t) { return arguments.length ? (r = t ? u : eu, i) : r === u }, i } function ou(t) { return isFinite(t) ? t : NaN } function au(t, n) { return null != t && +t >= n } function uu(t) { return null == t || isNaN(t = +t) ? -1 / 0 : t } function cu(t, n, e, r) { const i = r - n, o = e - n, a = isFinite(i) || isFinite(o) ? i / o : Math.sign(i) / Math.sign(o); return isNaN(a) ? t : t + a - .5 } function fu(t) { return t[0] } function su(t) { return t[1] } function lu() { return 1 } const hu = 134217729, du = 33306690738754706e-32; function pu(t, n, e, r, i) { let o, a, u, c, f = n[0], s = r[0], l = 0, h = 0; s > f == s > -f ? (o = f, f = n[++l]) : (o = s, s = r[++h]); let d = 0; if (l < t && h < e) for (s > f == s > -f ? (a = f + o, u = o - (a - f), f = n[++l]) : (a = s + o, u = o - (a - s), s = r[++h]), o = a, 0 !== u && (i[d++] = u); l < t && h < e;)s > f == s > -f ? (a = o + f, c = a - o, u = o - (a - c) + (f - c), f = n[++l]) : (a = o + s, c = a - o, u = o - (a - c) + (s - c), s = r[++h]), o = a, 0 !== u && (i[d++] = u); for (; l < t;)a = o + f, c = a - o, u = o - (a - c) + (f - c), f = n[++l], o = a, 0 !== u && (i[d++] = u); for (; h < e;)a = o + s, c = a - o, u = o - (a - c) + (s - c), s = r[++h], o = a, 0 !== u && (i[d++] = u); return 0 === o && 0 !== d || (i[d++] = o), d } function gu(t) { return new Float64Array(t) } const yu = 22204460492503146e-32, vu = 11093356479670487e-47, _u = gu(4), bu = gu(8), mu = gu(12), xu = gu(16), wu = gu(4); function Mu(t, n, e, r, i, o) { const a = (n - o) * (e - i), u = (t - i) * (r - o), c = a - u, f = Math.abs(a + u); return Math.abs(c) >= 33306690738754716e-32 * f ? c : -function(t, n, e, r, i, o, a) { let u, c, f, s, l, h, d, p, g, y, v, _, b, m, x, w, M, T; const A = t - i, S = e - i, E = n - o, N = r - o; m = A * N, h = hu * A, d = h - (h - A), p = A - d, h = hu * N, g = h - (h - N), y = N - g, x = p * y - (m - d * g - p * g - d * y), w = E * S, h = hu * E, d = h - (h - E), p = E - d, h = hu * S, g = h - (h - S), y = S - g, M = p * y - (w - d * g - p * g - d * y), v = x - M, l = x - v, _u[0] = x - (v + l) + (l - M), _ = m + v, l = _ - m, b = m - (_ - l) + (v - l), v = b - w, l = b - v, _u[1] = b - (v + l) + (l - w), T = _ + v, l = T - _, _u[2] = _ - (T - l) + (v - l), _u[3] = T; let k = function(t, n) { let e = n[0]; for (let r = 1; r < t; r++)e += n[r]; return e }(4, _u), C = yu * a; if (k >= C || -k >= C) return k; if (l = t - A, u = t - (A + l) + (l - i), l = e - S, f = e - (S + l) + (l - i), l = n - E, c = n - (E + l) + (l - o), l = r - N, s = r - (N + l) + (l - o), 0 === u && 0 === c && 0 === f && 0 === s) return k; if (C = vu * a + du * Math.abs(k), k += A * s + N * u - (E * f + S * c), k >= C || -k >= C) return k; m = u * N, h = hu * u, d = h - (h - u), p = u - d, h = hu * N, g = h - (h - N), y = N - g, x = p * y - (m - d * g - p * g - d * y), w = c * S, h = hu * c, d = h - (h - c), p = c - d, h = hu * S, g = h - (h - S), y = S - g, M = p * y - (w - d * g - p * g - d * y), v = x - M, l = x - v, wu[0] = x - (v + l) + (l - M), _ = m + v, l = _ - m, b = m - (_ - l) + (v - l), v = b - w, l = b - v, wu[1] = b - (v + l) + (l - w), T = _ + v, l = T - _, wu[2] = _ - (T - l) + (v - l), wu[3] = T; const P = pu(4, _u, 4, wu, bu); m = A * s, h = hu * A, d = h - (h - A), p = A - d, h = hu * s, g = h - (h - s), y = s - g, x = p * y - (m - d * g - p * g - d * y), w = E * f, h = hu * E, d = h - (h - E), p = E - d, h = hu * f, g = h - (h - f), y = f - g, M = p * y - (w - d * g - p * g - d * y), v = x - M, l = x - v, wu[0] = x - (v + l) + (l - M), _ = m + v, l = _ - m, b = m - (_ - l) + (v - l), v = b - w, l = b - v, wu[1] = b - (v + l) + (l - w), T = _ + v, l = T - _, wu[2] = _ - (T - l) + (v - l), wu[3] = T; const z = pu(P, bu, 4, wu, mu); m = u * s, h = hu * u, d = h - (h - u), p = u - d, h = hu * s, g = h - (h - s), y = s - g, x = p * y - (m - d * g - p * g - d * y), w = c * f, h = hu * c, d = h - (h - c), p = c - d, h = hu * f, g = h - (h - f), y = f - g, M = p * y - (w - d * g - p * g - d * y), v = x - M, l = x - v, wu[0] = x - (v + l) + (l - M), _ = m + v, l = _ - m, b = m - (_ - l) + (v - l), v = b - w, l = b - v, wu[1] = b - (v + l) + (l - w), T = _ + v, l = T - _, wu[2] = _ - (T - l) + (v - l), wu[3] = T; const $ = pu(z, mu, 4, wu, xu); return xu[$ - 1] }(t, n, e, r, i, o, f) } const Tu = Math.pow(2, -52), Au = new Uint32Array(512); class Su { static from(t, n = zu, e = $u) { const r = t.length, i = new Float64Array(2 * r); for (let o = 0; o < r; o++) { const r = t[o]; i[2 * o] = n(r), i[2 * o + 1] = e(r) } return new Su(i) } constructor(t) { const n = t.length >> 1; if (n > 0 && "number" != typeof t[0]) throw new Error("Expected coords to contain numbers."); this.coords = t; const e = Math.max(2 * n - 5, 0); this._triangles = new Uint32Array(3 * e), this._halfedges = new Int32Array(3 * e), this._hashSize = Math.ceil(Math.sqrt(n)), this._hullPrev = new Uint32Array(n), this._hullNext = new Uint32Array(n), this._hullTri = new Uint32Array(n), this._hullHash = new Int32Array(this._hashSize), this._ids = new Uint32Array(n), this._dists = new Float64Array(n), this.update() } update() { const { coords: t, _hullPrev: n, _hullNext: e, _hullTri: r, _hullHash: i } = this, o = t.length >> 1; let a = 1 / 0, u = 1 / 0, c = -1 / 0, f = -1 / 0; for (let n = 0; n < o; n++) { const e = t[2 * n], r = t[2 * n + 1]; e < a && (a = e), r < u && (u = r), e > c && (c = e), r > f && (f = r), this._ids[n] = n } const s = (a + c) / 2, l = (u + f) / 2; let h, d, p; for (let n = 0, e = 1 / 0; n < o; n++) { const r = Eu(s, l, t[2 * n], t[2 * n + 1]); r < e && (h = n, e = r) } const g = t[2 * h], y = t[2 * h + 1]; for (let n = 0, e = 1 / 0; n < o; n++) { if (n === h) continue; const r = Eu(g, y, t[2 * n], t[2 * n + 1]); r < e && r > 0 && (d = n, e = r) } let v = t[2 * d], _ = t[2 * d + 1], b = 1 / 0; for (let n = 0; n < o; n++) { if (n === h || n === d) continue; const e = ku(g, y, v, _, t[2 * n], t[2 * n + 1]); e < b && (p = n, b = e) } let m = t[2 * p], x = t[2 * p + 1]; if (b === 1 / 0) { for (let n = 0; n < o; n++)this._dists[n] = t[2 * n] - t[0] || t[2 * n + 1] - t[1]; Cu(this._ids, this._dists, 0, o - 1); const n = new Uint32Array(o); let e = 0; for (let t = 0, r = -1 / 0; t < o; t++) { const i = this._ids[t], o = this._dists[i]; o > r && (n[e++] = i, r = o) } return this.hull = n.subarray(0, e), this.triangles = new Uint32Array(0), void (this.halfedges = new Uint32Array(0)) } if (Mu(g, y, v, _, m, x) < 0) { const t = d, n = v, e = _; d = p, v = m, _ = x, p = t, m = n, x = e } const w = function(t, n, e, r, i, o) { const a = e - t, u = r - n, c = i - t, f = o - n, s = a * a + u * u, l = c * c + f * f, h = .5 / (a * f - u * c), d = t + (f * s - u * l) * h, p = n + (a * l - c * s) * h; return { x: d, y: p } }(g, y, v, _, m, x); this._cx = w.x, this._cy = w.y; for (let n = 0; n < o; n++)this._dists[n] = Eu(t[2 * n], t[2 * n + 1], w.x, w.y); Cu(this._ids, this._dists, 0, o - 1), this._hullStart = h; let M = 3; e[h] = n[p] = d, e[d] = n[h] = p, e[p] = n[d] = h, r[h] = 0, r[d] = 1, r[p] = 2, i.fill(-1), i[this._hashKey(g, y)] = h, i[this._hashKey(v, _)] = d, i[this._hashKey(m, x)] = p, this.trianglesLen = 0, this._addTriangle(h, d, p, -1, -1, -1); for (let o, a, u = 0; u < this._ids.length; u++) { const c = this._ids[u], f = t[2 * c], s = t[2 * c + 1]; if (u > 0 && Math.abs(f - o) <= Tu && Math.abs(s - a) <= Tu) continue; if (o = f, a = s, c === h || c === d || c === p) continue; let l = 0; for (let t = 0, n = this._hashKey(f, s); t < this._hashSize && (l = i[(n + t) % this._hashSize], -1 === l || l === e[l]); t++); l = n[l]; let g, y = l; for (; g = e[y], Mu(f, s, t[2 * y], t[2 * y + 1], t[2 * g], t[2 * g + 1]) >= 0;)if (y = g, y === l) { y = -1; break } if (-1 === y) continue; let v = this._addTriangle(y, c, e[y], -1, -1, r[y]); r[c] = this._legalize(v + 2), r[y] = v, M++; let _ = e[y]; for (; g = e[_], Mu(f, s, t[2 * _], t[2 * _ + 1], t[2 * g], t[2 * g + 1]) < 0;)v = this._addTriangle(_, c, g, r[c], -1, r[_]), r[c] = this._legalize(v + 2), e[_] = _, M--, _ = g; if (y === l) for (; g = n[y], Mu(f, s, t[2 * g], t[2 * g + 1], t[2 * y], t[2 * y + 1]) < 0;)v = this._addTriangle(g, c, y, -1, r[y], r[g]), this._legalize(v + 2), r[g] = v, e[y] = y, M--, y = g; this._hullStart = n[c] = y, e[y] = n[_] = c, e[c] = _, i[this._hashKey(f, s)] = c, i[this._hashKey(t[2 * y], t[2 * y + 1])] = y } this.hull = new Uint32Array(M); for (let t = 0, n = this._hullStart; t < M; t++)this.hull[t] = n, n = e[n]; this.triangles = this._triangles.subarray(0, this.trianglesLen), this.halfedges = this._halfedges.subarray(0, this.trianglesLen) } _hashKey(t, n) { return Math.floor(function(t, n) { const e = t / (Math.abs(t) + Math.abs(n)); return (n > 0 ? 3 - e : 1 + e) / 4 }(t - this._cx, n - this._cy) * this._hashSize) % this._hashSize } _legalize(t) { const { _triangles: n, _halfedges: e, coords: r } = this; let i = 0, o = 0; for (; ;) { const a = e[t], u = t - t % 3; if (o = u + (t + 2) % 3, -1 === a) { if (0 === i) break; t = Au[--i]; continue } const c = a - a % 3, f = u + (t + 1) % 3, s = c + (a + 2) % 3, l = n[o], h = n[t], d = n[f], p = n[s]; if (Nu(r[2 * l], r[2 * l + 1], r[2 * h], r[2 * h + 1], r[2 * d], r[2 * d + 1], r[2 * p], r[2 * p + 1])) { n[t] = p, n[a] = l; const r = e[s]; if (-1 === r) { let n = this._hullStart; do { if (this._hullTri[n] === s) { this._hullTri[n] = t; break } n = this._hullPrev[n] } while (n !== this._hullStart) } this._link(t, r), this._link(a, e[o]), this._link(o, s); const u = c + (a + 1) % 3; i < Au.length && (Au[i++] = u) } else { if (0 === i) break; t = Au[--i] } } return o } _link(t, n) { this._halfedges[t] = n, -1 !== n && (this._halfedges[n] = t) } _addTriangle(t, n, e, r, i, o) { const a = this.trianglesLen; return this._triangles[a] = t, this._triangles[a + 1] = n, this._triangles[a + 2] = e, this._link(a, r), this._link(a + 1, i), this._link(a + 2, o), this.trianglesLen += 3, a } } function Eu(t, n, e, r) { const i = t - e, o = n - r; return i * i + o * o } function Nu(t, n, e, r, i, o, a, u) { const c = t - a, f = n - u, s = e - a, l = r - u, h = i - a, d = o - u, p = s * s + l * l, g = h * h + d * d; return c * (l * g - p * d) - f * (s * g - p * h) + (c * c + f * f) * (s * d - l * h) < 0 } function ku(t, n, e, r, i, o) { const a = e - t, u = r - n, c = i - t, f = o - n, s = a * a + u * u, l = c * c + f * f, h = .5 / (a * f - u * c), d = (f * s - u * l) * h, p = (a * l - c * s) * h; return d * d + p * p } function Cu(t, n, e, r) { if (r - e <= 20) for (let i = e + 1; i <= r; i++) { const r = t[i], o = n[r]; let a = i - 1; for (; a >= e && n[t[a]] > o;)t[a + 1] = t[a--]; t[a + 1] = r } else { let i = e + 1, o = r; Pu(t, e + r >> 1, i), n[t[e]] > n[t[r]] && Pu(t, e, r), n[t[i]] > n[t[r]] && Pu(t, i, r), n[t[e]] > n[t[i]] && Pu(t, e, i); const a = t[i], u = n[a]; for (; ;) { do { i++ } while (n[t[i]] < u); do { o-- } while (n[t[o]] > u); if (o < i) break; Pu(t, i, o) } t[e + 1] = t[o], t[o] = a, r - i + 1 >= o - e ? (Cu(t, n, i, r), Cu(t, n, e, o - 1)) : (Cu(t, n, e, o - 1), Cu(t, n, i, r)) } } function Pu(t, n, e) { const r = t[n]; t[n] = t[e], t[e] = r } function zu(t) { return t[0] } function $u(t) { return t[1] } const Du = 1e-6; class Ru { constructor() { this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = "" } moveTo(t, n) { this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}` } closePath() { null !== this._x1 && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z") } lineTo(t, n) { this._ += `L${this._x1 = +t},${this._y1 = +n}` } arc(t, n, e) { const r = (t = +t) + (e = +e), i = n = +n; if (e < 0) throw new Error("negative radius"); null === this._x1 ? this._ += `M${r},${i}` : (Math.abs(this._x1 - r) > Du || Math.abs(this._y1 - i) > Du) && (this._ += "L" + r + "," + i), e && (this._ += `A${e},${e},0,1,1,${t - e},${n}A${e},${e},0,1,1,${this._x1 = r},${this._y1 = i}`) } rect(t, n, e, r) { this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${+e}v${+r}h${-e}Z` } value() { return this._ || null } } class Fu { constructor() { this._ = [] } moveTo(t, n) { this._.push([t, n]) } closePath() { this._.push(this._[0].slice()) } lineTo(t, n) { this._.push([t, n]) } value() { return this._.length ? this._ : null } } class qu { constructor(t, [n, e, r, i] = [0, 0, 960, 500]) { if (!((r = +r) >= (n = +n) && (i = +i) >= (e = +e))) throw new Error("invalid bounds"); this.delaunay = t, this._circumcenters = new Float64Array(2 * t.points.length), this.vectors = new Float64Array(2 * t.points.length), this.xmax = r, this.xmin = n, this.ymax = i, this.ymin = e, this._init() } update() { return this.delaunay.update(), this._init(), this } _init() { const { delaunay: { points: t, hull: n, triangles: e }, vectors: r } = this; let i, o; const a = this.circumcenters = this._circumcenters.subarray(0, e.length / 3 * 2); for (let r, u, c = 0, f = 0, s = e.length; c < s; c += 3, f += 2) { const s = 2 * e[c], l = 2 * e[c + 1], h = 2 * e[c + 2], d = t[s], p = t[s + 1], g = t[l], y = t[l + 1], v = t[h], _ = t[h + 1], b = g - d, m = y - p, x = v - d, w = _ - p, M = 2 * (b * w - m * x); if (Math.abs(M) < 1e-9) { if (void 0 === i) { i = o = 0; for (const e of n) i += t[2 * e], o += t[2 * e + 1]; i /= n.length, o /= n.length } const e = 1e9 * Math.sign((i - d) * w - (o - p) * x); r = (d + v) / 2 - e * w, u = (p + _) / 2 + e * x } else { const t = 1 / M, n = b * b + m * m, e = x * x + w * w; r = d + (w * n - m * e) * t, u = p + (b * e - x * n) * t } a[f] = r, a[f + 1] = u } let u, c, f, s = n[n.length - 1], l = 4 * s, h = t[2 * s], d = t[2 * s + 1]; r.fill(0); for (let e = 0; e < n.length; ++e)s = n[e], u = l, c = h, f = d, l = 4 * s, h = t[2 * s], d = t[2 * s + 1], r[u + 2] = r[l] = f - d, r[u + 3] = r[l + 1] = h - c } render(t) { const n = null == t ? t = new Ru : void 0, { delaunay: { halfedges: e, inedges: r, hull: i }, circumcenters: o, vectors: a } = this; if (i.length <= 1) return null; for (let n = 0, r = e.length; n < r; ++n) { const r = e[n]; if (r < n) continue; const i = 2 * Math.floor(n / 3), a = 2 * Math.floor(r / 3), u = o[i], c = o[i + 1], f = o[a], s = o[a + 1]; this._renderSegment(u, c, f, s, t) } let u, c = i[i.length - 1]; for (let n = 0; n < i.length; ++n) { u = c, c = i[n]; const e = 2 * Math.floor(r[c] / 3), f = o[e], s = o[e + 1], l = 4 * u, h = this._project(f, s, a[l + 2], a[l + 3]); h && this._renderSegment(f, s, h[0], h[1], t) } return n && n.value() } renderBounds(t) { const n = null == t ? t = new Ru : void 0; return t.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin), n && n.value() } renderCell(t, n) { const e = null == n ? n = new Ru : void 0, r = this._clip(t); if (null === r || !r.length) return; n.moveTo(r[0], r[1]); let i = r.length; for (; r[0] === r[i - 2] && r[1] === r[i - 1] && i > 1;)i -= 2; for (let t = 2; t < i; t += 2)r[t] === r[t - 2] && r[t + 1] === r[t - 1] || n.lineTo(r[t], r[t + 1]); return n.closePath(), e && e.value() } *cellPolygons() { const { delaunay: { points: t } } = this; for (let n = 0, e = t.length / 2; n < e; ++n) { const t = this.cellPolygon(n); t && (t.index = n, yield t) } } cellPolygon(t) { const n = new Fu; return this.renderCell(t, n), n.value() } _renderSegment(t, n, e, r, i) { let o; const a = this._regioncode(t, n), u = this._regioncode(e, r); 0 === a && 0 === u ? (i.moveTo(t, n), i.lineTo(e, r)) : (o = this._clipSegment(t, n, e, r, a, u)) && (i.moveTo(o[0], o[1]), i.lineTo(o[2], o[3])) } contains(t, n, e) { return (n = +n) == n && (e = +e) == e && this.delaunay._step(t, n, e) === t } *neighbors(t) { const n = this._clip(t); if (n) for (const e of this.delaunay.neighbors(t)) { const t = this._clip(e); if (t) t: for (let r = 0, i = n.length; r < i; r += 2)for (let o = 0, a = t.length; o < a; o += 2)if (n[r] === t[o] && n[r + 1] === t[o + 1] && n[(r + 2) % i] === t[(o + a - 2) % a] && n[(r + 3) % i] === t[(o + a - 1) % a]) { yield e; break t } } } _cell(t) { const { circumcenters: n, delaunay: { inedges: e, halfedges: r, triangles: i } } = this, o = e[t]; if (-1 === o) return null; const a = []; let u = o; do { const e = Math.floor(u / 3); if (a.push(n[2 * e], n[2 * e + 1]), u = u % 3 == 2 ? u - 2 : u + 1, i[u] !== t) break; u = r[u] } while (u !== o && -1 !== u); return a } _clip(t) { if (0 === t && 1 === this.delaunay.hull.length) return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin]; const n = this._cell(t); if (null === n) return null; const { vectors: e } = this, r = 4 * t; return this._simplify(e[r] || e[r + 1] ? this._clipInfinite(t, n, e[r], e[r + 1], e[r + 2], e[r + 3]) : this._clipFinite(t, n)) } _clipFinite(t, n) { const e = n.length; let r, i, o, a, u = null, c = n[e - 2], f = n[e - 1], s = this._regioncode(c, f), l = 0; for (let h = 0; h < e; h += 2)if (r = c, i = f, c = n[h], f = n[h + 1], o = s, s = this._regioncode(c, f), 0 === o && 0 === s) a = l, l = 0, u ? u.push(c, f) : u = [c, f]; else { let n, e, h, d, p; if (0 === o) { if (null === (n = this._clipSegment(r, i, c, f, o, s))) continue;[e, h, d, p] = n } else { if (null === (n = this._clipSegment(c, f, r, i, s, o))) continue;[d, p, e, h] = n, a = l, l = this._edgecode(e, h), a && l && this._edge(t, a, l, u, u.length), u ? u.push(e, h) : u = [e, h] } a = l, l = this._edgecode(d, p), a && l && this._edge(t, a, l, u, u.length), u ? u.push(d, p) : u = [d, p] } if (u) a = l, l = this._edgecode(u[0], u[1]), a && l && this._edge(t, a, l, u, u.length); else if (this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin]; return u } _clipSegment(t, n, e, r, i, o) { const a = i < o; for (a && ([t, n, e, r, i, o] = [e, r, t, n, o, i]); ;) { if (0 === i && 0 === o) return a ? [e, r, t, n] : [t, n, e, r]; if (i & o) return null; let u, c, f = i || o; 8 & f ? (u = t + (e - t) * (this.ymax - n) / (r - n), c = this.ymax) : 4 & f ? (u = t + (e - t) * (this.ymin - n) / (r - n), c = this.ymin) : 2 & f ? (c = n + (r - n) * (this.xmax - t) / (e - t), u = this.xmax) : (c = n + (r - n) * (this.xmin - t) / (e - t), u = this.xmin), i ? (t = u, n = c, i = this._regioncode(t, n)) : (e = u, r = c, o = this._regioncode(e, r)) } } _clipInfinite(t, n, e, r, i, o) { let a, u = Array.from(n); if ((a = this._project(u[0], u[1], e, r)) && u.unshift(a[0], a[1]), (a = this._project(u[u.length - 2], u[u.length - 1], i, o)) && u.push(a[0], a[1]), u = this._clipFinite(t, u)) for (let n, e = 0, r = u.length, i = this._edgecode(u[r - 2], u[r - 1]); e < r; e += 2)n = i, i = this._edgecode(u[e], u[e + 1]), n && i && (e = this._edge(t, n, i, u, e), r = u.length); else this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2) && (u = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax]); return u } _edge(t, n, e, r, i) { for (; n !== e;) { let e, o; switch (n) { case 5: n = 4; continue; case 4: n = 6, e = this.xmax, o = this.ymin; break; case 6: n = 2; continue; case 2: n = 10, e = this.xmax, o = this.ymax; break; case 10: n = 8; continue; case 8: n = 9, e = this.xmin, o = this.ymax; break; case 9: n = 1; continue; case 1: n = 5, e = this.xmin, o = this.ymin }r[i] === e && r[i + 1] === o || !this.contains(t, e, o) || (r.splice(i, 0, e, o), i += 2) } return i } _project(t, n, e, r) { let i, o, a, u = 1 / 0; if (r < 0) { if (n <= this.ymin) return null; (i = (this.ymin - n) / r) < u && (a = this.ymin, o = t + (u = i) * e) } else if (r > 0) { if (n >= this.ymax) return null; (i = (this.ymax - n) / r) < u && (a = this.ymax, o = t + (u = i) * e) } if (e > 0) { if (t >= this.xmax) return null; (i = (this.xmax - t) / e) < u && (o = this.xmax, a = n + (u = i) * r) } else if (e < 0) { if (t <= this.xmin) return null; (i = (this.xmin - t) / e) < u && (o = this.xmin, a = n + (u = i) * r) } return [o, a] } _edgecode(t, n) { return (t === this.xmin ? 1 : t === this.xmax ? 2 : 0) | (n === this.ymin ? 4 : n === this.ymax ? 8 : 0) } _regioncode(t, n) { return (t < this.xmin ? 1 : t > this.xmax ? 2 : 0) | (n < this.ymin ? 4 : n > this.ymax ? 8 : 0) } _simplify(t) { if (t && t.length > 4) { for (let n = 0; n < t.length; n += 2) { const e = (n + 2) % t.length, r = (n + 4) % t.length; (t[n] === t[e] && t[e] === t[r] || t[n + 1] === t[e + 1] && t[e + 1] === t[r + 1]) && (t.splice(e, 2), n -= 2) } t.length || (t = null) } return t } } const Uu = 2 * Math.PI, Iu = Math.pow; function Ou(t) { return t[0] } function Bu(t) { return t[1] } function Yu(t, n, e) { return [t + Math.sin(t + n) * e, n + Math.cos(t - n) * e] } class Lu { static from(t, n = Ou, e = Bu, r) { return new Lu("length" in t ? function(t, n, e, r) { const i = t.length, o = new Float64Array(2 * i); for (let a = 0; a < i; ++a) { const i = t[a]; o[2 * a] = n.call(r, i, a, t), o[2 * a + 1] = e.call(r, i, a, t) } return o }(t, n, e, r) : Float64Array.from(function*(t, n, e, r) { let i = 0; for (const o of t) yield n.call(r, o, i, t), yield e.call(r, o, i, t), ++i }(t, n, e, r))) } constructor(t) { this._delaunator = new Su(t), this.inedges = new Int32Array(t.length / 2), this._hullIndex = new Int32Array(t.length / 2), this.points = this._delaunator.coords, this._init() } update() { return this._delaunator.update(), this._init(), this } _init() { const t = this._delaunator, n = this.points; if (t.hull && t.hull.length > 2 && function(t) { const { triangles: n, coords: e } = t; for (let t = 0; t < n.length; t += 3) { const r = 2 * n[t], i = 2 * n[t + 1], o = 2 * n[t + 2]; if ((e[o] - e[r]) * (e[i + 1] - e[r + 1]) - (e[i] - e[r]) * (e[o + 1] - e[r + 1]) > 1e-10) return !1 } return !0 }(t)) { this.collinear = Int32Array.from({ length: n.length / 2 }, ((t, n) => n)).sort(((t, e) => n[2 * t] - n[2 * e] || n[2 * t + 1] - n[2 * e + 1])); const t = this.collinear[0], e = this.collinear[this.collinear.length - 1], r = [n[2 * t], n[2 * t + 1], n[2 * e], n[2 * e + 1]], i = 1e-8 * Math.hypot(r[3] - r[1], r[2] - r[0]); for (let t = 0, e = n.length / 2; t < e; ++t) { const e = Yu(n[2 * t], n[2 * t + 1], i); n[2 * t] = e[0], n[2 * t + 1] = e[1] } this._delaunator = new Su(n) } else delete this.collinear; const e = this.halfedges = this._delaunator.halfedges, r = this.hull = this._delaunator.hull, i = this.triangles = this._delaunator.triangles, o = this.inedges.fill(-1), a = this._hullIndex.fill(-1); for (let t = 0, n = e.length; t < n; ++t) { const n = i[t % 3 == 2 ? t - 2 : t + 1]; -1 !== e[t] && -1 !== o[n] || (o[n] = t) } for (let t = 0, n = r.length; t < n; ++t)a[r[t]] = t; r.length <= 2 && r.length > 0 && (this.triangles = new Int32Array(3).fill(-1), this.halfedges = new Int32Array(3).fill(-1), this.triangles[0] = r[0], o[r[0]] = 1, 2 === r.length && (o[r[1]] = 0, this.triangles[1] = r[1], this.triangles[2] = r[1])) } voronoi(t) { return new qu(this, t) } *neighbors(t) { const { inedges: n, hull: e, _hullIndex: r, halfedges: i, triangles: o, collinear: a } = this; if (a) { const n = a.indexOf(t); return n > 0 && (yield a[n - 1]), void (n < a.length - 1 && (yield a[n + 1])) } const u = n[t]; if (-1 === u) return; let c = u, f = -1; do { if (yield f = o[c], c = c % 3 == 2 ? c - 2 : c + 1, o[c] !== t) return; if (c = i[c], -1 === c) { const n = e[(r[t] + 1) % e.length]; return void (n !== f && (yield n)) } } while (c !== u) } find(t, n, e = 0) { if ((t = +t) != t || (n = +n) != n) return -1; const r = e; let i; for (; (i = this._step(e, t, n)) >= 0 && i !== e && i !== r;)e = i; return i } _step(t, n, e) { const { inedges: r, hull: i, _hullIndex: o, halfedges: a, triangles: u, points: c } = this; if (-1 === r[t] || !c.length) return (t + 1) % (c.length >> 1); let f = t, s = Iu(n - c[2 * t], 2) + Iu(e - c[2 * t + 1], 2); const l = r[t]; let h = l; do { let r = u[h]; const l = Iu(n - c[2 * r], 2) + Iu(e - c[2 * r + 1], 2); if (l < s && (s = l, f = r), h = h % 3 == 2 ? h - 2 : h + 1, u[h] !== t) break; if (h = a[h], -1 === h) { if (h = i[(o[t] + 1) % i.length], h !== r && Iu(n - c[2 * h], 2) + Iu(e - c[2 * h + 1], 2) < s) return h; break } } while (h !== l); return f } render(t) { const n = null == t ? t = new Ru : void 0, { points: e, halfedges: r, triangles: i } = this; for (let n = 0, o = r.length; n < o; ++n) { const o = r[n]; if (o < n) continue; const a = 2 * i[n], u = 2 * i[o]; t.moveTo(e[a], e[a + 1]), t.lineTo(e[u], e[u + 1]) } return this.renderHull(t), n && n.value() } renderPoints(t, n) { void 0 !== n || t && "function" == typeof t.moveTo || (n = t, t = null), n = null == n ? 2 : +n; const e = null == t ? t = new Ru : void 0, { points: r } = this; for (let e = 0, i = r.length; e < i; e += 2) { const i = r[e], o = r[e + 1]; t.moveTo(i + n, o), t.arc(i, o, n, 0, Uu) } return e && e.value() } renderHull(t) { const n = null == t ? t = new Ru : void 0, { hull: e, points: r } = this, i = 2 * e[0], o = e.length; t.moveTo(r[i], r[i + 1]); for (let n = 1; n < o; ++n) { const i = 2 * e[n]; t.lineTo(r[i], r[i + 1]) } return t.closePath(), n && n.value() } hullPolygon() { const t = new Fu; return this.renderHull(t), t.value() } renderTriangle(t, n) { const e = null == n ? n = new Ru : void 0, { points: r, triangles: i } = this, o = 2 * i[t *= 3], a = 2 * i[t + 1], u = 2 * i[t + 2]; return n.moveTo(r[o], r[o + 1]), n.lineTo(r[a], r[a + 1]), n.lineTo(r[u], r[u + 1]), n.closePath(), e && e.value() } *trianglePolygons() { const { triangles: t } = this; for (let n = 0, e = t.length / 3; n < e; ++n)yield this.trianglePolygon(n) } trianglePolygon(t) { const n = new Fu; return this.renderTriangle(t, n), n.value() } } var ju = {}, Hu = {}, Xu = 34, Gu = 10, Vu = 13; function Wu(t) { return new Function("d", "return {" + t.map((function(t, n) { return JSON.stringify(t) + ": d[" + n + '] || ""' })).join(",") + "}") } function Zu(t) { var n = Object.create(null), e = []; return t.forEach((function(t) { for (var r in t) r in n || e.push(n[r] = r) })), e } function Ku(t, n) { var e = t + "", r = e.length; return r < n ? new Array(n - r + 1).join(0) + e : e } function Qu(t) { var n, e = t.getUTCHours(), r = t.getUTCMinutes(), i = t.getUTCSeconds(), o = t.getUTCMilliseconds(); return isNaN(t) ? "Invalid Date" : ((n = t.getUTCFullYear()) < 0 ? "-" + Ku(-n, 6) : n > 9999 ? "+" + Ku(n, 6) : Ku(n, 4)) + "-" + Ku(t.getUTCMonth() + 1, 2) + "-" + Ku(t.getUTCDate(), 2) + (o ? "T" + Ku(e, 2) + ":" + Ku(r, 2) + ":" + Ku(i, 2) + "." + Ku(o, 3) + "Z" : i ? "T" + Ku(e, 2) + ":" + Ku(r, 2) + ":" + Ku(i, 2) + "Z" : r || e ? "T" + Ku(e, 2) + ":" + Ku(r, 2) + "Z" : "") } function Ju(t) { var n = new RegExp('["' + t + "\n\r]"), e = t.charCodeAt(0); function r(t, n) { var r, i = [], o = t.length, a = 0, u = 0, c = o <= 0, f = !1; function s() { if (c) return Hu; if (f) return f = !1, ju; var n, r, i = a; if (t.charCodeAt(i) === Xu) { for (; a++ < o && t.charCodeAt(a) !== Xu || t.charCodeAt(++a) === Xu;); return (n = a) >= o ? c = !0 : (r = t.charCodeAt(a++)) === Gu ? f = !0 : r === Vu && (f = !0, t.charCodeAt(a) === Gu && ++a), t.slice(i + 1, n - 1).replace(/""/g, '"') } for (; a < o;) { if ((r = t.charCodeAt(n = a++)) === Gu) f = !0; else if (r === Vu) f = !0, t.charCodeAt(a) === Gu && ++a; else if (r !== e) continue; return t.slice(i, n) } return c = !0, t.slice(i, o) } for (t.charCodeAt(o - 1) === Gu && --o, t.charCodeAt(o - 1) === Vu && --o; (r = s()) !== Hu;) { for (var l = []; r !== ju && r !== Hu;)l.push(r), r = s(); n && null == (l = n(l, u++)) || i.push(l) } return i } function i(n, e) { return n.map((function(n) { return e.map((function(t) { return a(n[t]) })).join(t) })) } function o(n) { return n.map(a).join(t) } function a(t) { return null == t ? "" : t instanceof Date ? Qu(t) : n.test(t += "") ? '"' + t.replace(/"/g, '""') + '"' : t } return { parse: function(t, n) { var e, i, o = r(t, (function(t, r) { if (e) return e(t, r - 1); i = t, e = n ? function(t, n) { var e = Wu(t); return function(r, i) { return n(e(r), i, t) } }(t, n) : Wu(t) })); return o.columns = i || [], o }, parseRows: r, format: function(n, e) { return null == e && (e = Zu(n)), [e.map(a).join(t)].concat(i(n, e)).join("\n") }, formatBody: function(t, n) { return null == n && (n = Zu(t)), i(t, n).join("\n") }, formatRows: function(t) { return t.map(o).join("\n") }, formatRow: o, formatValue: a } } var tc = Ju(","), nc = tc.parse, ec = tc.parseRows, rc = tc.format, ic = tc.formatBody, oc = tc.formatRows, ac = tc.formatRow, uc = tc.formatValue, cc = Ju("\t"), fc = cc.parse, sc = cc.parseRows, lc = cc.format, hc = cc.formatBody, dc = cc.formatRows, pc = cc.formatRow, gc = cc.formatValue; const yc = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours(); function vc(t) { if (!t.ok) throw new Error(t.status + " " + t.statusText); return t.blob() } function _c(t) { if (!t.ok) throw new Error(t.status + " " + t.statusText); return t.arrayBuffer() } function bc(t) { if (!t.ok) throw new Error(t.status + " " + t.statusText); return t.text() } function mc(t, n) { return fetch(t, n).then(bc) } function xc(t) { return function(n, e, r) { return 2 === arguments.length && "function" == typeof e && (r = e, e = void 0), mc(n, e).then((function(n) { return t(n, r) })) } } var wc = xc(nc), Mc = xc(fc); function Tc(t) { if (!t.ok) throw new Error(t.status + " " + t.statusText); if (204 !== t.status && 205 !== t.status) return t.json() } function Ac(t) { return (n, e) => mc(n, e).then((n => (new DOMParser).parseFromString(n, t))) } var Sc = Ac("application/xml"), Ec = Ac("text/html"), Nc = Ac("image/svg+xml"); function kc(t, n, e, r) { if (isNaN(n) || isNaN(e)) return t; var i, o, a, u, c, f, s, l, h, d = t._root, p = { data: r }, g = t._x0, y = t._y0, v = t._x1, _ = t._y1; if (!d) return t._root = p, t; for (; d.length;)if ((f = n >= (o = (g + v) / 2)) ? g = o : v = o, (s = e >= (a = (y + _) / 2)) ? y = a : _ = a, i = d, !(d = d[l = s << 1 | f])) return i[l] = p, t; if (u = +t._x.call(null, d.data), c = +t._y.call(null, d.data), n === u && e === c) return p.next = d, i ? i[l] = p : t._root = p, t; do { i = i ? i[l] = new Array(4) : t._root = new Array(4), (f = n >= (o = (g + v) / 2)) ? g = o : v = o, (s = e >= (a = (y + _) / 2)) ? y = a : _ = a } while ((l = s << 1 | f) == (h = (c >= a) << 1 | u >= o)); return i[h] = d, i[l] = p, t } function Cc(t, n, e, r, i) { this.node = t, this.x0 = n, this.y0 = e, this.x1 = r, this.y1 = i } function Pc(t) { return t[0] } function zc(t) { return t[1] } function $c(t, n, e) { var r = new Dc(null == n ? Pc : n, null == e ? zc : e, NaN, NaN, NaN, NaN); return null == t ? r : r.addAll(t) } function Dc(t, n, e, r, i, o) { this._x = t, this._y = n, this._x0 = e, this._y0 = r, this._x1 = i, this._y1 = o, this._root = void 0 } function Rc(t) { for (var n = { data: t.data }, e = n; t = t.next;)e = e.next = { data: t.data }; return n } var Fc = $c.prototype = Dc.prototype; function qc(t) { return function() { return t } } function Uc(t) { return 1e-6 * (t() - .5) } function Ic(t) { return t.x + t.vx } function Oc(t) { return t.y + t.vy } function Bc(t) { return t.index } function Yc(t, n) { var e = t.get(n); if (!e) throw new Error("node not found: " + n); return e } Fc.copy = function() { var t, n, e = new Dc(this._x, this._y, this._x0, this._y0, this._x1, this._y1), r = this._root; if (!r) return e; if (!r.length) return e._root = Rc(r), e; for (t = [{ source: r, target: e._root = new Array(4) }]; r = t.pop();)for (var i = 0; i < 4; ++i)(n = r.source[i]) && (n.length ? t.push({ source: n, target: r.target[i] = new Array(4) }) : r.target[i] = Rc(n)); return e }, Fc.add = function(t) { const n = +this._x.call(null, t), e = +this._y.call(null, t); return kc(this.cover(n, e), n, e, t) }, Fc.addAll = function(t) { var n, e, r, i, o = t.length, a = new Array(o), u = new Array(o), c = 1 / 0, f = 1 / 0, s = -1 / 0, l = -1 / 0; for (e = 0; e < o; ++e)isNaN(r = +this._x.call(null, n = t[e])) || isNaN(i = +this._y.call(null, n)) || (a[e] = r, u[e] = i, r < c && (c = r), r > s && (s = r), i < f && (f = i), i > l && (l = i)); if (c > s || f > l) return this; for (this.cover(c, f).cover(s, l), e = 0; e < o; ++e)kc(this, a[e], u[e], t[e]); return this }, Fc.cover = function(t, n) { if (isNaN(t = +t) || isNaN(n = +n)) return this; var e = this._x0, r = this._y0, i = this._x1, o = this._y1; if (isNaN(e)) i = (e = Math.floor(t)) + 1, o = (r = Math.floor(n)) + 1; else { for (var a, u, c = i - e || 1, f = this._root; e > t || t >= i || r > n || n >= o;)switch (u = (n < r) << 1 | t < e, (a = new Array(4))[u] = f, f = a, c *= 2, u) { case 0: i = e + c, o = r + c; break; case 1: e = i - c, o = r + c; break; case 2: i = e + c, r = o - c; break; case 3: e = i - c, r = o - c }this._root && this._root.length && (this._root = f) } return this._x0 = e, this._y0 = r, this._x1 = i, this._y1 = o, this }, Fc.data = function() { var t = []; return this.visit((function(n) { if (!n.length) do { t.push(n.data) } while (n = n.next) })), t }, Fc.extent = function(t) { return arguments.length ? this.cover(+t[0][0], +t[0][1]).cover(+t[1][0], +t[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]] }, Fc.find = function(t, n, e) { var r, i, o, a, u, c, f, s = this._x0, l = this._y0, h = this._x1, d = this._y1, p = [], g = this._root; for (g && p.push(new Cc(g, s, l, h, d)), null == e ? e = 1 / 0 : (s = t - e, l = n - e, h = t + e, d = n + e, e *= e); c = p.pop();)if (!(!(g = c.node) || (i = c.x0) > h || (o = c.y0) > d || (a = c.x1) < s || (u = c.y1) < l)) if (g.length) { var y = (i + a) / 2, v = (o + u) / 2; p.push(new Cc(g[3], y, v, a, u), new Cc(g[2], i, v, y, u), new Cc(g[1], y, o, a, v), new Cc(g[0], i, o, y, v)), (f = (n >= v) << 1 | t >= y) && (c = p[p.length - 1], p[p.length - 1] = p[p.length - 1 - f], p[p.length - 1 - f] = c) } else { var _ = t - +this._x.call(null, g.data), b = n - +this._y.call(null, g.data), m = _ * _ + b * b; if (m < e) { var x = Math.sqrt(e = m); s = t - x, l = n - x, h = t + x, d = n + x, r = g.data } } return r }, Fc.remove = function(t) { if (isNaN(o = +this._x.call(null, t)) || isNaN(a = +this._y.call(null, t))) return this; var n, e, r, i, o, a, u, c, f, s, l, h, d = this._root, p = this._x0, g = this._y0, y = this._x1, v = this._y1; if (!d) return this; if (d.length) for (; ;) { if ((f = o >= (u = (p + y) / 2)) ? p = u : y = u, (s = a >= (c = (g + v) / 2)) ? g = c : v = c, n = d, !(d = d[l = s << 1 | f])) return this; if (!d.length) break; (n[l + 1 & 3] || n[l + 2 & 3] || n[l + 3 & 3]) && (e = n, h = l) } for (; d.data !== t;)if (r = d, !(d = d.next)) return this; return (i = d.next) && delete d.next, r ? (i ? r.next = i : delete r.next, this) : n ? (i ? n[l] = i : delete n[l], (d = n[0] || n[1] || n[2] || n[3]) && d === (n[3] || n[2] || n[1] || n[0]) && !d.length && (e ? e[h] = d : this._root = d), this) : (this._root = i, this) }, Fc.removeAll = function(t) { for (var n = 0, e = t.length; n < e; ++n)this.remove(t[n]); return this }, Fc.root = function() { return this._root }, Fc.size = function() { var t = 0; return this.visit((function(n) { if (!n.length) do { ++t } while (n = n.next) })), t }, Fc.visit = function(t) { var n, e, r, i, o, a, u = [], c = this._root; for (c && u.push(new Cc(c, this._x0, this._y0, this._x1, this._y1)); n = u.pop();)if (!t(c = n.node, r = n.x0, i = n.y0, o = n.x1, a = n.y1) && c.length) { var f = (r + o) / 2, s = (i + a) / 2; (e = c[3]) && u.push(new Cc(e, f, s, o, a)), (e = c[2]) && u.push(new Cc(e, r, s, f, a)), (e = c[1]) && u.push(new Cc(e, f, i, o, s)), (e = c[0]) && u.push(new Cc(e, r, i, f, s)) } return this }, Fc.visitAfter = function(t) { var n, e = [], r = []; for (this._root && e.push(new Cc(this._root, this._x0, this._y0, this._x1, this._y1)); n = e.pop();) { var i = n.node; if (i.length) { var o, a = n.x0, u = n.y0, c = n.x1, f = n.y1, s = (a + c) / 2, l = (u + f) / 2; (o = i[0]) && e.push(new Cc(o, a, u, s, l)), (o = i[1]) && e.push(new Cc(o, s, u, c, l)), (o = i[2]) && e.push(new Cc(o, a, l, s, f)), (o = i[3]) && e.push(new Cc(o, s, l, c, f)) } r.push(n) } for (; n = r.pop();)t(n.node, n.x0, n.y0, n.x1, n.y1); return this }, Fc.x = function(t) { return arguments.length ? (this._x = t, this) : this._x }, Fc.y = function(t) { return arguments.length ? (this._y = t, this) : this._y }; const Lc = 1664525, jc = 1013904223, Hc = 4294967296; function Xc(t) { return t.x } function Gc(t) { return t.y } var Vc = Math.PI * (3 - Math.sqrt(5)); function Wc(t, n) { if ((e = (t = n ? t.toExponential(n - 1) : t.toExponential()).indexOf("e")) < 0) return null; var e, r = t.slice(0, e); return [r.length > 1 ? r[0] + r.slice(2) : r, +t.slice(e + 1)] } function Zc(t) { return (t = Wc(Math.abs(t))) ? t[1] : NaN } var Kc, Qc = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i; function Jc(t) { if (!(n = Qc.exec(t))) throw new Error("invalid format: " + t); var n; return new tf({ fill: n[1], align: n[2], sign: n[3], symbol: n[4], zero: n[5], width: n[6], comma: n[7], precision: n[8] && n[8].slice(1), trim: n[9], type: n[10] }) } function tf(t) { this.fill = void 0 === t.fill ? " " : t.fill + "", this.align = void 0 === t.align ? ">" : t.align + "", this.sign = void 0 === t.sign ? "-" : t.sign + "", this.symbol = void 0 === t.symbol ? "" : t.symbol + "", this.zero = !!t.zero, this.width = void 0 === t.width ? void 0 : +t.width, this.comma = !!t.comma, this.precision = void 0 === t.precision ? void 0 : +t.precision, this.trim = !!t.trim, this.type = void 0 === t.type ? "" : t.type + "" } function nf(t, n) { var e = Wc(t, n); if (!e) return t + ""; var r = e[0], i = e[1]; return i < 0 ? "0." + new Array(-i).join("0") + r : r.length > i + 1 ? r.slice(0, i + 1) + "." + r.slice(i + 1) : r + new Array(i - r.length + 2).join("0") } Jc.prototype = tf.prototype, tf.prototype.toString = function() { return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (void 0 === this.width ? "" : Math.max(1, 0 | this.width)) + (this.comma ? "," : "") + (void 0 === this.precision ? "" : "." + Math.max(0, 0 | this.precision)) + (this.trim ? "~" : "") + this.type }; var ef = { "%": (t, n) => (100 * t).toFixed(n), b: t => Math.round(t).toString(2), c: t => t + "", d: function(t) { return Math.abs(t = Math.round(t)) >= 1e21 ? t.toLocaleString("en").replace(/,/g, "") : t.toString(10) }, e: (t, n) => t.toExponential(n), f: (t, n) => t.toFixed(n), g: (t, n) => t.toPrecision(n), o: t => Math.round(t).toString(8), p: (t, n) => nf(100 * t, n), r: nf, s: function(t, n) { var e = Wc(t, n); if (!e) return t + ""; var r = e[0], i = e[1], o = i - (Kc = 3 * Math.max(-8, Math.min(8, Math.floor(i / 3)))) + 1, a = r.length; return o === a ? r : o > a ? r + new Array(o - a + 1).join("0") : o > 0 ? r.slice(0, o) + "." + r.slice(o) : "0." + new Array(1 - o).join("0") + Wc(t, Math.max(0, n + o - 1))[0] }, X: t => Math.round(t).toString(16).toUpperCase(), x: t => Math.round(t).toString(16) }; function rf(t) { return t } var of, af = Array.prototype.map, uf = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"]; function cf(t) { var n, e, r = void 0 === t.grouping || void 0 === t.thousands ? rf : (n = af.call(t.grouping, Number), e = t.thousands + "", function(t, r) { for (var i = t.length, o = [], a = 0, u = n[0], c = 0; i > 0 && u > 0 && (c + u + 1 > r && (u = Math.max(1, r - c)), o.push(t.substring(i -= u, i + u)), !((c += u + 1) > r));)u = n[a = (a + 1) % n.length]; return o.reverse().join(e) }), i = void 0 === t.currency ? "" : t.currency[0] + "", o = void 0 === t.currency ? "" : t.currency[1] + "", a = void 0 === t.decimal ? "." : t.decimal + "", u = void 0 === t.numerals ? rf : function(t) { return function(n) { return n.replace(/[0-9]/g, (function(n) { return t[+n] })) } }(af.call(t.numerals, String)), c = void 0 === t.percent ? "%" : t.percent + "", f = void 0 === t.minus ? "−" : t.minus + "", s = void 0 === t.nan ? "NaN" : t.nan + ""; function l(t) { var n = (t = Jc(t)).fill, e = t.align, l = t.sign, h = t.symbol, d = t.zero, p = t.width, g = t.comma, y = t.precision, v = t.trim, _ = t.type; "n" === _ ? (g = !0, _ = "g") : ef[_] || (void 0 === y && (y = 12), v = !0, _ = "g"), (d || "0" === n && "=" === e) && (d = !0, n = "0", e = "="); var b = "$" === h ? i : "#" === h && /[boxX]/.test(_) ? "0" + _.toLowerCase() : "", m = "$" === h ? o : /[%p]/.test(_) ? c : "", x = ef[_], w = /[defgprs%]/.test(_); function M(t) { var i, o, c, h = b, M = m; if ("c" === _) M = x(t) + M, t = ""; else { var T = (t = +t) < 0 || 1 / t < 0; if (t = isNaN(t) ? s : x(Math.abs(t), y), v && (t = function(t) { t: for (var n, e = t.length, r = 1, i = -1; r < e; ++r)switch (t[r]) { case ".": i = n = r; break; case "0": 0 === i && (i = r), n = r; break; default: if (!+t[r]) break t; i > 0 && (i = 0) }return i > 0 ? t.slice(0, i) + t.slice(n + 1) : t }(t)), T && 0 == +t && "+" !== l && (T = !1), h = (T ? "(" === l ? l : f : "-" === l || "(" === l ? "" : l) + h, M = ("s" === _ ? uf[8 + Kc / 3] : "") + M + (T && "(" === l ? ")" : ""), w) for (i = -1, o = t.length; ++i < o;)if (48 > (c = t.charCodeAt(i)) || c > 57) { M = (46 === c ? a + t.slice(i + 1) : t.slice(i)) + M, t = t.slice(0, i); break } } g && !d && (t = r(t, 1 / 0)); var A = h.length + t.length + M.length, S = A < p ? new Array(p - A + 1).join(n) : ""; switch (g && d && (t = r(S + t, S.length ? p - M.length : 1 / 0), S = ""), e) { case "<": t = h + t + M + S; break; case "=": t = h + S + t + M; break; case "^": t = S.slice(0, A = S.length >> 1) + h + t + M + S.slice(A); break; default: t = S + h + t + M }return u(t) } return y = void 0 === y ? 6 : /[gprs]/.test(_) ? Math.max(1, Math.min(21, y)) : Math.max(0, Math.min(20, y)), M.toString = function() { return t + "" }, M } return { format: l, formatPrefix: function(t, n) { var e = l(((t = Jc(t)).type = "f", t)), r = 3 * Math.max(-8, Math.min(8, Math.floor(Zc(n) / 3))), i = Math.pow(10, -r), o = uf[8 + r / 3]; return function(t) { return e(i * t) + o } } } } function ff(n) { return of = cf(n), t.format = of.format, t.formatPrefix = of.formatPrefix, of } function sf(t) { return Math.max(0, -Zc(Math.abs(t))) } function lf(t, n) { return Math.max(0, 3 * Math.max(-8, Math.min(8, Math.floor(Zc(n) / 3))) - Zc(Math.abs(t))) } function hf(t, n) { return t = Math.abs(t), n = Math.abs(n) - t, Math.max(0, Zc(n) - Zc(t)) + 1 } t.format = void 0, t.formatPrefix = void 0, ff({ thousands: ",", grouping: [3], currency: ["$", ""] }); var df = 1e-6, pf = 1e-12, gf = Math.PI, yf = gf / 2, vf = gf / 4, _f = 2 * gf, bf = 180 / gf, mf = gf / 180, xf = Math.abs, wf = Math.atan, Mf = Math.atan2, Tf = Math.cos, Af = Math.ceil, Sf = Math.exp, Ef = Math.hypot, Nf = Math.log, kf = Math.pow, Cf = Math.sin, Pf = Math.sign || function(t) { return t > 0 ? 1 : t < 0 ? -1 : 0 }, zf = Math.sqrt, $f = Math.tan; function Df(t) { return t > 1 ? 0 : t < -1 ? gf : Math.acos(t) } function Rf(t) { return t > 1 ? yf : t < -1 ? -yf : Math.asin(t) } function Ff(t) { return (t = Cf(t / 2)) * t } function qf() { } function Uf(t, n) { t && Of.hasOwnProperty(t.type) && Of[t.type](t, n) } var If = { Feature: function(t, n) { Uf(t.geometry, n) }, FeatureCollection: function(t, n) { for (var e = t.features, r = -1, i = e.length; ++r < i;)Uf(e[r].geometry, n) } }, Of = { Sphere: function(t, n) { n.sphere() }, Point: function(t, n) { t = t.coordinates, n.point(t[0], t[1], t[2]) }, MultiPoint: function(t, n) { for (var e = t.coordinates, r = -1, i = e.length; ++r < i;)t = e[r], n.point(t[0], t[1], t[2]) }, LineString: function(t, n) { Bf(t.coordinates, n, 0) }, MultiLineString: function(t, n) { for (var e = t.coordinates, r = -1, i = e.length; ++r < i;)Bf(e[r], n, 0) }, Polygon: function(t, n) { Yf(t.coordinates, n) }, MultiPolygon: function(t, n) { for (var e = t.coordinates, r = -1, i = e.length; ++r < i;)Yf(e[r], n) }, GeometryCollection: function(t, n) { for (var e = t.geometries, r = -1, i = e.length; ++r < i;)Uf(e[r], n) } }; function Bf(t, n, e) { var r, i = -1, o = t.length - e; for (n.lineStart(); ++i < o;)r = t[i], n.point(r[0], r[1], r[2]); n.lineEnd() } function Yf(t, n) { var e = -1, r = t.length; for (n.polygonStart(); ++e < r;)Bf(t[e], n, 1); n.polygonEnd() } function Lf(t, n) { t && If.hasOwnProperty(t.type) ? If[t.type](t, n) : Uf(t, n) } var jf, Hf, Xf, Gf, Vf, Wf, Zf, Kf, Qf, Jf, ts, ns, es, rs, is, os, as = new T, us = new T, cs = { point: qf, lineStart: qf, lineEnd: qf, polygonStart: function() { as = new T, cs.lineStart = fs, cs.lineEnd = ss }, polygonEnd: function() { var t = +as; us.add(t < 0 ? _f + t : t), this.lineStart = this.lineEnd = this.point = qf }, sphere: function() { us.add(_f) } }; function fs() { cs.point = ls } function ss() { hs(jf, Hf) } function ls(t, n) { cs.point = hs, jf = t, Hf = n, Xf = t *= mf, Gf = Tf(n = (n *= mf) / 2 + vf), Vf = Cf(n) } function hs(t, n) { var e = (t *= mf) - Xf, r = e >= 0 ? 1 : -1, i = r * e, o = Tf(n = (n *= mf) / 2 + vf), a = Cf(n), u = Vf * a, c = Gf * o + u * Tf(i), f = u * r * Cf(i); as.add(Mf(f, c)), Xf = t, Gf = o, Vf = a } function ds(t) { return [Mf(t[1], t[0]), Rf(t[2])] } function ps(t) { var n = t[0], e = t[1], r = Tf(e); return [r * Tf(n), r * Cf(n), Cf(e)] } function gs(t, n) { return t[0] * n[0] + t[1] * n[1] + t[2] * n[2] } function ys(t, n) { return [t[1] * n[2] - t[2] * n[1], t[2] * n[0] - t[0] * n[2], t[0] * n[1] - t[1] * n[0]] } function vs(t, n) { t[0] += n[0], t[1] += n[1], t[2] += n[2] } function _s(t, n) { return [t[0] * n, t[1] * n, t[2] * n] } function bs(t) { var n = zf(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]); t[0] /= n, t[1] /= n, t[2] /= n } var ms, xs, ws, Ms, Ts, As, Ss, Es, Ns, ks, Cs, Ps, zs, $s, Ds, Rs, Fs = { point: qs, lineStart: Is, lineEnd: Os, polygonStart: function() { Fs.point = Bs, Fs.lineStart = Ys, Fs.lineEnd = Ls, rs = new T, cs.polygonStart() }, polygonEnd: function() { cs.polygonEnd(), Fs.point = qs, Fs.lineStart = Is, Fs.lineEnd = Os, as < 0 ? (Wf = -(Kf = 180), Zf = -(Qf = 90)) : rs > df ? Qf = 90 : rs < -df && (Zf = -90), os[0] = Wf, os[1] = Kf }, sphere: function() { Wf = -(Kf = 180), Zf = -(Qf = 90) } }; function qs(t, n) { is.push(os = [Wf = t, Kf = t]), n < Zf && (Zf = n), n > Qf && (Qf = n) } function Us(t, n) { var e = ps([t * mf, n * mf]); if (es) { var r = ys(es, e), i = ys([r[1], -r[0], 0], r); bs(i), i = ds(i); var o, a = t - Jf, u = a > 0 ? 1 : -1, c = i[0] * bf * u, f = xf(a) > 180; f ^ (u * Jf < c && c < u * t) ? (o = i[1] * bf) > Qf && (Qf = o) : f ^ (u * Jf < (c = (c + 360) % 360 - 180) && c < u * t) ? (o = -i[1] * bf) < Zf && (Zf = o) : (n < Zf && (Zf = n), n > Qf && (Qf = n)), f ? t < Jf ? js(Wf, t) > js(Wf, Kf) && (Kf = t) : js(t, Kf) > js(Wf, Kf) && (Wf = t) : Kf >= Wf ? (t < Wf && (Wf = t), t > Kf && (Kf = t)) : t > Jf ? js(Wf, t) > js(Wf, Kf) && (Kf = t) : js(t, Kf) > js(Wf, Kf) && (Wf = t) } else is.push(os = [Wf = t, Kf = t]); n < Zf && (Zf = n), n > Qf && (Qf = n), es = e, Jf = t } function Is() { Fs.point = Us } function Os() { os[0] = Wf, os[1] = Kf, Fs.point = qs, es = null } function Bs(t, n) { if (es) { var e = t - Jf; rs.add(xf(e) > 180 ? e + (e > 0 ? 360 : -360) : e) } else ts = t, ns = n; cs.point(t, n), Us(t, n) } function Ys() { cs.lineStart() } function Ls() { Bs(ts, ns), cs.lineEnd(), xf(rs) > df && (Wf = -(Kf = 180)), os[0] = Wf, os[1] = Kf, es = null } function js(t, n) { return (n -= t) < 0 ? n + 360 : n } function Hs(t, n) { return t[0] - n[0] } function Xs(t, n) { return t[0] <= t[1] ? t[0] <= n && n <= t[1] : n < t[0] || t[1] < n } var Gs = { sphere: qf, point: Vs, lineStart: Zs, lineEnd: Js, polygonStart: function() { Gs.lineStart = tl, Gs.lineEnd = nl }, polygonEnd: function() { Gs.lineStart = Zs, Gs.lineEnd = Js } }; function Vs(t, n) { t *= mf; var e = Tf(n *= mf); Ws(e * Tf(t), e * Cf(t), Cf(n)) } function Ws(t, n, e) { ++ms, ws += (t - ws) / ms, Ms += (n - Ms) / ms, Ts += (e - Ts) / ms } function Zs() { Gs.point = Ks } function Ks(t, n) { t *= mf; var e = Tf(n *= mf); $s = e * Tf(t), Ds = e * Cf(t), Rs = Cf(n), Gs.point = Qs, Ws($s, Ds, Rs) } function Qs(t, n) { t *= mf; var e = Tf(n *= mf), r = e * Tf(t), i = e * Cf(t), o = Cf(n), a = Mf(zf((a = Ds * o - Rs * i) * a + (a = Rs * r - $s * o) * a + (a = $s * i - Ds * r) * a), $s * r + Ds * i + Rs * o); xs += a, As += a * ($s + ($s = r)), Ss += a * (Ds + (Ds = i)), Es += a * (Rs + (Rs = o)), Ws($s, Ds, Rs) } function Js() { Gs.point = Vs } function tl() { Gs.point = el } function nl() { rl(Ps, zs), Gs.point = Vs } function el(t, n) { Ps = t, zs = n, t *= mf, n *= mf, Gs.point = rl; var e = Tf(n); $s = e * Tf(t), Ds = e * Cf(t), Rs = Cf(n), Ws($s, Ds, Rs) } function rl(t, n) { t *= mf; var e = Tf(n *= mf), r = e * Tf(t), i = e * Cf(t), o = Cf(n), a = Ds * o - Rs * i, u = Rs * r - $s * o, c = $s * i - Ds * r, f = Ef(a, u, c), s = Rf(f), l = f && -s / f; Ns.add(l * a), ks.add(l * u), Cs.add(l * c), xs += s, As += s * ($s + ($s = r)), Ss += s * (Ds + (Ds = i)), Es += s * (Rs + (Rs = o)), Ws($s, Ds, Rs) } function il(t) { return function() { return t } } function ol(t, n) { function e(e, r) { return e = t(e, r), n(e[0], e[1]) } return t.invert && n.invert && (e.invert = function(e, r) { return (e = n.invert(e, r)) && t.invert(e[0], e[1]) }), e } function al(t, n) { return xf(t) > gf && (t -= Math.round(t / _f) * _f), [t, n] } function ul(t, n, e) { return (t %= _f) ? n || e ? ol(fl(t), sl(n, e)) : fl(t) : n || e ? sl(n, e) : al } function cl(t) { return function(n, e) { return xf(n += t) > gf && (n -= Math.round(n / _f) * _f), [n, e] } } function fl(t) { var n = cl(t); return n.invert = cl(-t), n } function sl(t, n) { var e = Tf(t), r = Cf(t), i = Tf(n), o = Cf(n); function a(t, n) { var a = Tf(n), u = Tf(t) * a, c = Cf(t) * a, f = Cf(n), s = f * e + u * r; return [Mf(c * i - s * o, u * e - f * r), Rf(s * i + c * o)] } return a.invert = function(t, n) { var a = Tf(n), u = Tf(t) * a, c = Cf(t) * a, f = Cf(n), s = f * i - c * o; return [Mf(c * i + f * o, u * e + s * r), Rf(s * e - u * r)] }, a } function ll(t) { function n(n) { return (n = t(n[0] * mf, n[1] * mf))[0] *= bf, n[1] *= bf, n } return t = ul(t[0] * mf, t[1] * mf, t.length > 2 ? t[2] * mf : 0), n.invert = function(n) { return (n = t.invert(n[0] * mf, n[1] * mf))[0] *= bf, n[1] *= bf, n }, n } function hl(t, n, e, r, i, o) { if (e) { var a = Tf(n), u = Cf(n), c = r * e; null == i ? (i = n + r * _f, o = n - c / 2) : (i = dl(a, i), o = dl(a, o), (r > 0 ? i < o : i > o) && (i += r * _f)); for (var f, s = i; r > 0 ? s > o : s < o; s -= c)f = ds([a, -u * Tf(s), -u * Cf(s)]), t.point(f[0], f[1]) } } function dl(t, n) { (n = ps(n))[0] -= t, bs(n); var e = Df(-n[1]); return ((-n[2] < 0 ? -e : e) + _f - df) % _f } function pl() { var t, n = []; return { point: function(n, e, r) { t.push([n, e, r]) }, lineStart: function() { n.push(t = []) }, lineEnd: qf, rejoin: function() { n.length > 1 && n.push(n.pop().concat(n.shift())) }, result: function() { var e = n; return n = [], t = null, e } } } function gl(t, n) { return xf(t[0] - n[0]) < df && xf(t[1] - n[1]) < df } function yl(t, n, e, r) { this.x = t, this.z = n, this.o = e, this.e = r, this.v = !1, this.n = this.p = null } function vl(t, n, e, r, i) { var o, a, u = [], c = []; if (t.forEach((function(t) { if (!((n = t.length - 1) <= 0)) { var n, e, r = t[0], a = t[n]; if (gl(r, a)) { if (!r[2] && !a[2]) { for (i.lineStart(), o = 0; o < n; ++o)i.point((r = t[o])[0], r[1]); return void i.lineEnd() } a[0] += 2 * df } u.push(e = new yl(r, t, null, !0)), c.push(e.o = new yl(r, null, e, !1)), u.push(e = new yl(a, t, null, !1)), c.push(e.o = new yl(a, null, e, !0)) } })), u.length) { for (c.sort(n), _l(u), _l(c), o = 0, a = c.length; o < a; ++o)c[o].e = e = !e; for (var f, s, l = u[0]; ;) { for (var h = l, d = !0; h.v;)if ((h = h.n) === l) return; f = h.z, i.lineStart(); do { if (h.v = h.o.v = !0, h.e) { if (d) for (o = 0, a = f.length; o < a; ++o)i.point((s = f[o])[0], s[1]); else r(h.x, h.n.x, 1, i); h = h.n } else { if (d) for (f = h.p.z, o = f.length - 1; o >= 0; --o)i.point((s = f[o])[0], s[1]); else r(h.x, h.p.x, -1, i); h = h.p } f = (h = h.o).z, d = !d } while (!h.v); i.lineEnd() } } } function _l(t) { if (n = t.length) { for (var n, e, r = 0, i = t[0]; ++r < n;)i.n = e = t[r], e.p = i, i = e; i.n = e = t[0], e.p = i } } function bl(t) { return xf(t[0]) <= gf ? t[0] : Pf(t[0]) * ((xf(t[0]) + gf) % _f - gf) } function ml(t, n) { var e = bl(n), r = n[1], i = Cf(r), o = [Cf(e), -Tf(e), 0], a = 0, u = 0, c = new T; 1 === i ? r = yf + df : -1 === i && (r = -yf - df); for (var f = 0, s = t.length; f < s; ++f)if (h = (l = t[f]).length) for (var l, h, d = l[h - 1], p = bl(d), g = d[1] / 2 + vf, y = Cf(g), v = Tf(g), _ = 0; _ < h; ++_, p = m, y = w, v = M, d = b) { var b = l[_], m = bl(b), x = b[1] / 2 + vf, w = Cf(x), M = Tf(x), A = m - p, S = A >= 0 ? 1 : -1, E = S * A, N = E > gf, k = y * w; if (c.add(Mf(k * S * Cf(E), v * M + k * Tf(E))), a += N ? A + S * _f : A, N ^ p >= e ^ m >= e) { var C = ys(ps(d), ps(b)); bs(C); var P = ys(o, C); bs(P); var z = (N ^ A >= 0 ? -1 : 1) * Rf(P[2]); (r > z || r === z && (C[0] || C[1])) && (u += N ^ A >= 0 ? 1 : -1) } } return (a < -df || a < df && c < -pf) ^ 1 & u } function xl(t, n, e, r) { return function(i) { var o, a, u, c = n(i), f = pl(), s = n(f), l = !1, h = { point: d, lineStart: g, lineEnd: y, polygonStart: function() { h.point = v, h.lineStart = _, h.lineEnd = b, a = [], o = [] }, polygonEnd: function() { h.point = d, h.lineStart = g, h.lineEnd = y, a = ft(a); var t = ml(o, r); a.length ? (l || (i.polygonStart(), l = !0), vl(a, Ml, t, e, i)) : t && (l || (i.polygonStart(), l = !0), i.lineStart(), e(null, null, 1, i), i.lineEnd()), l && (i.polygonEnd(), l = !1), a = o = null }, sphere: function() { i.polygonStart(), i.lineStart(), e(null, null, 1, i), i.lineEnd(), i.polygonEnd() } }; function d(n, e) { t(n, e) && i.point(n, e) } function p(t, n) { c.point(t, n) } function g() { h.point = p, c.lineStart() } function y() { h.point = d, c.lineEnd() } function v(t, n) { u.push([t, n]), s.point(t, n) } function _() { s.lineStart(), u = [] } function b() { v(u[0][0], u[0][1]), s.lineEnd(); var t, n, e, r, c = s.clean(), h = f.result(), d = h.length; if (u.pop(), o.push(u), u = null, d) if (1 & c) { if ((n = (e = h[0]).length - 1) > 0) { for (l || (i.polygonStart(), l = !0), i.lineStart(), t = 0; t < n; ++t)i.point((r = e[t])[0], r[1]); i.lineEnd() } } else d > 1 && 2 & c && h.push(h.pop().concat(h.shift())), a.push(h.filter(wl)) } return h } } function wl(t) { return t.length > 1 } function Ml(t, n) { return ((t = t.x)[0] < 0 ? t[1] - yf - df : yf - t[1]) - ((n = n.x)[0] < 0 ? n[1] - yf - df : yf - n[1]) } al.invert = al; var Tl = xl((function() { return !0 }), (function(t) { var n, e = NaN, r = NaN, i = NaN; return { lineStart: function() { t.lineStart(), n = 1 }, point: function(o, a) { var u = o > 0 ? gf : -gf, c = xf(o - e); xf(c - gf) < df ? (t.point(e, r = (r + a) / 2 > 0 ? yf : -yf), t.point(i, r), t.lineEnd(), t.lineStart(), t.point(u, r), t.point(o, r), n = 0) : i !== u && c >= gf && (xf(e - i) < df && (e -= i * df), xf(o - u) < df && (o -= u * df), r = function(t, n, e, r) { var i, o, a = Cf(t - e); return xf(a) > df ? wf((Cf(n) * (o = Tf(r)) * Cf(e) - Cf(r) * (i = Tf(n)) * Cf(t)) / (i * o * a)) : (n + r) / 2 }(e, r, o, a), t.point(i, r), t.lineEnd(), t.lineStart(), t.point(u, r), n = 0), t.point(e = o, r = a), i = u }, lineEnd: function() { t.lineEnd(), e = r = NaN }, clean: function() { return 2 - n } } }), (function(t, n, e, r) { var i; if (null == t) i = e * yf, r.point(-gf, i), r.point(0, i), r.point(gf, i), r.point(gf, 0), r.point(gf, -i), r.point(0, -i), r.point(-gf, -i), r.point(-gf, 0), r.point(-gf, i); else if (xf(t[0] - n[0]) > df) { var o = t[0] < n[0] ? gf : -gf; i = e * o / 2, r.point(-o, i), r.point(0, i), r.point(o, i) } else r.point(n[0], n[1]) }), [-gf, -yf]); function Al(t) { var n = Tf(t), e = 2 * mf, r = n > 0, i = xf(n) > df; function o(t, e) { return Tf(t) * Tf(e) > n } function a(t, e, r) { var i = [1, 0, 0], o = ys(ps(t), ps(e)), a = gs(o, o), u = o[0], c = a - u * u; if (!c) return !r && t; var f = n * a / c, s = -n * u / c, l = ys(i, o), h = _s(i, f); vs(h, _s(o, s)); var d = l, p = gs(h, d), g = gs(d, d), y = p * p - g * (gs(h, h) - 1); if (!(y < 0)) { var v = zf(y), _ = _s(d, (-p - v) / g); if (vs(_, h), _ = ds(_), !r) return _; var b, m = t[0], x = e[0], w = t[1], M = e[1]; x < m && (b = m, m = x, x = b); var T = x - m, A = xf(T - gf) < df; if (!A && M < w && (b = w, w = M, M = b), A || T < df ? A ? w + M > 0 ^ _[1] < (xf(_[0] - m) < df ? w : M) : w <= _[1] && _[1] <= M : T > gf ^ (m <= _[0] && _[0] <= x)) { var S = _s(d, (-p + v) / g); return vs(S, h), [_, ds(S)] } } } function u(n, e) { var i = r ? t : gf - t, o = 0; return n < -i ? o |= 1 : n > i && (o |= 2), e < -i ? o |= 4 : e > i && (o |= 8), o } return xl(o, (function(t) { var n, e, c, f, s; return { lineStart: function() { f = c = !1, s = 1 }, point: function(l, h) { var d, p = [l, h], g = o(l, h), y = r ? g ? 0 : u(l, h) : g ? u(l + (l < 0 ? gf : -gf), h) : 0; if (!n && (f = c = g) && t.lineStart(), g !== c && (!(d = a(n, p)) || gl(n, d) || gl(p, d)) && (p[2] = 1), g !== c) s = 0, g ? (t.lineStart(), d = a(p, n), t.point(d[0], d[1])) : (d = a(n, p), t.point(d[0], d[1], 2), t.lineEnd()), n = d; else if (i && n && r ^ g) { var v; y & e || !(v = a(p, n, !0)) || (s = 0, r ? (t.lineStart(), t.point(v[0][0], v[0][1]), t.point(v[1][0], v[1][1]), t.lineEnd()) : (t.point(v[1][0], v[1][1]), t.lineEnd(), t.lineStart(), t.point(v[0][0], v[0][1], 3))) } !g || n && gl(n, p) || t.point(p[0], p[1]), n = p, c = g, e = y }, lineEnd: function() { c && t.lineEnd(), n = null }, clean: function() { return s | (f && c) << 1 } } }), (function(n, r, i, o) { hl(o, t, e, i, n, r) }), r ? [0, -t] : [-gf, t - gf]) } var Sl, El, Nl, kl, Cl = 1e9, Pl = -Cl; function zl(t, n, e, r) { function i(i, o) { return t <= i && i <= e && n <= o && o <= r } function o(i, o, u, f) { var s = 0, l = 0; if (null == i || (s = a(i, u)) !== (l = a(o, u)) || c(i, o) < 0 ^ u > 0) do { f.point(0 === s || 3 === s ? t : e, s > 1 ? r : n) } while ((s = (s + u + 4) % 4) !== l); else f.point(o[0], o[1]) } function a(r, i) { return xf(r[0] - t) < df ? i > 0 ? 0 : 3 : xf(r[0] - e) < df ? i > 0 ? 2 : 1 : xf(r[1] - n) < df ? i > 0 ? 1 : 0 : i > 0 ? 3 : 2 } function u(t, n) { return c(t.x, n.x) } function c(t, n) { var e = a(t, 1), r = a(n, 1); return e !== r ? e - r : 0 === e ? n[1] - t[1] : 1 === e ? t[0] - n[0] : 2 === e ? t[1] - n[1] : n[0] - t[0] } return function(a) { var c, f, s, l, h, d, p, g, y, v, _, b = a, m = pl(), x = { point: w, lineStart: function() { x.point = M, f && f.push(s = []); v = !0, y = !1, p = g = NaN }, lineEnd: function() { c && (M(l, h), d && y && m.rejoin(), c.push(m.result())); x.point = w, y && b.lineEnd() }, polygonStart: function() { b = m, c = [], f = [], _ = !0 }, polygonEnd: function() { var n = function() { for (var n = 0, e = 0, i = f.length; e < i; ++e)for (var o, a, u = f[e], c = 1, s = u.length, l = u[0], h = l[0], d = l[1]; c < s; ++c)o = h, a = d, h = (l = u[c])[0], d = l[1], a <= r ? d > r && (h - o) * (r - a) > (d - a) * (t - o) && ++n : d <= r && (h - o) * (r - a) < (d - a) * (t - o) && --n; return n }(), e = _ && n, i = (c = ft(c)).length; (e || i) && (a.polygonStart(), e && (a.lineStart(), o(null, null, 1, a), a.lineEnd()), i && vl(c, u, n, o, a), a.polygonEnd()); b = a, c = f = s = null } }; function w(t, n) { i(t, n) && b.point(t, n) } function M(o, a) { var u = i(o, a); if (f && s.push([o, a]), v) l = o, h = a, d = u, v = !1, u && (b.lineStart(), b.point(o, a)); else if (u && y) b.point(o, a); else { var c = [p = Math.max(Pl, Math.min(Cl, p)), g = Math.max(Pl, Math.min(Cl, g))], m = [o = Math.max(Pl, Math.min(Cl, o)), a = Math.max(Pl, Math.min(Cl, a))]; !function(t, n, e, r, i, o) { var a, u = t[0], c = t[1], f = 0, s = 1, l = n[0] - u, h = n[1] - c; if (a = e - u, l || !(a > 0)) { if (a /= l, l < 0) { if (a < f) return; a < s && (s = a) } else if (l > 0) { if (a > s) return; a > f && (f = a) } if (a = i - u, l || !(a < 0)) { if (a /= l, l < 0) { if (a > s) return; a > f && (f = a) } else if (l > 0) { if (a < f) return; a < s && (s = a) } if (a = r - c, h || !(a > 0)) { if (a /= h, h < 0) { if (a < f) return; a < s && (s = a) } else if (h > 0) { if (a > s) return; a > f && (f = a) } if (a = o - c, h || !(a < 0)) { if (a /= h, h < 0) { if (a > s) return; a > f && (f = a) } else if (h > 0) { if (a < f) return; a < s && (s = a) } return f > 0 && (t[0] = u + f * l, t[1] = c + f * h), s < 1 && (n[0] = u + s * l, n[1] = c + s * h), !0 } } } } }(c, m, t, n, e, r) ? u && (b.lineStart(), b.point(o, a), _ = !1) : (y || (b.lineStart(), b.point(c[0], c[1])), b.point(m[0], m[1]), u || b.lineEnd(), _ = !1) } p = o, g = a, y = u } return x } } var $l = { sphere: qf, point: qf, lineStart: function() { $l.point = Rl, $l.lineEnd = Dl }, lineEnd: qf, polygonStart: qf, polygonEnd: qf }; function Dl() { $l.point = $l.lineEnd = qf } function Rl(t, n) { El = t *= mf, Nl = Cf(n *= mf), kl = Tf(n), $l.point = Fl } function Fl(t, n) { t *= mf; var e = Cf(n *= mf), r = Tf(n), i = xf(t - El), o = Tf(i), a = r * Cf(i), u = kl * e - Nl * r * o, c = Nl * e + kl * r * o; Sl.add(Mf(zf(a * a + u * u), c)), El = t, Nl = e, kl = r } function ql(t) { return Sl = new T, Lf(t, $l), +Sl } var Ul = [null, null], Il = { type: "LineString", coordinates: Ul }; function Ol(t, n) { return Ul[0] = t, Ul[1] = n, ql(Il) } var Bl = { Feature: function(t, n) { return Ll(t.geometry, n) }, FeatureCollection: function(t, n) { for (var e = t.features, r = -1, i = e.length; ++r < i;)if (Ll(e[r].geometry, n)) return !0; return !1 } }, Yl = { Sphere: function() { return !0 }, Point: function(t, n) { return jl(t.coordinates, n) }, MultiPoint: function(t, n) { for (var e = t.coordinates, r = -1, i = e.length; ++r < i;)if (jl(e[r], n)) return !0; return !1 }, LineString: function(t, n) { return Hl(t.coordinates, n) }, MultiLineString: function(t, n) { for (var e = t.coordinates, r = -1, i = e.length; ++r < i;)if (Hl(e[r], n)) return !0; return !1 }, Polygon: function(t, n) { return Xl(t.coordinates, n) }, MultiPolygon: function(t, n) { for (var e = t.coordinates, r = -1, i = e.length; ++r < i;)if (Xl(e[r], n)) return !0; return !1 }, GeometryCollection: function(t, n) { for (var e = t.geometries, r = -1, i = e.length; ++r < i;)if (Ll(e[r], n)) return !0; return !1 } }; function Ll(t, n) { return !(!t || !Yl.hasOwnProperty(t.type)) && Yl[t.type](t, n) } function jl(t, n) { return 0 === Ol(t, n) } function Hl(t, n) { for (var e, r, i, o = 0, a = t.length; o < a; o++) { if (0 === (r = Ol(t[o], n))) return !0; if (o > 0 && (i = Ol(t[o], t[o - 1])) > 0 && e <= i && r <= i && (e + r - i) * (1 - Math.pow((e - r) / i, 2)) < pf * i) return !0; e = r } return !1 } function Xl(t, n) { return !!ml(t.map(Gl), Vl(n)) } function Gl(t) { return (t = t.map(Vl)).pop(), t } function Vl(t) { return [t[0] * mf, t[1] * mf] } function Wl(t, n, e) { var r = lt(t, n - df, e).concat(n); return function(t) { return r.map((function(n) { return [t, n] })) } } function Zl(t, n, e) { var r = lt(t, n - df, e).concat(n); return function(t) { return r.map((function(n) { return [n, t] })) } } function Kl() { var t, n, e, r, i, o, a, u, c, f, s, l, h = 10, d = h, p = 90, g = 360, y = 2.5; function v() { return { type: "MultiLineString", coordinates: _() } } function _() { return lt(Af(r / p) * p, e, p).map(s).concat(lt(Af(u / g) * g, a, g).map(l)).concat(lt(Af(n / h) * h, t, h).filter((function(t) { return xf(t % p) > df })).map(c)).concat(lt(Af(o / d) * d, i, d).filter((function(t) { return xf(t % g) > df })).map(f)) } return v.lines = function() { return _().map((function(t) { return { type: "LineString", coordinates: t } })) }, v.outline = function() { return { type: "Polygon", coordinates: [s(r).concat(l(a).slice(1), s(e).reverse().slice(1), l(u).reverse().slice(1))] } }, v.extent = function(t) { return arguments.length ? v.extentMajor(t).extentMinor(t) : v.extentMinor() }, v.extentMajor = function(t) { return arguments.length ? (r = +t[0][0], e = +t[1][0], u = +t[0][1], a = +t[1][1], r > e && (t = r, r = e, e = t), u > a && (t = u, u = a, a = t), v.precision(y)) : [[r, u], [e, a]] }, v.extentMinor = function(e) { return arguments.length ? (n = +e[0][0], t = +e[1][0], o = +e[0][1], i = +e[1][1], n > t && (e = n, n = t, t = e), o > i && (e = o, o = i, i = e), v.precision(y)) : [[n, o], [t, i]] }, v.step = function(t) { return arguments.length ? v.stepMajor(t).stepMinor(t) : v.stepMinor() }, v.stepMajor = function(t) { return arguments.length ? (p = +t[0], g = +t[1], v) : [p, g] }, v.stepMinor = function(t) { return arguments.length ? (h = +t[0], d = +t[1], v) : [h, d] }, v.precision = function(h) { return arguments.length ? (y = +h, c = Wl(o, i, 90), f = Zl(n, t, y), s = Wl(u, a, 90), l = Zl(r, e, y), v) : y }, v.extentMajor([[-180, -90 + df], [180, 90 - df]]).extentMinor([[-180, -80 - df], [180, 80 + df]]) } var Ql, Jl, th, nh, eh = t => t, rh = new T, ih = new T, oh = { point: qf, lineStart: qf, lineEnd: qf, polygonStart: function() { oh.lineStart = ah, oh.lineEnd = fh }, polygonEnd: function() { oh.lineStart = oh.lineEnd = oh.point = qf, rh.add(xf(ih)), ih = new T }, result: function() { var t = rh / 2; return rh = new T, t } }; function ah() { oh.point = uh } function uh(t, n) { oh.point = ch, Ql = th = t, Jl = nh = n } function ch(t, n) { ih.add(nh * t - th * n), th = t, nh = n } function fh() { ch(Ql, Jl) } var sh = oh, lh = 1 / 0, hh = lh, dh = -lh, ph = dh, gh = { point: function(t, n) { t < lh && (lh = t); t > dh && (dh = t); n < hh && (hh = n); n > ph && (ph = n) }, lineStart: qf, lineEnd: qf, polygonStart: qf, polygonEnd: qf, result: function() { var t = [[lh, hh], [dh, ph]]; return dh = ph = -(hh = lh = 1 / 0), t } }; var yh, vh, _h, bh, mh = gh, xh = 0, wh = 0, Mh = 0, Th = 0, Ah = 0, Sh = 0, Eh = 0, Nh = 0, kh = 0, Ch = { point: Ph, lineStart: zh, lineEnd: Rh, polygonStart: function() { Ch.lineStart = Fh, Ch.lineEnd = qh }, polygonEnd: function() { Ch.point = Ph, Ch.lineStart = zh, Ch.lineEnd = Rh }, result: function() { var t = kh ? [Eh / kh, Nh / kh] : Sh ? [Th / Sh, Ah / Sh] : Mh ? [xh / Mh, wh / Mh] : [NaN, NaN]; return xh = wh = Mh = Th = Ah = Sh = Eh = Nh = kh = 0, t } }; function Ph(t, n) { xh += t, wh += n, ++Mh } function zh() { Ch.point = $h } function $h(t, n) { Ch.point = Dh, Ph(_h = t, bh = n) } function Dh(t, n) { var e = t - _h, r = n - bh, i = zf(e * e + r * r); Th += i * (_h + t) / 2, Ah += i * (bh + n) / 2, Sh += i, Ph(_h = t, bh = n) } function Rh() { Ch.point = Ph } function Fh() { Ch.point = Uh } function qh() { Ih(yh, vh) } function Uh(t, n) { Ch.point = Ih, Ph(yh = _h = t, vh = bh = n) } function Ih(t, n) { var e = t - _h, r = n - bh, i = zf(e * e + r * r); Th += i * (_h + t) / 2, Ah += i * (bh + n) / 2, Sh += i, Eh += (i = bh * t - _h * n) * (_h + t), Nh += i * (bh + n), kh += 3 * i, Ph(_h = t, bh = n) } var Oh = Ch; function Bh(t) { this._context = t } Bh.prototype = { _radius: 4.5, pointRadius: function(t) { return this._radius = t, this }, polygonStart: function() { this._line = 0 }, polygonEnd: function() { this._line = NaN }, lineStart: function() { this._point = 0 }, lineEnd: function() { 0 === this._line && this._context.closePath(), this._point = NaN }, point: function(t, n) { switch (this._point) { case 0: this._context.moveTo(t, n), this._point = 1; break; case 1: this._context.lineTo(t, n); break; default: this._context.moveTo(t + this._radius, n), this._context.arc(t, n, this._radius, 0, _f) } }, result: qf }; var Yh, Lh, jh, Hh, Xh, Gh = new T, Vh = { point: qf, lineStart: function() { Vh.point = Wh }, lineEnd: function() { Yh && Zh(Lh, jh), Vh.point = qf }, polygonStart: function() { Yh = !0 }, polygonEnd: function() { Yh = null }, result: function() { var t = +Gh; return Gh = new T, t } }; function Wh(t, n) { Vh.point = Zh, Lh = Hh = t, jh = Xh = n } function Zh(t, n) { Hh -= t, Xh -= n, Gh.add(zf(Hh * Hh + Xh * Xh)), Hh = t, Xh = n } var Kh = Vh; let Qh, Jh, td, nd; class ed { constructor(t) { this._append = null == t ? rd : function(t) { const n = Math.floor(t); if (!(n >= 0)) throw new RangeError(`invalid digits: ${t}`); if (n > 15) return rd; if (n !== Qh) { const t = 10 ** n; Qh = n, Jh = function(n) { let e = 1; this._ += n[0]; for (const r = n.length; e < r; ++e)this._ += Math.round(arguments[e] * t) / t + n[e] } } return Jh }(t), this._radius = 4.5, this._ = "" } pointRadius(t) { return this._radius = +t, this } polygonStart() { this._line = 0 } polygonEnd() { this._line = NaN } lineStart() { this._point = 0 } lineEnd() { 0 === this._line && (this._ += "Z"), this._point = NaN } point(t, n) { switch (this._point) { case 0: this._append`M${t},${n}`, this._point = 1; break; case 1: this._append`L${t},${n}`; break; default: if (this._append`M${t},${n}`, this._radius !== td || this._append !== Jh) { const t = this._radius, n = this._; this._ = "", this._append`m0,${t}a${t},${t} 0 1,1 0,${-2 * t}a${t},${t} 0 1,1 0,${2 * t}z`, td = t, Jh = this._append, nd = this._, this._ = n } this._ += nd } } result() { const t = this._; return this._ = "", t.length ? t : null } } function rd(t) { let n = 1; this._ += t[0]; for (const e = t.length; n < e; ++n)this._ += arguments[n] + t[n] } function id(t) { return function(n) { var e = new od; for (var r in t) e[r] = t[r]; return e.stream = n, e } } function od() { } function ad(t, n, e) { var r = t.clipExtent && t.clipExtent(); return t.scale(150).translate([0, 0]), null != r && t.clipExtent(null), Lf(e, t.stream(mh)), n(mh.result()), null != r && t.clipExtent(r), t } function ud(t, n, e) { return ad(t, (function(e) { var r = n[1][0] - n[0][0], i = n[1][1] - n[0][1], o = Math.min(r / (e[1][0] - e[0][0]), i / (e[1][1] - e[0][1])), a = +n[0][0] + (r - o * (e[1][0] + e[0][0])) / 2, u = +n[0][1] + (i - o * (e[1][1] + e[0][1])) / 2; t.scale(150 * o).translate([a, u]) }), e) } function cd(t, n, e) { return ud(t, [[0, 0], n], e) } function fd(t, n, e) { return ad(t, (function(e) { var r = +n, i = r / (e[1][0] - e[0][0]), o = (r - i * (e[1][0] + e[0][0])) / 2, a = -i * e[0][1]; t.scale(150 * i).translate([o, a]) }), e) } function sd(t, n, e) { return ad(t, (function(e) { var r = +n, i = r / (e[1][1] - e[0][1]), o = -i * e[0][0], a = (r - i * (e[1][1] + e[0][1])) / 2; t.scale(150 * i).translate([o, a]) }), e) } od.prototype = { constructor: od, point: function(t, n) { this.stream.point(t, n) }, sphere: function() { this.stream.sphere() }, lineStart: function() { this.stream.lineStart() }, lineEnd: function() { this.stream.lineEnd() }, polygonStart: function() { this.stream.polygonStart() }, polygonEnd: function() { this.stream.polygonEnd() } }; var ld = 16, hd = Tf(30 * mf); function dd(t, n) { return +n ? function(t, n) { function e(r, i, o, a, u, c, f, s, l, h, d, p, g, y) { var v = f - r, _ = s - i, b = v * v + _ * _; if (b > 4 * n && g--) { var m = a + h, x = u + d, w = c + p, M = zf(m * m + x * x + w * w), T = Rf(w /= M), A = xf(xf(w) - 1) < df || xf(o - l) < df ? (o + l) / 2 : Mf(x, m), S = t(A, T), E = S[0], N = S[1], k = E - r, C = N - i, P = _ * k - v * C; (P * P / b > n || xf((v * k + _ * C) / b - .5) > .3 || a * h + u * d + c * p < hd) && (e(r, i, o, a, u, c, E, N, A, m /= M, x /= M, w, g, y), y.point(E, N), e(E, N, A, m, x, w, f, s, l, h, d, p, g, y)) } } return function(n) { var r, i, o, a, u, c, f, s, l, h, d, p, g = { point: y, lineStart: v, lineEnd: b, polygonStart: function() { n.polygonStart(), g.lineStart = m }, polygonEnd: function() { n.polygonEnd(), g.lineStart = v } }; function y(e, r) { e = t(e, r), n.point(e[0], e[1]) } function v() { s = NaN, g.point = _, n.lineStart() } function _(r, i) { var o = ps([r, i]), a = t(r, i); e(s, l, f, h, d, p, s = a[0], l = a[1], f = r, h = o[0], d = o[1], p = o[2], ld, n), n.point(s, l) } function b() { g.point = y, n.lineEnd() } function m() { v(), g.point = x, g.lineEnd = w } function x(t, n) { _(r = t, n), i = s, o = l, a = h, u = d, c = p, g.point = _ } function w() { e(s, l, f, h, d, p, i, o, r, a, u, c, ld, n), g.lineEnd = b, b() } return g } }(t, n) : function(t) { return id({ point: function(n, e) { n = t(n, e), this.stream.point(n[0], n[1]) } }) }(t) } var pd = id({ point: function(t, n) { this.stream.point(t * mf, n * mf) } }); function gd(t, n, e, r, i, o) { if (!o) return function(t, n, e, r, i) { function o(o, a) { return [n + t * (o *= r), e - t * (a *= i)] } return o.invert = function(o, a) { return [(o - n) / t * r, (e - a) / t * i] }, o }(t, n, e, r, i); var a = Tf(o), u = Cf(o), c = a * t, f = u * t, s = a / t, l = u / t, h = (u * e - a * n) / t, d = (u * n + a * e) / t; function p(t, o) { return [c * (t *= r) - f * (o *= i) + n, e - f * t - c * o] } return p.invert = function(t, n) { return [r * (s * t - l * n + h), i * (d - l * t - s * n)] }, p } function yd(t) { return vd((function() { return t }))() } function vd(t) { var n, e, r, i, o, a, u, c, f, s, l = 150, h = 480, d = 250, p = 0, g = 0, y = 0, v = 0, _ = 0, b = 0, m = 1, x = 1, w = null, M = Tl, T = null, A = eh, S = .5; function E(t) { return c(t[0] * mf, t[1] * mf) } function N(t) { return (t = c.invert(t[0], t[1])) && [t[0] * bf, t[1] * bf] } function k() { var t = gd(l, 0, 0, m, x, b).apply(null, n(p, g)), r = gd(l, h - t[0], d - t[1], m, x, b); return e = ul(y, v, _), u = ol(n, r), c = ol(e, u), a = dd(u, S), C() } function C() { return f = s = null, E } return E.stream = function(t) { return f && s === t ? f : f = pd(function(t) { return id({ point: function(n, e) { var r = t(n, e); return this.stream.point(r[0], r[1]) } }) }(e)(M(a(A(s = t))))) }, E.preclip = function(t) { return arguments.length ? (M = t, w = void 0, C()) : M }, E.postclip = function(t) { return arguments.length ? (A = t, T = r = i = o = null, C()) : A }, E.clipAngle = function(t) { return arguments.length ? (M = +t ? Al(w = t * mf) : (w = null, Tl), C()) : w * bf }, E.clipExtent = function(t) { return arguments.length ? (A = null == t ? (T = r = i = o = null, eh) : zl(T = +t[0][0], r = +t[0][1], i = +t[1][0], o = +t[1][1]), C()) : null == T ? null : [[T, r], [i, o]] }, E.scale = function(t) { return arguments.length ? (l = +t, k()) : l }, E.translate = function(t) { return arguments.length ? (h = +t[0], d = +t[1], k()) : [h, d] }, E.center = function(t) { return arguments.length ? (p = t[0] % 360 * mf, g = t[1] % 360 * mf, k()) : [p * bf, g * bf] }, E.rotate = function(t) { return arguments.length ? (y = t[0] % 360 * mf, v = t[1] % 360 * mf, _ = t.length > 2 ? t[2] % 360 * mf : 0, k()) : [y * bf, v * bf, _ * bf] }, E.angle = function(t) { return arguments.length ? (b = t % 360 * mf, k()) : b * bf }, E.reflectX = function(t) { return arguments.length ? (m = t ? -1 : 1, k()) : m < 0 }, E.reflectY = function(t) { return arguments.length ? (x = t ? -1 : 1, k()) : x < 0 }, E.precision = function(t) { return arguments.length ? (a = dd(u, S = t * t), C()) : zf(S) }, E.fitExtent = function(t, n) { return ud(E, t, n) }, E.fitSize = function(t, n) { return cd(E, t, n) }, E.fitWidth = function(t, n) { return fd(E, t, n) }, E.fitHeight = function(t, n) { return sd(E, t, n) }, function() { return n = t.apply(this, arguments), E.invert = n.invert && N, k() } } function _d(t) { var n = 0, e = gf / 3, r = vd(t), i = r(n, e); return i.parallels = function(t) { return arguments.length ? r(n = t[0] * mf, e = t[1] * mf) : [n * bf, e * bf] }, i } function bd(t, n) { var e = Cf(t), r = (e + Cf(n)) / 2; if (xf(r) < df) return function(t) { var n = Tf(t); function e(t, e) { return [t * n, Cf(e) / n] } return e.invert = function(t, e) { return [t / n, Rf(e * n)] }, e }(t); var i = 1 + e * (2 * r - e), o = zf(i) / r; function a(t, n) { var e = zf(i - 2 * r * Cf(n)) / r; return [e * Cf(t *= r), o - e * Tf(t)] } return a.invert = function(t, n) { var e = o - n, a = Mf(t, xf(e)) * Pf(e); return e * r < 0 && (a -= gf * Pf(t) * Pf(e)), [a / r, Rf((i - (t * t + e * e) * r * r) / (2 * r))] }, a } function md() { return _d(bd).scale(155.424).center([0, 33.6442]) } function xd() { return md().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-.6, 38.7]) } function wd(t) { return function(n, e) { var r = Tf(n), i = Tf(e), o = t(r * i); return o === 1 / 0 ? [2, 0] : [o * i * Cf(n), o * Cf(e)] } } function Md(t) { return function(n, e) { var r = zf(n * n + e * e), i = t(r), o = Cf(i), a = Tf(i); return [Mf(n * o, r * a), Rf(r && e * o / r)] } } var Td = wd((function(t) { return zf(2 / (1 + t)) })); Td.invert = Md((function(t) { return 2 * Rf(t / 2) })); var Ad = wd((function(t) { return (t = Df(t)) && t / Cf(t) })); function Sd(t, n) { return [t, Nf($f((yf + n) / 2))] } function Ed(t) { var n, e, r, i = yd(t), o = i.center, a = i.scale, u = i.translate, c = i.clipExtent, f = null; function s() { var o = gf * a(), u = i(ll(i.rotate()).invert([0, 0])); return c(null == f ? [[u[0] - o, u[1] - o], [u[0] + o, u[1] + o]] : t === Sd ? [[Math.max(u[0] - o, f), n], [Math.min(u[0] + o, e), r]] : [[f, Math.max(u[1] - o, n)], [e, Math.min(u[1] + o, r)]]) } return i.scale = function(t) { return arguments.length ? (a(t), s()) : a() }, i.translate = function(t) { return arguments.length ? (u(t), s()) : u() }, i.center = function(t) { return arguments.length ? (o(t), s()) : o() }, i.clipExtent = function(t) { return arguments.length ? (null == t ? f = n = e = r = null : (f = +t[0][0], n = +t[0][1], e = +t[1][0], r = +t[1][1]), s()) : null == f ? null : [[f, n], [e, r]] }, s() } function Nd(t) { return $f((yf + t) / 2) } function kd(t, n) { var e = Tf(t), r = t === n ? Cf(t) : Nf(e / Tf(n)) / Nf(Nd(n) / Nd(t)), i = e * kf(Nd(t), r) / r; if (!r) return Sd; function o(t, n) { i > 0 ? n < -yf + df && (n = -yf + df) : n > yf - df && (n = yf - df); var e = i / kf(Nd(n), r); return [e * Cf(r * t), i - e * Tf(r * t)] } return o.invert = function(t, n) { var e = i - n, o = Pf(r) * zf(t * t + e * e), a = Mf(t, xf(e)) * Pf(e); return e * r < 0 && (a -= gf * Pf(t) * Pf(e)), [a / r, 2 * wf(kf(i / o, 1 / r)) - yf] }, o } function Cd(t, n) { return [t, n] } function Pd(t, n) { var e = Tf(t), r = t === n ? Cf(t) : (e - Tf(n)) / (n - t), i = e / r + t; if (xf(r) < df) return Cd; function o(t, n) { var e = i - n, o = r * t; return [e * Cf(o), i - e * Tf(o)] } return o.invert = function(t, n) { var e = i - n, o = Mf(t, xf(e)) * Pf(e); return e * r < 0 && (o -= gf * Pf(t) * Pf(e)), [o / r, i - Pf(r) * zf(t * t + e * e)] }, o } Ad.invert = Md((function(t) { return t })), Sd.invert = function(t, n) { return [t, 2 * wf(Sf(n)) - yf] }, Cd.invert = Cd; var zd = 1.340264, $d = -.081106, Dd = 893e-6, Rd = .003796, Fd = zf(3) / 2; function qd(t, n) { var e = Rf(Fd * Cf(n)), r = e * e, i = r * r * r; return [t * Tf(e) / (Fd * (zd + 3 * $d * r + i * (7 * Dd + 9 * Rd * r))), e * (zd + $d * r + i * (Dd + Rd * r))] } function Ud(t, n) { var e = Tf(n), r = Tf(t) * e; return [e * Cf(t) / r, Cf(n) / r] } function Id(t, n) { var e = n * n, r = e * e; return [t * (.8707 - .131979 * e + r * (r * (.003971 * e - .001529 * r) - .013791)), n * (1.007226 + e * (.015085 + r * (.028874 * e - .044475 - .005916 * r)))] } function Od(t, n) { return [Tf(n) * Cf(t), Cf(n)] } function Bd(t, n) { var e = Tf(n), r = 1 + Tf(t) * e; return [e * Cf(t) / r, Cf(n) / r] } function Yd(t, n) { return [Nf($f((yf + n) / 2)), -t] } function Ld(t, n) { return t.parent === n.parent ? 1 : 2 } function jd(t, n) { return t + n.x } function Hd(t, n) { return Math.max(t, n.y) } function Xd(t) { var n = 0, e = t.children, r = e && e.length; if (r) for (; --r >= 0;)n += e[r].value; else n = 1; t.value = n } function Gd(t, n) { t instanceof Map ? (t = [void 0, t], void 0 === n && (n = Wd)) : void 0 === n && (n = Vd); for (var e, r, i, o, a, u = new Qd(t), c = [u]; e = c.pop();)if ((i = n(e.data)) && (a = (i = Array.from(i)).length)) for (e.children = i, o = a - 1; o >= 0; --o)c.push(r = i[o] = new Qd(i[o])), r.parent = e, r.depth = e.depth + 1; return u.eachBefore(Kd) } function Vd(t) { return t.children } function Wd(t) { return Array.isArray(t) ? t[1] : null } function Zd(t) { void 0 !== t.data.value && (t.value = t.data.value), t.data = t.data.data } function Kd(t) { var n = 0; do { t.height = n } while ((t = t.parent) && t.height < ++n) } function Qd(t) { this.data = t, this.depth = this.height = 0, this.parent = null } function Jd(t) { return null == t ? null : tp(t) } function tp(t) { if ("function" != typeof t) throw new Error; return t } function np() { return 0 } function ep(t) { return function() { return t } } qd.invert = function(t, n) { for (var e, r = n, i = r * r, o = i * i * i, a = 0; a < 12 && (o = (i = (r -= e = (r * (zd + $d * i + o * (Dd + Rd * i)) - n) / (zd + 3 * $d * i + o * (7 * Dd + 9 * Rd * i))) * r) * i * i, !(xf(e) < pf)); ++a); return [Fd * t * (zd + 3 * $d * i + o * (7 * Dd + 9 * Rd * i)) / Tf(r), Rf(Cf(r) / Fd)] }, Ud.invert = Md(wf), Id.invert = function(t, n) { var e, r = n, i = 25; do { var o = r * r, a = o * o; r -= e = (r * (1.007226 + o * (.015085 + a * (.028874 * o - .044475 - .005916 * a))) - n) / (1.007226 + o * (.045255 + a * (.259866 * o - .311325 - .005916 * 11 * a))) } while (xf(e) > df && --i > 0); return [t / (.8707 + (o = r * r) * (o * (o * o * o * (.003971 - .001529 * o) - .013791) - .131979)), r] }, Od.invert = Md(Rf), Bd.invert = Md((function(t) { return 2 * wf(t) })), Yd.invert = function(t, n) { return [-n, 2 * wf(Sf(t)) - yf] }, Qd.prototype = Gd.prototype = { constructor: Qd, count: function() { return this.eachAfter(Xd) }, each: function(t, n) { let e = -1; for (const r of this) t.call(n, r, ++e, this); return this }, eachAfter: function(t, n) { for (var e, r, i, o = this, a = [o], u = [], c = -1; o = a.pop();)if (u.push(o), e = o.children) for (r = 0, i = e.length; r < i; ++r)a.push(e[r]); for (; o = u.pop();)t.call(n, o, ++c, this); return this }, eachBefore: function(t, n) { for (var e, r, i = this, o = [i], a = -1; i = o.pop();)if (t.call(n, i, ++a, this), e = i.children) for (r = e.length - 1; r >= 0; --r)o.push(e[r]); return this }, find: function(t, n) { let e = -1; for (const r of this) if (t.call(n, r, ++e, this)) return r }, sum: function(t) { return this.eachAfter((function(n) { for (var e = +t(n.data) || 0, r = n.children, i = r && r.length; --i >= 0;)e += r[i].value; n.value = e })) }, sort: function(t) { return this.eachBefore((function(n) { n.children && n.children.sort(t) })) }, path: function(t) { for (var n = this, e = function(t, n) { if (t === n) return t; var e = t.ancestors(), r = n.ancestors(), i = null; t = e.pop(), n = r.pop(); for (; t === n;)i = t, t = e.pop(), n = r.pop(); return i }(n, t), r = [n]; n !== e;)n = n.parent, r.push(n); for (var i = r.length; t !== e;)r.splice(i, 0, t), t = t.parent; return r }, ancestors: function() { for (var t = this, n = [t]; t = t.parent;)n.push(t); return n }, descendants: function() { return Array.from(this) }, leaves: function() { var t = []; return this.eachBefore((function(n) { n.children || t.push(n) })), t }, links: function() { var t = this, n = []; return t.each((function(e) { e !== t && n.push({ source: e.parent, target: e }) })), n }, copy: function() { return Gd(this).eachBefore(Zd) }, [Symbol.iterator]: function*() { var t, n, e, r, i = this, o = [i]; do { for (t = o.reverse(), o = []; i = t.pop();)if (yield i, n = i.children) for (e = 0, r = n.length; e < r; ++e)o.push(n[e]) } while (o.length) } }; const rp = 1664525, ip = 1013904223, op = 4294967296; function ap() { let t = 1; return () => (t = (rp * t + ip) % op) / op } function up(t, n) { for (var e, r, i = 0, o = (t = function(t, n) { let e, r, i = t.length; for (; i;)r = n() * i-- | 0, e = t[i], t[i] = t[r], t[r] = e; return t }(Array.from(t), n)).length, a = []; i < o;)e = t[i], r && sp(r, e) ? ++i : (r = hp(a = cp(a, e)), i = 0); return r } function cp(t, n) { var e, r; if (lp(n, t)) return [n]; for (e = 0; e < t.length; ++e)if (fp(n, t[e]) && lp(dp(t[e], n), t)) return [t[e], n]; for (e = 0; e < t.length - 1; ++e)for (r = e + 1; r < t.length; ++r)if (fp(dp(t[e], t[r]), n) && fp(dp(t[e], n), t[r]) && fp(dp(t[r], n), t[e]) && lp(pp(t[e], t[r], n), t)) return [t[e], t[r], n]; throw new Error } function fp(t, n) { var e = t.r - n.r, r = n.x - t.x, i = n.y - t.y; return e < 0 || e * e < r * r + i * i } function sp(t, n) { var e = t.r - n.r + 1e-9 * Math.max(t.r, n.r, 1), r = n.x - t.x, i = n.y - t.y; return e > 0 && e * e > r * r + i * i } function lp(t, n) { for (var e = 0; e < n.length; ++e)if (!sp(t, n[e])) return !1; return !0 } function hp(t) { switch (t.length) { case 1: return function(t) { return { x: t.x, y: t.y, r: t.r } }(t[0]); case 2: return dp(t[0], t[1]); case 3: return pp(t[0], t[1], t[2]) } } function dp(t, n) { var e = t.x, r = t.y, i = t.r, o = n.x, a = n.y, u = n.r, c = o - e, f = a - r, s = u - i, l = Math.sqrt(c * c + f * f); return { x: (e + o + c / l * s) / 2, y: (r + a + f / l * s) / 2, r: (l + i + u) / 2 } } function pp(t, n, e) { var r = t.x, i = t.y, o = t.r, a = n.x, u = n.y, c = n.r, f = e.x, s = e.y, l = e.r, h = r - a, d = r - f, p = i - u, g = i - s, y = c - o, v = l - o, _ = r * r + i * i - o * o, b = _ - a * a - u * u + c * c, m = _ - f * f - s * s + l * l, x = d * p - h * g, w = (p * m - g * b) / (2 * x) - r, M = (g * y - p * v) / x, T = (d * b - h * m) / (2 * x) - i, A = (h * v - d * y) / x, S = M * M + A * A - 1, E = 2 * (o + w * M + T * A), N = w * w + T * T - o * o, k = -(Math.abs(S) > 1e-6 ? (E + Math.sqrt(E * E - 4 * S * N)) / (2 * S) : N / E); return { x: r + w + M * k, y: i + T + A * k, r: k } } function gp(t, n, e) { var r, i, o, a, u = t.x - n.x, c = t.y - n.y, f = u * u + c * c; f ? (i = n.r + e.r, i *= i, a = t.r + e.r, i > (a *= a) ? (r = (f + a - i) / (2 * f), o = Math.sqrt(Math.max(0, a / f - r * r)), e.x = t.x - r * u - o * c, e.y = t.y - r * c + o * u) : (r = (f + i - a) / (2 * f), o = Math.sqrt(Math.max(0, i / f - r * r)), e.x = n.x + r * u - o * c, e.y = n.y + r * c + o * u)) : (e.x = n.x + e.r, e.y = n.y) } function yp(t, n) { var e = t.r + n.r - 1e-6, r = n.x - t.x, i = n.y - t.y; return e > 0 && e * e > r * r + i * i } function vp(t) { var n = t._, e = t.next._, r = n.r + e.r, i = (n.x * e.r + e.x * n.r) / r, o = (n.y * e.r + e.y * n.r) / r; return i * i + o * o } function _p(t) { this._ = t, this.next = null, this.previous = null } function bp(t, n) { if (!(o = (t = function(t) { return "object" == typeof t && "length" in t ? t : Array.from(t) }(t)).length)) return 0; var e, r, i, o, a, u, c, f, s, l, h; if ((e = t[0]).x = 0, e.y = 0, !(o > 1)) return e.r; if (r = t[1], e.x = -r.r, r.x = e.r, r.y = 0, !(o > 2)) return e.r + r.r; gp(r, e, i = t[2]), e = new _p(e), r = new _p(r), i = new _p(i), e.next = i.previous = r, r.next = e.previous = i, i.next = r.previous = e; t: for (c = 3; c < o; ++c) { gp(e._, r._, i = t[c]), i = new _p(i), f = r.next, s = e.previous, l = r._.r, h = e._.r; do { if (l <= h) { if (yp(f._, i._)) { r = f, e.next = r, r.previous = e, --c; continue t } l += f._.r, f = f.next } else { if (yp(s._, i._)) { (e = s).next = r, r.previous = e, --c; continue t } h += s._.r, s = s.previous } } while (f !== s.next); for (i.previous = e, i.next = r, e.next = r.previous = r = i, a = vp(e); (i = i.next) !== r;)(u = vp(i)) < a && (e = i, a = u); r = e.next } for (e = [r._], i = r; (i = i.next) !== r;)e.push(i._); for (i = up(e, n), c = 0; c < o; ++c)(e = t[c]).x -= i.x, e.y -= i.y; return i.r } function mp(t) { return Math.sqrt(t.value) } function xp(t) { return function(n) { n.children || (n.r = Math.max(0, +t(n) || 0)) } } function wp(t, n, e) { return function(r) { if (i = r.children) { var i, o, a, u = i.length, c = t(r) * n || 0; if (c) for (o = 0; o < u; ++o)i[o].r += c; if (a = bp(i, e), c) for (o = 0; o < u; ++o)i[o].r -= c; r.r = a + c } } } function Mp(t) { return function(n) { var e = n.parent; n.r *= t, e && (n.x = e.x + t * n.x, n.y = e.y + t * n.y) } } function Tp(t) { t.x0 = Math.round(t.x0), t.y0 = Math.round(t.y0), t.x1 = Math.round(t.x1), t.y1 = Math.round(t.y1) } function Ap(t, n, e, r, i) { for (var o, a = t.children, u = -1, c = a.length, f = t.value && (r - n) / t.value; ++u < c;)(o = a[u]).y0 = e, o.y1 = i, o.x0 = n, o.x1 = n += o.value * f } var Sp = { depth: -1 }, Ep = {}, Np = {}; function kp(t) { return t.id } function Cp(t) { return t.parentId } function Pp(t) { let n = t.length; if (n < 2) return ""; for (; --n > 1 && !zp(t, n);); return t.slice(0, n) } function zp(t, n) { if ("/" === t[n]) { let e = 0; for (; n > 0 && "\\" === t[--n];)++e; if (!(1 & e)) return !0 } return !1 } function $p(t, n) { return t.parent === n.parent ? 1 : 2 } function Dp(t) { var n = t.children; return n ? n[0] : t.t } function Rp(t) { var n = t.children; return n ? n[n.length - 1] : t.t } function Fp(t, n, e) { var r = e / (n.i - t.i); n.c -= r, n.s += e, t.c += r, n.z += e, n.m += e } function qp(t, n, e) { return t.a.parent === n.parent ? t.a : e } function Up(t, n) { this._ = t, this.parent = null, this.children = null, this.A = null, this.a = this, this.z = 0, this.m = 0, this.c = 0, this.s = 0, this.t = null, this.i = n } function Ip(t, n, e, r, i) { for (var o, a = t.children, u = -1, c = a.length, f = t.value && (i - e) / t.value; ++u < c;)(o = a[u]).x0 = n, o.x1 = r, o.y0 = e, o.y1 = e += o.value * f } Up.prototype = Object.create(Qd.prototype); var Op = (1 + Math.sqrt(5)) / 2; function Bp(t, n, e, r, i, o) { for (var a, u, c, f, s, l, h, d, p, g, y, v = [], _ = n.children, b = 0, m = 0, x = _.length, w = n.value; b < x;) { c = i - e, f = o - r; do { s = _[m++].value } while (!s && m < x); for (l = h = s, y = s * s * (g = Math.max(f / c, c / f) / (w * t)), p = Math.max(h / y, y / l); m < x; ++m) { if (s += u = _[m].value, u < l && (l = u), u > h && (h = u), y = s * s * g, (d = Math.max(h / y, y / l)) > p) { s -= u; break } p = d } v.push(a = { value: s, dice: c < f, children: _.slice(b, m) }), a.dice ? Ap(a, e, r, i, w ? r += f * s / w : o) : Ip(a, e, r, w ? e += c * s / w : i, o), w -= s, b = m } return v } var Yp = function t(n) { function e(t, e, r, i, o) { Bp(n, t, e, r, i, o) } return e.ratio = function(n) { return t((n = +n) > 1 ? n : 1) }, e }(Op); var Lp = function t(n) { function e(t, e, r, i, o) { if ((a = t._squarify) && a.ratio === n) for (var a, u, c, f, s, l = -1, h = a.length, d = t.value; ++l < h;) { for (c = (u = a[l]).children, f = u.value = 0, s = c.length; f < s; ++f)u.value += c[f].value; u.dice ? Ap(u, e, r, i, d ? r += (o - r) * u.value / d : o) : Ip(u, e, r, d ? e += (i - e) * u.value / d : i, o), d -= u.value } else t._squarify = a = Bp(n, t, e, r, i, o), a.ratio = n } return e.ratio = function(n) { return t((n = +n) > 1 ? n : 1) }, e }(Op); function jp(t, n, e) { return (n[0] - t[0]) * (e[1] - t[1]) - (n[1] - t[1]) * (e[0] - t[0]) } function Hp(t, n) { return t[0] - n[0] || t[1] - n[1] } function Xp(t) { const n = t.length, e = [0, 1]; let r, i = 2; for (r = 2; r < n; ++r) { for (; i > 1 && jp(t[e[i - 2]], t[e[i - 1]], t[r]) <= 0;)--i; e[i++] = r } return e.slice(0, i) } var Gp = Math.random, Vp = function t(n) { function e(t, e) { return t = null == t ? 0 : +t, e = null == e ? 1 : +e, 1 === arguments.length ? (e = t, t = 0) : e -= t, function() { return n() * e + t } } return e.source = t, e }(Gp), Wp = function t(n) { function e(t, e) { return arguments.length < 2 && (e = t, t = 0), t = Math.floor(t), e = Math.floor(e) - t, function() { return Math.floor(n() * e + t) } } return e.source = t, e }(Gp), Zp = function t(n) { function e(t, e) { var r, i; return t = null == t ? 0 : +t, e = null == e ? 1 : +e, function() { var o; if (null != r) o = r, r = null; else do { r = 2 * n() - 1, o = 2 * n() - 1, i = r * r + o * o } while (!i || i > 1); return t + e * o * Math.sqrt(-2 * Math.log(i) / i) } } return e.source = t, e }(Gp), Kp = function t(n) { var e = Zp.source(n); function r() { var t = e.apply(this, arguments); return function() { return Math.exp(t()) } } return r.source = t, r }(Gp), Qp = function t(n) { function e(t) { return (t = +t) <= 0 ? () => 0 : function() { for (var e = 0, r = t; r > 1; --r)e += n(); return e + r * n() } } return e.source = t, e }(Gp), Jp = function t(n) { var e = Qp.source(n); function r(t) { if (0 == (t = +t)) return n; var r = e(t); return function() { return r() / t } } return r.source = t, r }(Gp), tg = function t(n) { function e(t) { return function() { return -Math.log1p(-n()) / t } } return e.source = t, e }(Gp), ng = function t(n) { function e(t) { if ((t = +t) < 0) throw new RangeError("invalid alpha"); return t = 1 / -t, function() { return Math.pow(1 - n(), t) } } return e.source = t, e }(Gp), eg = function t(n) { function e(t) { if ((t = +t) < 0 || t > 1) throw new RangeError("invalid p"); return function() { return Math.floor(n() + t) } } return e.source = t, e }(Gp), rg = function t(n) { function e(t) { if ((t = +t) < 0 || t > 1) throw new RangeError("invalid p"); return 0 === t ? () => 1 / 0 : 1 === t ? () => 1 : (t = Math.log1p(-t), function() { return 1 + Math.floor(Math.log1p(-n()) / t) }) } return e.source = t, e }(Gp), ig = function t(n) { var e = Zp.source(n)(); function r(t, r) { if ((t = +t) < 0) throw new RangeError("invalid k"); if (0 === t) return () => 0; if (r = null == r ? 1 : +r, 1 === t) return () => -Math.log1p(-n()) * r; var i = (t < 1 ? t + 1 : t) - 1 / 3, o = 1 / (3 * Math.sqrt(i)), a = t < 1 ? () => Math.pow(n(), 1 / t) : () => 1; return function() { do { do { var t = e(), u = 1 + o * t } while (u <= 0); u *= u * u; var c = 1 - n() } while (c >= 1 - .0331 * t * t * t * t && Math.log(c) >= .5 * t * t + i * (1 - u + Math.log(u))); return i * u * a() * r } } return r.source = t, r }(Gp), og = function t(n) { var e = ig.source(n); function r(t, n) { var r = e(t), i = e(n); return function() { var t = r(); return 0 === t ? 0 : t / (t + i()) } } return r.source = t, r }(Gp), ag = function t(n) { var e = rg.source(n), r = og.source(n); function i(t, n) { return t = +t, (n = +n) >= 1 ? () => t : n <= 0 ? () => 0 : function() { for (var i = 0, o = t, a = n; o * a > 16 && o * (1 - a) > 16;) { var u = Math.floor((o + 1) * a), c = r(u, o - u + 1)(); c <= a ? (i += u, o -= u, a = (a - c) / (1 - c)) : (o = u - 1, a /= c) } for (var f = a < .5, s = e(f ? a : 1 - a), l = s(), h = 0; l <= o; ++h)l += s(); return i + (f ? h : o - h) } } return i.source = t, i }(Gp), ug = function t(n) { function e(t, e, r) { var i; return 0 == (t = +t) ? i = t => -Math.log(t) : (t = 1 / t, i = n => Math.pow(n, t)), e = null == e ? 0 : +e, r = null == r ? 1 : +r, function() { return e + r * i(-Math.log1p(-n())) } } return e.source = t, e }(Gp), cg = function t(n) { function e(t, e) { return t = null == t ? 0 : +t, e = null == e ? 1 : +e, function() { return t + e * Math.tan(Math.PI * n()) } } return e.source = t, e }(Gp), fg = function t(n) { function e(t, e) { return t = null == t ? 0 : +t, e = null == e ? 1 : +e, function() { var r = n(); return t + e * Math.log(r / (1 - r)) } } return e.source = t, e }(Gp), sg = function t(n) { var e = ig.source(n), r = ag.source(n); function i(t) { return function() { for (var i = 0, o = t; o > 16;) { var a = Math.floor(.875 * o), u = e(a)(); if (u > o) return i + r(a - 1, o / u)(); i += a, o -= u } for (var c = -Math.log1p(-n()), f = 0; c <= o; ++f)c -= Math.log1p(-n()); return i + f } } return i.source = t, i }(Gp); const lg = 1 / 4294967296; function hg(t, n) { switch (arguments.length) { case 0: break; case 1: this.range(t); break; default: this.range(n).domain(t) }return this } function dg(t, n) { switch (arguments.length) { case 0: break; case 1: "function" == typeof t ? this.interpolator(t) : this.range(t); break; default: this.domain(t), "function" == typeof n ? this.interpolator(n) : this.range(n) }return this } const pg = Symbol("implicit"); function gg() { var t = new InternMap, n = [], e = [], r = pg; function i(i) { let o = t.get(i); if (void 0 === o) { if (r !== pg) return r; t.set(i, o = n.push(i) - 1) } return e[o % e.length] } return i.domain = function(e) { if (!arguments.length) return n.slice(); n = [], t = new InternMap; for (const r of e) t.has(r) || t.set(r, n.push(r) - 1); return i }, i.range = function(t) { return arguments.length ? (e = Array.from(t), i) : e.slice() }, i.unknown = function(t) { return arguments.length ? (r = t, i) : r }, i.copy = function() { return gg(n, e).unknown(r) }, hg.apply(i, arguments), i } function yg() { var t, n, e = gg().unknown(void 0), r = e.domain, i = e.range, o = 0, a = 1, u = !1, c = 0, f = 0, s = .5; function l() { var e = r().length, l = a < o, h = l ? a : o, d = l ? o : a; t = (d - h) / Math.max(1, e - c + 2 * f), u && (t = Math.floor(t)), h += (d - h - t * (e - c)) * s, n = t * (1 - c), u && (h = Math.round(h), n = Math.round(n)); var p = lt(e).map((function(n) { return h + t * n })); return i(l ? p.reverse() : p) } return delete e.unknown, e.domain = function(t) { return arguments.length ? (r(t), l()) : r() }, e.range = function(t) { return arguments.length ? ([o, a] = t, o = +o, a = +a, l()) : [o, a] }, e.rangeRound = function(t) { return [o, a] = t, o = +o, a = +a, u = !0, l() }, e.bandwidth = function() { return n }, e.step = function() { return t }, e.round = function(t) { return arguments.length ? (u = !!t, l()) : u }, e.padding = function(t) { return arguments.length ? (c = Math.min(1, f = +t), l()) : c }, e.paddingInner = function(t) { return arguments.length ? (c = Math.min(1, t), l()) : c }, e.paddingOuter = function(t) { return arguments.length ? (f = +t, l()) : f }, e.align = function(t) { return arguments.length ? (s = Math.max(0, Math.min(1, t)), l()) : s }, e.copy = function() { return yg(r(), [o, a]).round(u).paddingInner(c).paddingOuter(f).align(s) }, hg.apply(l(), arguments) } function vg(t) { var n = t.copy; return t.padding = t.paddingOuter, delete t.paddingInner, delete t.paddingOuter, t.copy = function() { return vg(n()) }, t } function _g(t) { return +t } var bg = [0, 1]; function mg(t) { return t } function xg(t, n) { return (n -= t = +t) ? function(e) { return (e - t) / n } : function(t) { return function() { return t } }(isNaN(n) ? NaN : .5) } function wg(t, n, e) { var r = t[0], i = t[1], o = n[0], a = n[1]; return i < r ? (r = xg(i, r), o = e(a, o)) : (r = xg(r, i), o = e(o, a)), function(t) { return o(r(t)) } } function Mg(t, n, e) { var r = Math.min(t.length, n.length) - 1, i = new Array(r), o = new Array(r), a = -1; for (t[r] < t[0] && (t = t.slice().reverse(), n = n.slice().reverse()); ++a < r;)i[a] = xg(t[a], t[a + 1]), o[a] = e(n[a], n[a + 1]); return function(n) { var e = s(t, n, 1, r) - 1; return o[e](i[e](n)) } } function Tg(t, n) { return n.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown()) } function Ag() { var t, n, e, r, i, o, a = bg, u = bg, c = Gr, f = mg; function s() { var t = Math.min(a.length, u.length); return f !== mg && (f = function(t, n) { var e; return t > n && (e = t, t = n, n = e), function(e) { return Math.max(t, Math.min(n, e)) } }(a[0], a[t - 1])), r = t > 2 ? Mg : wg, i = o = null, l } function l(n) { return null == n || isNaN(n = +n) ? e : (i || (i = r(a.map(t), u, c)))(t(f(n))) } return l.invert = function(e) { return f(n((o || (o = r(u, a.map(t), Yr)))(e))) }, l.domain = function(t) { return arguments.length ? (a = Array.from(t, _g), s()) : a.slice() }, l.range = function(t) { return arguments.length ? (u = Array.from(t), s()) : u.slice() }, l.rangeRound = function(t) { return u = Array.from(t), c = Vr, s() }, l.clamp = function(t) { return arguments.length ? (f = !!t || mg, s()) : f !== mg }, l.interpolate = function(t) { return arguments.length ? (c = t, s()) : c }, l.unknown = function(t) { return arguments.length ? (e = t, l) : e }, function(e, r) { return t = e, n = r, s() } } function Sg() { return Ag()(mg, mg) } function Eg(n, e, r, i) { var o, a = W(n, e, r); switch ((i = Jc(null == i ? ",f" : i)).type) { case "s": var u = Math.max(Math.abs(n), Math.abs(e)); return null != i.precision || isNaN(o = lf(a, u)) || (i.precision = o), t.formatPrefix(i, u); case "": case "e": case "g": case "p": case "r": null != i.precision || isNaN(o = hf(a, Math.max(Math.abs(n), Math.abs(e)))) || (i.precision = o - ("e" === i.type)); break; case "f": case "%": null != i.precision || isNaN(o = sf(a)) || (i.precision = o - 2 * ("%" === i.type)) }return t.format(i) } function Ng(t) { var n = t.domain; return t.ticks = function(t) { var e = n(); return G(e[0], e[e.length - 1], null == t ? 10 : t) }, t.tickFormat = function(t, e) { var r = n(); return Eg(r[0], r[r.length - 1], null == t ? 10 : t, e) }, t.nice = function(e) { null == e && (e = 10); var r, i, o = n(), a = 0, u = o.length - 1, c = o[a], f = o[u], s = 10; for (f < c && (i = c, c = f, f = i, i = a, a = u, u = i); s-- > 0;) { if ((i = V(c, f, e)) === r) return o[a] = c, o[u] = f, n(o); if (i > 0) c = Math.floor(c / i) * i, f = Math.ceil(f / i) * i; else { if (!(i < 0)) break; c = Math.ceil(c * i) / i, f = Math.floor(f * i) / i } r = i } return t }, t } function kg(t, n) { var e, r = 0, i = (t = t.slice()).length - 1, o = t[r], a = t[i]; return a < o && (e = r, r = i, i = e, e = o, o = a, a = e), t[r] = n.floor(o), t[i] = n.ceil(a), t } function Cg(t) { return Math.log(t) } function Pg(t) { return Math.exp(t) } function zg(t) { return -Math.log(-t) } function $g(t) { return -Math.exp(-t) } function Dg(t) { return isFinite(t) ? +("1e" + t) : t < 0 ? 0 : t } function Rg(t) { return (n, e) => -t(-n, e) } function Fg(n) { const e = n(Cg, Pg), r = e.domain; let i, o, a = 10; function u() { return i = function(t) { return t === Math.E ? Math.log : 10 === t && Math.log10 || 2 === t && Math.log2 || (t = Math.log(t), n => Math.log(n) / t) }(a), o = function(t) { return 10 === t ? Dg : t === Math.E ? Math.exp : n => Math.pow(t, n) }(a), r()[0] < 0 ? (i = Rg(i), o = Rg(o), n(zg, $g)) : n(Cg, Pg), e } return e.base = function(t) { return arguments.length ? (a = +t, u()) : a }, e.domain = function(t) { return arguments.length ? (r(t), u()) : r() }, e.ticks = t => { const n = r(); let e = n[0], u = n[n.length - 1]; const c = u < e; c && ([e, u] = [u, e]); let f, s, l = i(e), h = i(u); const d = null == t ? 10 : +t; let p = []; if (!(a % 1) && h - l < d) { if (l = Math.floor(l), h = Math.ceil(h), e > 0) { for (; l <= h; ++l)for (f = 1; f < a; ++f)if (s = l < 0 ? f / o(-l) : f * o(l), !(s < e)) { if (s > u) break; p.push(s) } } else for (; l <= h; ++l)for (f = a - 1; f >= 1; --f)if (s = l > 0 ? f / o(-l) : f * o(l), !(s < e)) { if (s > u) break; p.push(s) } 2 * p.length < d && (p = G(e, u, d)) } else p = G(l, h, Math.min(h - l, d)).map(o); return c ? p.reverse() : p }, e.tickFormat = (n, r) => { if (null == n && (n = 10), null == r && (r = 10 === a ? "s" : ","), "function" != typeof r && (a % 1 || null != (r = Jc(r)).precision || (r.trim = !0), r = t.format(r)), n === 1 / 0) return r; const u = Math.max(1, a * n / e.ticks().length); return t => { let n = t / o(Math.round(i(t))); return n * a < a - .5 && (n *= a), n <= u ? r(t) : "" } }, e.nice = () => r(kg(r(), { floor: t => o(Math.floor(i(t))), ceil: t => o(Math.ceil(i(t))) })), e } function qg(t) { return function(n) { return Math.sign(n) * Math.log1p(Math.abs(n / t)) } } function Ug(t) { return function(n) { return Math.sign(n) * Math.expm1(Math.abs(n)) * t } } function Ig(t) { var n = 1, e = t(qg(n), Ug(n)); return e.constant = function(e) { return arguments.length ? t(qg(n = +e), Ug(n)) : n }, Ng(e) } function Og(t) { return function(n) { return n < 0 ? -Math.pow(-n, t) : Math.pow(n, t) } } function Bg(t) { return t < 0 ? -Math.sqrt(-t) : Math.sqrt(t) } function Yg(t) { return t < 0 ? -t * t : t * t } function Lg(t) { var n = t(mg, mg), e = 1; return n.exponent = function(n) { return arguments.length ? 1 === (e = +n) ? t(mg, mg) : .5 === e ? t(Bg, Yg) : t(Og(e), Og(1 / e)) : e }, Ng(n) } function jg() { var t = Lg(Ag()); return t.copy = function() { return Tg(t, jg()).exponent(t.exponent()) }, hg.apply(t, arguments), t } function Hg(t) { return Math.sign(t) * t * t } const Xg = new Date, Gg = new Date; function Vg(t, n, e, r) { function i(n) { return t(n = 0 === arguments.length ? new Date : new Date(+n)), n } return i.floor = n => (t(n = new Date(+n)), n), i.ceil = e => (t(e = new Date(e - 1)), n(e, 1), t(e), e), i.round = t => { const n = i(t), e = i.ceil(t); return t - n < e - t ? n : e }, i.offset = (t, e) => (n(t = new Date(+t), null == e ? 1 : Math.floor(e)), t), i.range = (e, r, o) => { const a = []; if (e = i.ceil(e), o = null == o ? 1 : Math.floor(o), !(e < r && o > 0)) return a; let u; do { a.push(u = new Date(+e)), n(e, o), t(e) } while (u < e && e < r); return a }, i.filter = e => Vg((n => { if (n >= n) for (; t(n), !e(n);)n.setTime(n - 1) }), ((t, r) => { if (t >= t) if (r < 0) for (; ++r <= 0;)for (; n(t, -1), !e(t);); else for (; --r >= 0;)for (; n(t, 1), !e(t);); })), e && (i.count = (n, r) => (Xg.setTime(+n), Gg.setTime(+r), t(Xg), t(Gg), Math.floor(e(Xg, Gg))), i.every = t => (t = Math.floor(t), isFinite(t) && t > 0 ? t > 1 ? i.filter(r ? n => r(n) % t == 0 : n => i.count(0, n) % t == 0) : i : null)), i } const Wg = Vg((() => { }), ((t, n) => { t.setTime(+t + n) }), ((t, n) => n - t)); Wg.every = t => (t = Math.floor(t), isFinite(t) && t > 0 ? t > 1 ? Vg((n => { n.setTime(Math.floor(n / t) * t) }), ((n, e) => { n.setTime(+n + e * t) }), ((n, e) => (e - n) / t)) : Wg : null); const Zg = Wg.range, Kg = 1e3, Qg = 6e4, Jg = 36e5, ty = 864e5, ny = 6048e5, ey = 2592e6, ry = 31536e6, iy = Vg((t => { t.setTime(t - t.getMilliseconds()) }), ((t, n) => { t.setTime(+t + n * Kg) }), ((t, n) => (n - t) / Kg), (t => t.getUTCSeconds())), oy = iy.range, ay = Vg((t => { t.setTime(t - t.getMilliseconds() - t.getSeconds() * Kg) }), ((t, n) => { t.setTime(+t + n * Qg) }), ((t, n) => (n - t) / Qg), (t => t.getMinutes())), uy = ay.range, cy = Vg((t => { t.setUTCSeconds(0, 0) }), ((t, n) => { t.setTime(+t + n * Qg) }), ((t, n) => (n - t) / Qg), (t => t.getUTCMinutes())), fy = cy.range, sy = Vg((t => { t.setTime(t - t.getMilliseconds() - t.getSeconds() * Kg - t.getMinutes() * Qg) }), ((t, n) => { t.setTime(+t + n * Jg) }), ((t, n) => (n - t) / Jg), (t => t.getHours())), ly = sy.range, hy = Vg((t => { t.setUTCMinutes(0, 0, 0) }), ((t, n) => { t.setTime(+t + n * Jg) }), ((t, n) => (n - t) / Jg), (t => t.getUTCHours())), dy = hy.range, py = Vg((t => t.setHours(0, 0, 0, 0)), ((t, n) => t.setDate(t.getDate() + n)), ((t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Qg) / ty), (t => t.getDate() - 1)), gy = py.range, yy = Vg((t => { t.setUTCHours(0, 0, 0, 0) }), ((t, n) => { t.setUTCDate(t.getUTCDate() + n) }), ((t, n) => (n - t) / ty), (t => t.getUTCDate() - 1)), vy = yy.range, _y = Vg((t => { t.setUTCHours(0, 0, 0, 0) }), ((t, n) => { t.setUTCDate(t.getUTCDate() + n) }), ((t, n) => (n - t) / ty), (t => Math.floor(t / ty))), by = _y.range; function my(t) { return Vg((n => { n.setDate(n.getDate() - (n.getDay() + 7 - t) % 7), n.setHours(0, 0, 0, 0) }), ((t, n) => { t.setDate(t.getDate() + 7 * n) }), ((t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Qg) / ny)) } const xy = my(0), wy = my(1), My = my(2), Ty = my(3), Ay = my(4), Sy = my(5), Ey = my(6), Ny = xy.range, ky = wy.range, Cy = My.range, Py = Ty.range, zy = Ay.range, $y = Sy.range, Dy = Ey.range; function Ry(t) { return Vg((n => { n.setUTCDate(n.getUTCDate() - (n.getUTCDay() + 7 - t) % 7), n.setUTCHours(0, 0, 0, 0) }), ((t, n) => { t.setUTCDate(t.getUTCDate() + 7 * n) }), ((t, n) => (n - t) / ny)) } const Fy = Ry(0), qy = Ry(1), Uy = Ry(2), Iy = Ry(3), Oy = Ry(4), By = Ry(5), Yy = Ry(6), Ly = Fy.range, jy = qy.range, Hy = Uy.range, Xy = Iy.range, Gy = Oy.range, Vy = By.range, Wy = Yy.range, Zy = Vg((t => { t.setDate(1), t.setHours(0, 0, 0, 0) }), ((t, n) => { t.setMonth(t.getMonth() + n) }), ((t, n) => n.getMonth() - t.getMonth() + 12 * (n.getFullYear() - t.getFullYear())), (t => t.getMonth())), Ky = Zy.range, Qy = Vg((t => { t.setUTCDate(1), t.setUTCHours(0, 0, 0, 0) }), ((t, n) => { t.setUTCMonth(t.getUTCMonth() + n) }), ((t, n) => n.getUTCMonth() - t.getUTCMonth() + 12 * (n.getUTCFullYear() - t.getUTCFullYear())), (t => t.getUTCMonth())), Jy = Qy.range, tv = Vg((t => { t.setMonth(0, 1), t.setHours(0, 0, 0, 0) }), ((t, n) => { t.setFullYear(t.getFullYear() + n) }), ((t, n) => n.getFullYear() - t.getFullYear()), (t => t.getFullYear())); tv.every = t => isFinite(t = Math.floor(t)) && t > 0 ? Vg((n => { n.setFullYear(Math.floor(n.getFullYear() / t) * t), n.setMonth(0, 1), n.setHours(0, 0, 0, 0) }), ((n, e) => { n.setFullYear(n.getFullYear() + e * t) })) : null; const nv = tv.range, ev = Vg((t => { t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0) }), ((t, n) => { t.setUTCFullYear(t.getUTCFullYear() + n) }), ((t, n) => n.getUTCFullYear() - t.getUTCFullYear()), (t => t.getUTCFullYear())); ev.every = t => isFinite(t = Math.floor(t)) && t > 0 ? Vg((n => { n.setUTCFullYear(Math.floor(n.getUTCFullYear() / t) * t), n.setUTCMonth(0, 1), n.setUTCHours(0, 0, 0, 0) }), ((n, e) => { n.setUTCFullYear(n.getUTCFullYear() + e * t) })) : null; const rv = ev.range; function iv(t, n, e, i, o, a) { const u = [[iy, 1, Kg], [iy, 5, 5e3], [iy, 15, 15e3], [iy, 30, 3e4], [a, 1, Qg], [a, 5, 3e5], [a, 15, 9e5], [a, 30, 18e5], [o, 1, Jg], [o, 3, 108e5], [o, 6, 216e5], [o, 12, 432e5], [i, 1, ty], [i, 2, 1728e5], [e, 1, ny], [n, 1, ey], [n, 3, 7776e6], [t, 1, ry]]; function c(n, e, i) { const o = Math.abs(e - n) / i, a = r((([, , t]) => t)).right(u, o); if (a === u.length) return t.every(W(n / ry, e / ry, i)); if (0 === a) return Wg.every(Math.max(W(n, e, i), 1)); const [c, f] = u[o / u[a - 1][2] < u[a][2] / o ? a - 1 : a]; return c.every(f) } return [function(t, n, e) { const r = n < t; r && ([t, n] = [n, t]); const i = e && "function" == typeof e.range ? e : c(t, n, e), o = i ? i.range(t, +n + 1) : []; return r ? o.reverse() : o }, c] } const [ov, av] = iv(ev, Qy, Fy, _y, hy, cy), [uv, cv] = iv(tv, Zy, xy, py, sy, ay); function fv(t) { if (0 <= t.y && t.y < 100) { var n = new Date(-1, t.m, t.d, t.H, t.M, t.S, t.L); return n.setFullYear(t.y), n } return new Date(t.y, t.m, t.d, t.H, t.M, t.S, t.L) } function sv(t) { if (0 <= t.y && t.y < 100) { var n = new Date(Date.UTC(-1, t.m, t.d, t.H, t.M, t.S, t.L)); return n.setUTCFullYear(t.y), n } return new Date(Date.UTC(t.y, t.m, t.d, t.H, t.M, t.S, t.L)) } function lv(t, n, e) { return { y: t, m: n, d: e, H: 0, M: 0, S: 0, L: 0 } } function hv(t) { var n = t.dateTime, e = t.date, r = t.time, i = t.periods, o = t.days, a = t.shortDays, u = t.months, c = t.shortMonths, f = mv(i), s = xv(i), l = mv(o), h = xv(o), d = mv(a), p = xv(a), g = mv(u), y = xv(u), v = mv(c), _ = xv(c), b = { a: function(t) { return a[t.getDay()] }, A: function(t) { return o[t.getDay()] }, b: function(t) { return c[t.getMonth()] }, B: function(t) { return u[t.getMonth()] }, c: null, d: Yv, e: Yv, f: Gv, g: i_, G: a_, H: Lv, I: jv, j: Hv, L: Xv, m: Vv, M: Wv, p: function(t) { return i[+(t.getHours() >= 12)] }, q: function(t) { return 1 + ~~(t.getMonth() / 3) }, Q: k_, s: C_, S: Zv, u: Kv, U: Qv, V: t_, w: n_, W: e_, x: null, X: null, y: r_, Y: o_, Z: u_, "%": N_ }, m = { a: function(t) { return a[t.getUTCDay()] }, A: function(t) { return o[t.getUTCDay()] }, b: function(t) { return c[t.getUTCMonth()] }, B: function(t) { return u[t.getUTCMonth()] }, c: null, d: c_, e: c_, f: d_, g: T_, G: S_, H: f_, I: s_, j: l_, L: h_, m: p_, M: g_, p: function(t) { return i[+(t.getUTCHours() >= 12)] }, q: function(t) { return 1 + ~~(t.getUTCMonth() / 3) }, Q: k_, s: C_, S: y_, u: v_, U: __, V: m_, w: x_, W: w_, x: null, X: null, y: M_, Y: A_, Z: E_, "%": N_ }, x = { a: function(t, n, e) { var r = d.exec(n.slice(e)); return r ? (t.w = p.get(r[0].toLowerCase()), e + r[0].length) : -1 }, A: function(t, n, e) { var r = l.exec(n.slice(e)); return r ? (t.w = h.get(r[0].toLowerCase()), e + r[0].length) : -1 }, b: function(t, n, e) { var r = v.exec(n.slice(e)); return r ? (t.m = _.get(r[0].toLowerCase()), e + r[0].length) : -1 }, B: function(t, n, e) { var r = g.exec(n.slice(e)); return r ? (t.m = y.get(r[0].toLowerCase()), e + r[0].length) : -1 }, c: function(t, e, r) { return T(t, n, e, r) }, d: zv, e: zv, f: Uv, g: Nv, G: Ev, H: Dv, I: Dv, j: $v, L: qv, m: Pv, M: Rv, p: function(t, n, e) { var r = f.exec(n.slice(e)); return r ? (t.p = s.get(r[0].toLowerCase()), e + r[0].length) : -1 }, q: Cv, Q: Ov, s: Bv, S: Fv, u: Mv, U: Tv, V: Av, w: wv, W: Sv, x: function(t, n, r) { return T(t, e, n, r) }, X: function(t, n, e) { return T(t, r, n, e) }, y: Nv, Y: Ev, Z: kv, "%": Iv }; function w(t, n) { return function(e) { var r, i, o, a = [], u = -1, c = 0, f = t.length; for (e instanceof Date || (e = new Date(+e)); ++u < f;)37 === t.charCodeAt(u) && (a.push(t.slice(c, u)), null != (i = pv[r = t.charAt(++u)]) ? r = t.charAt(++u) : i = "e" === r ? " " : "0", (o = n[r]) && (r = o(e, i)), a.push(r), c = u + 1); return a.push(t.slice(c, u)), a.join("") } } function M(t, n) { return function(e) { var r, i, o = lv(1900, void 0, 1); if (T(o, t, e += "", 0) != e.length) return null; if ("Q" in o) return new Date(o.Q); if ("s" in o) return new Date(1e3 * o.s + ("L" in o ? o.L : 0)); if (n && !("Z" in o) && (o.Z = 0), "p" in o && (o.H = o.H % 12 + 12 * o.p), void 0 === o.m && (o.m = "q" in o ? o.q : 0), "V" in o) { if (o.V < 1 || o.V > 53) return null; "w" in o || (o.w = 1), "Z" in o ? (i = (r = sv(lv(o.y, 0, 1))).getUTCDay(), r = i > 4 || 0 === i ? qy.ceil(r) : qy(r), r = yy.offset(r, 7 * (o.V - 1)), o.y = r.getUTCFullYear(), o.m = r.getUTCMonth(), o.d = r.getUTCDate() + (o.w + 6) % 7) : (i = (r = fv(lv(o.y, 0, 1))).getDay(), r = i > 4 || 0 === i ? wy.ceil(r) : wy(r), r = py.offset(r, 7 * (o.V - 1)), o.y = r.getFullYear(), o.m = r.getMonth(), o.d = r.getDate() + (o.w + 6) % 7) } else ("W" in o || "U" in o) && ("w" in o || (o.w = "u" in o ? o.u % 7 : "W" in o ? 1 : 0), i = "Z" in o ? sv(lv(o.y, 0, 1)).getUTCDay() : fv(lv(o.y, 0, 1)).getDay(), o.m = 0, o.d = "W" in o ? (o.w + 6) % 7 + 7 * o.W - (i + 5) % 7 : o.w + 7 * o.U - (i + 6) % 7); return "Z" in o ? (o.H += o.Z / 100 | 0, o.M += o.Z % 100, sv(o)) : fv(o) } } function T(t, n, e, r) { for (var i, o, a = 0, u = n.length, c = e.length; a < u;) { if (r >= c) return -1; if (37 === (i = n.charCodeAt(a++))) { if (i = n.charAt(a++), !(o = x[i in pv ? n.charAt(a++) : i]) || (r = o(t, e, r)) < 0) return -1 } else if (i != e.charCodeAt(r++)) return -1 } return r } return b.x = w(e, b), b.X = w(r, b), b.c = w(n, b), m.x = w(e, m), m.X = w(r, m), m.c = w(n, m), { format: function(t) { var n = w(t += "", b); return n.toString = function() { return t }, n }, parse: function(t) { var n = M(t += "", !1); return n.toString = function() { return t }, n }, utcFormat: function(t) { var n = w(t += "", m); return n.toString = function() { return t }, n }, utcParse: function(t) { var n = M(t += "", !0); return n.toString = function() { return t }, n } } } var dv, pv = { "-": "", _: " ", 0: "0" }, gv = /^\s*\d+/, yv = /^%/, vv = /[\\^$*+?|[\]().{}]/g; function _v(t, n, e) { var r = t < 0 ? "-" : "", i = (r ? -t : t) + "", o = i.length; return r + (o < e ? new Array(e - o + 1).join(n) + i : i) } function bv(t) { return t.replace(vv, "\\$&") } function mv(t) { return new RegExp("^(?:" + t.map(bv).join("|") + ")", "i") } function xv(t) { return new Map(t.map(((t, n) => [t.toLowerCase(), n]))) } function wv(t, n, e) { var r = gv.exec(n.slice(e, e + 1)); return r ? (t.w = +r[0], e + r[0].length) : -1 } function Mv(t, n, e) { var r = gv.exec(n.slice(e, e + 1)); return r ? (t.u = +r[0], e + r[0].length) : -1 } function Tv(t, n, e) { var r = gv.exec(n.slice(e, e + 2)); return r ? (t.U = +r[0], e + r[0].length) : -1 } function Av(t, n, e) { var r = gv.exec(n.slice(e, e + 2)); return r ? (t.V = +r[0], e + r[0].length) : -1 } function Sv(t, n, e) { var r = gv.exec(n.slice(e, e + 2)); return r ? (t.W = +r[0], e + r[0].length) : -1 } function Ev(t, n, e) { var r = gv.exec(n.slice(e, e + 4)); return r ? (t.y = +r[0], e + r[0].length) : -1 } function Nv(t, n, e) { var r = gv.exec(n.slice(e, e + 2)); return r ? (t.y = +r[0] + (+r[0] > 68 ? 1900 : 2e3), e + r[0].length) : -1 } function kv(t, n, e) { var r = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(n.slice(e, e + 6)); return r ? (t.Z = r[1] ? 0 : -(r[2] + (r[3] || "00")), e + r[0].length) : -1 } function Cv(t, n, e) { var r = gv.exec(n.slice(e, e + 1)); return r ? (t.q = 3 * r[0] - 3, e + r[0].length) : -1 } function Pv(t, n, e) { var r = gv.exec(n.slice(e, e + 2)); return r ? (t.m = r[0] - 1, e + r[0].length) : -1 } function zv(t, n, e) { var r = gv.exec(n.slice(e, e + 2)); return r ? (t.d = +r[0], e + r[0].length) : -1 } function $v(t, n, e) { var r = gv.exec(n.slice(e, e + 3)); return r ? (t.m = 0, t.d = +r[0], e + r[0].length) : -1 } function Dv(t, n, e) { var r = gv.exec(n.slice(e, e + 2)); return r ? (t.H = +r[0], e + r[0].length) : -1 } function Rv(t, n, e) { var r = gv.exec(n.slice(e, e + 2)); return r ? (t.M = +r[0], e + r[0].length) : -1 } function Fv(t, n, e) { var r = gv.exec(n.slice(e, e + 2)); return r ? (t.S = +r[0], e + r[0].length) : -1 } function qv(t, n, e) { var r = gv.exec(n.slice(e, e + 3)); return r ? (t.L = +r[0], e + r[0].length) : -1 } function Uv(t, n, e) { var r = gv.exec(n.slice(e, e + 6)); return r ? (t.L = Math.floor(r[0] / 1e3), e + r[0].length) : -1 } function Iv(t, n, e) { var r = yv.exec(n.slice(e, e + 1)); return r ? e + r[0].length : -1 } function Ov(t, n, e) { var r = gv.exec(n.slice(e)); return r ? (t.Q = +r[0], e + r[0].length) : -1 } function Bv(t, n, e) { var r = gv.exec(n.slice(e)); return r ? (t.s = +r[0], e + r[0].length) : -1 } function Yv(t, n) { return _v(t.getDate(), n, 2) } function Lv(t, n) { return _v(t.getHours(), n, 2) } function jv(t, n) { return _v(t.getHours() % 12 || 12, n, 2) } function Hv(t, n) { return _v(1 + py.count(tv(t), t), n, 3) } function Xv(t, n) { return _v(t.getMilliseconds(), n, 3) } function Gv(t, n) { return Xv(t, n) + "000" } function Vv(t, n) { return _v(t.getMonth() + 1, n, 2) } function Wv(t, n) { return _v(t.getMinutes(), n, 2) } function Zv(t, n) { return _v(t.getSeconds(), n, 2) } function Kv(t) { var n = t.getDay(); return 0 === n ? 7 : n } function Qv(t, n) { return _v(xy.count(tv(t) - 1, t), n, 2) } function Jv(t) { var n = t.getDay(); return n >= 4 || 0 === n ? Ay(t) : Ay.ceil(t) } function t_(t, n) { return t = Jv(t), _v(Ay.count(tv(t), t) + (4 === tv(t).getDay()), n, 2) } function n_(t) { return t.getDay() } function e_(t, n) { return _v(wy.count(tv(t) - 1, t), n, 2) } function r_(t, n) { return _v(t.getFullYear() % 100, n, 2) } function i_(t, n) { return _v((t = Jv(t)).getFullYear() % 100, n, 2) } function o_(t, n) { return _v(t.getFullYear() % 1e4, n, 4) } function a_(t, n) { var e = t.getDay(); return _v((t = e >= 4 || 0 === e ? Ay(t) : Ay.ceil(t)).getFullYear() % 1e4, n, 4) } function u_(t) { var n = t.getTimezoneOffset(); return (n > 0 ? "-" : (n *= -1, "+")) + _v(n / 60 | 0, "0", 2) + _v(n % 60, "0", 2) } function c_(t, n) { return _v(t.getUTCDate(), n, 2) } function f_(t, n) { return _v(t.getUTCHours(), n, 2) } function s_(t, n) { return _v(t.getUTCHours() % 12 || 12, n, 2) } function l_(t, n) { return _v(1 + yy.count(ev(t), t), n, 3) } function h_(t, n) { return _v(t.getUTCMilliseconds(), n, 3) } function d_(t, n) { return h_(t, n) + "000" } function p_(t, n) { return _v(t.getUTCMonth() + 1, n, 2) } function g_(t, n) { return _v(t.getUTCMinutes(), n, 2) } function y_(t, n) { return _v(t.getUTCSeconds(), n, 2) } function v_(t) { var n = t.getUTCDay(); return 0 === n ? 7 : n } function __(t, n) { return _v(Fy.count(ev(t) - 1, t), n, 2) } function b_(t) { var n = t.getUTCDay(); return n >= 4 || 0 === n ? Oy(t) : Oy.ceil(t) } function m_(t, n) { return t = b_(t), _v(Oy.count(ev(t), t) + (4 === ev(t).getUTCDay()), n, 2) } function x_(t) { return t.getUTCDay() } function w_(t, n) { return _v(qy.count(ev(t) - 1, t), n, 2) } function M_(t, n) { return _v(t.getUTCFullYear() % 100, n, 2) } function T_(t, n) { return _v((t = b_(t)).getUTCFullYear() % 100, n, 2) } function A_(t, n) { return _v(t.getUTCFullYear() % 1e4, n, 4) } function S_(t, n) { var e = t.getUTCDay(); return _v((t = e >= 4 || 0 === e ? Oy(t) : Oy.ceil(t)).getUTCFullYear() % 1e4, n, 4) } function E_() { return "+0000" } function N_() { return "%" } function k_(t) { return +t } function C_(t) { return Math.floor(+t / 1e3) } function P_(n) { return dv = hv(n), t.timeFormat = dv.format, t.timeParse = dv.parse, t.utcFormat = dv.utcFormat, t.utcParse = dv.utcParse, dv } t.timeFormat = void 0, t.timeParse = void 0, t.utcFormat = void 0, t.utcParse = void 0, P_({ dateTime: "%x, %X", date: "%-m/%-d/%Y", time: "%-I:%M:%S %p", periods: ["AM", "PM"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"] }); var z_ = "%Y-%m-%dT%H:%M:%S.%LZ"; var $_ = Date.prototype.toISOString ? function(t) { return t.toISOString() } : t.utcFormat(z_), D_ = $_; var R_ = +new Date("2000-01-01T00:00:00.000Z") ? function(t) { var n = new Date(t); return isNaN(n) ? null : n } : t.utcParse(z_), F_ = R_; function q_(t) { return new Date(t) } function U_(t) { return t instanceof Date ? +t : +new Date(+t) } function I_(t, n, e, r, i, o, a, u, c, f) { var s = Sg(), l = s.invert, h = s.domain, d = f(".%L"), p = f(":%S"), g = f("%I:%M"), y = f("%I %p"), v = f("%a %d"), _ = f("%b %d"), b = f("%B"), m = f("%Y"); function x(t) { return (c(t) < t ? d : u(t) < t ? p : a(t) < t ? g : o(t) < t ? y : r(t) < t ? i(t) < t ? v : _ : e(t) < t ? b : m)(t) } return s.invert = function(t) { return new Date(l(t)) }, s.domain = function(t) { return arguments.length ? h(Array.from(t, U_)) : h().map(q_) }, s.ticks = function(n) { var e = h(); return t(e[0], e[e.length - 1], null == n ? 10 : n) }, s.tickFormat = function(t, n) { return null == n ? x : f(n) }, s.nice = function(t) { var e = h(); return t && "function" == typeof t.range || (t = n(e[0], e[e.length - 1], null == t ? 10 : t)), t ? h(kg(e, t)) : s }, s.copy = function() { return Tg(s, I_(t, n, e, r, i, o, a, u, c, f)) }, s } function O_() { var t, n, e, r, i, o = 0, a = 1, u = mg, c = !1; function f(n) { return null == n || isNaN(n = +n) ? i : u(0 === e ? .5 : (n = (r(n) - t) * e, c ? Math.max(0, Math.min(1, n)) : n)) } function s(t) { return function(n) { var e, r; return arguments.length ? ([e, r] = n, u = t(e, r), f) : [u(0), u(1)] } } return f.domain = function(i) { return arguments.length ? ([o, a] = i, t = r(o = +o), n = r(a = +a), e = t === n ? 0 : 1 / (n - t), f) : [o, a] }, f.clamp = function(t) { return arguments.length ? (c = !!t, f) : c }, f.interpolator = function(t) { return arguments.length ? (u = t, f) : u }, f.range = s(Gr), f.rangeRound = s(Vr), f.unknown = function(t) { return arguments.length ? (i = t, f) : i }, function(i) { return r = i, t = i(o), n = i(a), e = t === n ? 0 : 1 / (n - t), f } } function B_(t, n) { return n.domain(t.domain()).interpolator(t.interpolator()).clamp(t.clamp()).unknown(t.unknown()) } function Y_() { var t = Lg(O_()); return t.copy = function() { return B_(t, Y_()).exponent(t.exponent()) }, dg.apply(t, arguments) } function L_() { var t, n, e, r, i, o, a, u = 0, c = .5, f = 1, s = 1, l = mg, h = !1; function d(t) { return isNaN(t = +t) ? a : (t = .5 + ((t = +o(t)) - n) * (s * t < s * n ? r : i), l(h ? Math.max(0, Math.min(1, t)) : t)) } function p(t) { return function(n) { var e, r, i; return arguments.length ? ([e, r, i] = n, l = di(t, [e, r, i]), d) : [l(0), l(.5), l(1)] } } return d.domain = function(a) { return arguments.length ? ([u, c, f] = a, t = o(u = +u), n = o(c = +c), e = o(f = +f), r = t === n ? 0 : .5 / (n - t), i = n === e ? 0 : .5 / (e - n), s = n < t ? -1 : 1, d) : [u, c, f] }, d.clamp = function(t) { return arguments.length ? (h = !!t, d) : h }, d.interpolator = function(t) { return arguments.length ? (l = t, d) : l }, d.range = p(Gr), d.rangeRound = p(Vr), d.unknown = function(t) { return arguments.length ? (a = t, d) : a }, function(a) { return o = a, t = a(u), n = a(c), e = a(f), r = t === n ? 0 : .5 / (n - t), i = n === e ? 0 : .5 / (e - n), s = n < t ? -1 : 1, d } } function j_() { var t = Lg(L_()); return t.copy = function() { return B_(t, j_()).exponent(t.exponent()) }, dg.apply(t, arguments) } function H_(t) { for (var n = t.length / 6 | 0, e = new Array(n), r = 0; r < n;)e[r] = "#" + t.slice(6 * r, 6 * ++r); return e } var X_ = H_("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"), G_ = H_("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666"), V_ = H_("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666"), W_ = H_("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0"), Z_ = H_("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928"), K_ = H_("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2"), Q_ = H_("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc"), J_ = H_("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999"), tb = H_("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3"), nb = H_("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"), eb = H_("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab"), rb = t => Fr(t[t.length - 1]), ib = new Array(3).concat("d8b365f5f5f55ab4ac", "a6611adfc27d80cdc1018571", "a6611adfc27df5f5f580cdc1018571", "8c510ad8b365f6e8c3c7eae55ab4ac01665e", "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e", "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e", "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e", "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30", "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30").map(H_), ob = rb(ib), ab = new Array(3).concat("af8dc3f7f7f77fbf7b", "7b3294c2a5cfa6dba0008837", "7b3294c2a5cff7f7f7a6dba0008837", "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837", "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837", "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837", "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837", "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b", "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b").map(H_), ub = rb(ab), cb = new Array(3).concat("e9a3c9f7f7f7a1d76a", "d01c8bf1b6dab8e1864dac26", "d01c8bf1b6daf7f7f7b8e1864dac26", "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221", "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221", "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221", "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221", "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419", "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419").map(H_), fb = rb(cb), sb = new Array(3).concat("998ec3f7f7f7f1a340", "5e3c99b2abd2fdb863e66101", "5e3c99b2abd2f7f7f7fdb863e66101", "542788998ec3d8daebfee0b6f1a340b35806", "542788998ec3d8daebf7f7f7fee0b6f1a340b35806", "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806", "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806", "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08", "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08").map(H_), lb = rb(sb), hb = new Array(3).concat("ef8a62f7f7f767a9cf", "ca0020f4a58292c5de0571b0", "ca0020f4a582f7f7f792c5de0571b0", "b2182bef8a62fddbc7d1e5f067a9cf2166ac", "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac", "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac", "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac", "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061", "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061").map(H_), db = rb(hb), pb = new Array(3).concat("ef8a62ffffff999999", "ca0020f4a582bababa404040", "ca0020f4a582ffffffbababa404040", "b2182bef8a62fddbc7e0e0e09999994d4d4d", "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d", "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d", "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d", "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a", "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a").map(H_), gb = rb(pb), yb = new Array(3).concat("fc8d59ffffbf91bfdb", "d7191cfdae61abd9e92c7bb6", "d7191cfdae61ffffbfabd9e92c7bb6", "d73027fc8d59fee090e0f3f891bfdb4575b4", "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4", "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4", "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4", "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695", "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695").map(H_), vb = rb(yb), _b = new Array(3).concat("fc8d59ffffbf91cf60", "d7191cfdae61a6d96a1a9641", "d7191cfdae61ffffbfa6d96a1a9641", "d73027fc8d59fee08bd9ef8b91cf601a9850", "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850", "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850", "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850", "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837", "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837").map(H_), bb = rb(_b), mb = new Array(3).concat("fc8d59ffffbf99d594", "d7191cfdae61abdda42b83ba", "d7191cfdae61ffffbfabdda42b83ba", "d53e4ffc8d59fee08be6f59899d5943288bd", "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd", "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd", "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd", "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2", "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2").map(H_), xb = rb(mb), wb = new Array(3).concat("e5f5f999d8c92ca25f", "edf8fbb2e2e266c2a4238b45", "edf8fbb2e2e266c2a42ca25f006d2c", "edf8fbccece699d8c966c2a42ca25f006d2c", "edf8fbccece699d8c966c2a441ae76238b45005824", "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824", "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b").map(H_), Mb = rb(wb), Tb = new Array(3).concat("e0ecf49ebcda8856a7", "edf8fbb3cde38c96c688419d", "edf8fbb3cde38c96c68856a7810f7c", "edf8fbbfd3e69ebcda8c96c68856a7810f7c", "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b", "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b", "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b").map(H_), Ab = rb(Tb), Sb = new Array(3).concat("e0f3dba8ddb543a2ca", "f0f9e8bae4bc7bccc42b8cbe", "f0f9e8bae4bc7bccc443a2ca0868ac", "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac", "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e", "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e", "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081").map(H_), Eb = rb(Sb), Nb = new Array(3).concat("fee8c8fdbb84e34a33", "fef0d9fdcc8afc8d59d7301f", "fef0d9fdcc8afc8d59e34a33b30000", "fef0d9fdd49efdbb84fc8d59e34a33b30000", "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000", "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000", "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000").map(H_), kb = rb(Nb), Cb = new Array(3).concat("ece2f0a6bddb1c9099", "f6eff7bdc9e167a9cf02818a", "f6eff7bdc9e167a9cf1c9099016c59", "f6eff7d0d1e6a6bddb67a9cf1c9099016c59", "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450", "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450", "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636").map(H_), Pb = rb(Cb), zb = new Array(3).concat("ece7f2a6bddb2b8cbe", "f1eef6bdc9e174a9cf0570b0", "f1eef6bdc9e174a9cf2b8cbe045a8d", "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d", "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b", "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b", "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858").map(H_), $b = rb(zb), Db = new Array(3).concat("e7e1efc994c7dd1c77", "f1eef6d7b5d8df65b0ce1256", "f1eef6d7b5d8df65b0dd1c77980043", "f1eef6d4b9dac994c7df65b0dd1c77980043", "f1eef6d4b9dac994c7df65b0e7298ace125691003f", "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f", "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f").map(H_), Rb = rb(Db), Fb = new Array(3).concat("fde0ddfa9fb5c51b8a", "feebe2fbb4b9f768a1ae017e", "feebe2fbb4b9f768a1c51b8a7a0177", "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177", "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177", "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177", "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a").map(H_), qb = rb(Fb), Ub = new Array(3).concat("edf8b17fcdbb2c7fb8", "ffffcca1dab441b6c4225ea8", "ffffcca1dab441b6c42c7fb8253494", "ffffccc7e9b47fcdbb41b6c42c7fb8253494", "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84", "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84", "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58").map(H_), Ib = rb(Ub), Ob = new Array(3).concat("f7fcb9addd8e31a354", "ffffccc2e69978c679238443", "ffffccc2e69978c67931a354006837", "ffffccd9f0a3addd8e78c67931a354006837", "ffffccd9f0a3addd8e78c67941ab5d238443005a32", "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32", "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529").map(H_), Bb = rb(Ob), Yb = new Array(3).concat("fff7bcfec44fd95f0e", "ffffd4fed98efe9929cc4c02", "ffffd4fed98efe9929d95f0e993404", "ffffd4fee391fec44ffe9929d95f0e993404", "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04", "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04", "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506").map(H_), Lb = rb(Yb), jb = new Array(3).concat("ffeda0feb24cf03b20", "ffffb2fecc5cfd8d3ce31a1c", "ffffb2fecc5cfd8d3cf03b20bd0026", "ffffb2fed976feb24cfd8d3cf03b20bd0026", "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026", "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026", "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026").map(H_), Hb = rb(jb), Xb = new Array(3).concat("deebf79ecae13182bd", "eff3ffbdd7e76baed62171b5", "eff3ffbdd7e76baed63182bd08519c", "eff3ffc6dbef9ecae16baed63182bd08519c", "eff3ffc6dbef9ecae16baed64292c62171b5084594", "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594", "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b").map(H_), Gb = rb(Xb), Vb = new Array(3).concat("e5f5e0a1d99b31a354", "edf8e9bae4b374c476238b45", "edf8e9bae4b374c47631a354006d2c", "edf8e9c7e9c0a1d99b74c47631a354006d2c", "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32", "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32", "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b").map(H_), Wb = rb(Vb), Zb = new Array(3).concat("f0f0f0bdbdbd636363", "f7f7f7cccccc969696525252", "f7f7f7cccccc969696636363252525", "f7f7f7d9d9d9bdbdbd969696636363252525", "f7f7f7d9d9d9bdbdbd969696737373525252252525", "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525", "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000").map(H_), Kb = rb(Zb), Qb = new Array(3).concat("efedf5bcbddc756bb1", "f2f0f7cbc9e29e9ac86a51a3", "f2f0f7cbc9e29e9ac8756bb154278f", "f2f0f7dadaebbcbddc9e9ac8756bb154278f", "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486", "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486", "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d").map(H_), Jb = rb(Qb), tm = new Array(3).concat("fee0d2fc9272de2d26", "fee5d9fcae91fb6a4acb181d", "fee5d9fcae91fb6a4ade2d26a50f15", "fee5d9fcbba1fc9272fb6a4ade2d26a50f15", "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d", "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d", "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d").map(H_), nm = rb(tm), em = new Array(3).concat("fee6cefdae6be6550d", "feeddefdbe85fd8d3cd94701", "feeddefdbe85fd8d3ce6550da63603", "feeddefdd0a2fdae6bfd8d3ce6550da63603", "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04", "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04", "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704").map(H_), rm = rb(em); var im = hi(Tr(300, .5, 0), Tr(-240, .5, 1)), om = hi(Tr(-100, .75, .35), Tr(80, 1.5, .8)), am = hi(Tr(260, .75, .35), Tr(80, 1.5, .8)), um = Tr(); var cm = Fe(), fm = Math.PI / 3, sm = 2 * Math.PI / 3; function lm(t) { var n = t.length; return function(e) { return t[Math.max(0, Math.min(n - 1, Math.floor(e * n)))] } } var hm = lm(H_("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725")), dm = lm(H_("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf")), pm = lm(H_("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4")), gm = lm(H_("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921")); function ym(t) { return function() { return t } } const vm = Math.abs, _m = Math.atan2, bm = Math.cos, mm = Math.max, xm = Math.min, wm = Math.sin, Mm = Math.sqrt, Tm = 1e-12, Am = Math.PI, Sm = Am / 2, Em = 2 * Am; function Nm(t) { return t >= 1 ? Sm : t <= -1 ? -Sm : Math.asin(t) } function km(t) { let n = 3; return t.digits = function(e) { if (!arguments.length) return n; if (null == e) n = null; else { const t = Math.floor(e); if (!(t >= 0)) throw new RangeError(`invalid digits: ${e}`); n = t } return t }, () => new Ua(n) } function Cm(t) { return t.innerRadius } function Pm(t) { return t.outerRadius } function zm(t) { return t.startAngle } function $m(t) { return t.endAngle } function Dm(t) { return t && t.padAngle } function Rm(t, n, e, r, i, o, a) { var u = t - e, c = n - r, f = (a ? o : -o) / Mm(u * u + c * c), s = f * c, l = -f * u, h = t + s, d = n + l, p = e + s, g = r + l, y = (h + p) / 2, v = (d + g) / 2, _ = p - h, b = g - d, m = _ * _ + b * b, x = i - o, w = h * g - p * d, M = (b < 0 ? -1 : 1) * Mm(mm(0, x * x * m - w * w)), T = (w * b - _ * M) / m, A = (-w * _ - b * M) / m, S = (w * b + _ * M) / m, E = (-w * _ + b * M) / m, N = T - y, k = A - v, C = S - y, P = E - v; return N * N + k * k > C * C + P * P && (T = S, A = E), { cx: T, cy: A, x01: -s, y01: -l, x11: T * (i / x - 1), y11: A * (i / x - 1) } } var Fm = Array.prototype.slice; function qm(t) { return "object" == typeof t && "length" in t ? t : Array.from(t) } function Um(t) { this._context = t } function Im(t) { return new Um(t) } function Om(t) { return t[0] } function Bm(t) { return t[1] } function Ym(t, n) { var e = ym(!0), r = null, i = Im, o = null, a = km(u); function u(u) { var c, f, s, l = (u = qm(u)).length, h = !1; for (null == r && (o = i(s = a())), c = 0; c <= l; ++c)!(c < l && e(f = u[c], c, u)) === h && ((h = !h) ? o.lineStart() : o.lineEnd()), h && o.point(+t(f, c, u), +n(f, c, u)); if (s) return o = null, s + "" || null } return t = "function" == typeof t ? t : void 0 === t ? Om : ym(t), n = "function" == typeof n ? n : void 0 === n ? Bm : ym(n), u.x = function(n) { return arguments.length ? (t = "function" == typeof n ? n : ym(+n), u) : t }, u.y = function(t) { return arguments.length ? (n = "function" == typeof t ? t : ym(+t), u) : n }, u.defined = function(t) { return arguments.length ? (e = "function" == typeof t ? t : ym(!!t), u) : e }, u.curve = function(t) { return arguments.length ? (i = t, null != r && (o = i(r)), u) : i }, u.context = function(t) { return arguments.length ? (null == t ? r = o = null : o = i(r = t), u) : r }, u } function Lm(t, n, e) { var r = null, i = ym(!0), o = null, a = Im, u = null, c = km(f); function f(f) { var s, l, h, d, p, g = (f = qm(f)).length, y = !1, v = new Array(g), _ = new Array(g); for (null == o && (u = a(p = c())), s = 0; s <= g; ++s) { if (!(s < g && i(d = f[s], s, f)) === y) if (y = !y) l = s, u.areaStart(), u.lineStart(); else { for (u.lineEnd(), u.lineStart(), h = s - 1; h >= l; --h)u.point(v[h], _[h]); u.lineEnd(), u.areaEnd() } y && (v[s] = +t(d, s, f), _[s] = +n(d, s, f), u.point(r ? +r(d, s, f) : v[s], e ? +e(d, s, f) : _[s])) } if (p) return u = null, p + "" || null } function s() { return Ym().defined(i).curve(a).context(o) } return t = "function" == typeof t ? t : void 0 === t ? Om : ym(+t), n = "function" == typeof n ? n : ym(void 0 === n ? 0 : +n), e = "function" == typeof e ? e : void 0 === e ? Bm : ym(+e), f.x = function(n) { return arguments.length ? (t = "function" == typeof n ? n : ym(+n), r = null, f) : t }, f.x0 = function(n) { return arguments.length ? (t = "function" == typeof n ? n : ym(+n), f) : t }, f.x1 = function(t) { return arguments.length ? (r = null == t ? null : "function" == typeof t ? t : ym(+t), f) : r }, f.y = function(t) { return arguments.length ? (n = "function" == typeof t ? t : ym(+t), e = null, f) : n }, f.y0 = function(t) { return arguments.length ? (n = "function" == typeof t ? t : ym(+t), f) : n }, f.y1 = function(t) { return arguments.length ? (e = null == t ? null : "function" == typeof t ? t : ym(+t), f) : e }, f.lineX0 = f.lineY0 = function() { return s().x(t).y(n) }, f.lineY1 = function() { return s().x(t).y(e) }, f.lineX1 = function() { return s().x(r).y(n) }, f.defined = function(t) { return arguments.length ? (i = "function" == typeof t ? t : ym(!!t), f) : i }, f.curve = function(t) { return arguments.length ? (a = t, null != o && (u = a(o)), f) : a }, f.context = function(t) { return arguments.length ? (null == t ? o = u = null : u = a(o = t), f) : o }, f } function jm(t, n) { return n < t ? -1 : n > t ? 1 : n >= t ? 0 : NaN } function Hm(t) { return t } Um.prototype = { areaStart: function() { this._line = 0 }, areaEnd: function() { this._line = NaN }, lineStart: function() { this._point = 0 }, lineEnd: function() { (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line }, point: function(t, n) { switch (t = +t, n = +n, this._point) { case 0: this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n); break; case 1: this._point = 2; default: this._context.lineTo(t, n) } } }; var Xm = Vm(Im); function Gm(t) { this._curve = t } function Vm(t) { function n(n) { return new Gm(t(n)) } return n._curve = t, n } function Wm(t) { var n = t.curve; return t.angle = t.x, delete t.x, t.radius = t.y, delete t.y, t.curve = function(t) { return arguments.length ? n(Vm(t)) : n()._curve }, t } function Zm() { return Wm(Ym().curve(Xm)) } function Km() { var t = Lm().curve(Xm), n = t.curve, e = t.lineX0, r = t.lineX1, i = t.lineY0, o = t.lineY1; return t.angle = t.x, delete t.x, t.startAngle = t.x0, delete t.x0, t.endAngle = t.x1, delete t.x1, t.radius = t.y, delete t.y, t.innerRadius = t.y0, delete t.y0, t.outerRadius = t.y1, delete t.y1, t.lineStartAngle = function() { return Wm(e()) }, delete t.lineX0, t.lineEndAngle = function() { return Wm(r()) }, delete t.lineX1, t.lineInnerRadius = function() { return Wm(i()) }, delete t.lineY0, t.lineOuterRadius = function() { return Wm(o()) }, delete t.lineY1, t.curve = function(t) { return arguments.length ? n(Vm(t)) : n()._curve }, t } function Qm(t, n) { return [(n = +n) * Math.cos(t -= Math.PI / 2), n * Math.sin(t)] } Gm.prototype = { areaStart: function() { this._curve.areaStart() }, areaEnd: function() { this._curve.areaEnd() }, lineStart: function() { this._curve.lineStart() }, lineEnd: function() { this._curve.lineEnd() }, point: function(t, n) { this._curve.point(n * Math.sin(t), n * -Math.cos(t)) } }; class Jm { constructor(t, n) { this._context = t, this._x = n } areaStart() { this._line = 0 } areaEnd() { this._line = NaN } lineStart() { this._point = 0 } lineEnd() { (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line } point(t, n) { switch (t = +t, n = +n, this._point) { case 0: this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n); break; case 1: this._point = 2; default: this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + t) / 2, this._y0, this._x0, n, t, n) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + n) / 2, t, this._y0, t, n) }this._x0 = t, this._y0 = n } } class tx { constructor(t) { this._context = t } lineStart() { this._point = 0 } lineEnd() { } point(t, n) { if (t = +t, n = +n, 0 === this._point) this._point = 1; else { const e = Qm(this._x0, this._y0), r = Qm(this._x0, this._y0 = (this._y0 + n) / 2), i = Qm(t, this._y0), o = Qm(t, n); this._context.moveTo(...e), this._context.bezierCurveTo(...r, ...i, ...o) } this._x0 = t, this._y0 = n } } function nx(t) { return new Jm(t, !0) } function ex(t) { return new Jm(t, !1) } function rx(t) { return new tx(t) } function ix(t) { return t.source } function ox(t) { return t.target } function ax(t) { let n = ix, e = ox, r = Om, i = Bm, o = null, a = null, u = km(c); function c() { let c; const f = Fm.call(arguments), s = n.apply(this, f), l = e.apply(this, f); if (null == o && (a = t(c = u())), a.lineStart(), f[0] = s, a.point(+r.apply(this, f), +i.apply(this, f)), f[0] = l, a.point(+r.apply(this, f), +i.apply(this, f)), a.lineEnd(), c) return a = null, c + "" || null } return c.source = function(t) { return arguments.length ? (n = t, c) : n }, c.target = function(t) { return arguments.length ? (e = t, c) : e }, c.x = function(t) { return arguments.length ? (r = "function" == typeof t ? t : ym(+t), c) : r }, c.y = function(t) { return arguments.length ? (i = "function" == typeof t ? t : ym(+t), c) : i }, c.context = function(n) { return arguments.length ? (null == n ? o = a = null : a = t(o = n), c) : o }, c } const ux = Mm(3); var cx = { draw(t, n) { const e = .59436 * Mm(n + xm(n / 28, .75)), r = e / 2, i = r * ux; t.moveTo(0, e), t.lineTo(0, -e), t.moveTo(-i, -r), t.lineTo(i, r), t.moveTo(-i, r), t.lineTo(i, -r) } }, fx = { draw(t, n) { const e = Mm(n / Am); t.moveTo(e, 0), t.arc(0, 0, e, 0, Em) } }, sx = { draw(t, n) { const e = Mm(n / 5) / 2; t.moveTo(-3 * e, -e), t.lineTo(-e, -e), t.lineTo(-e, -3 * e), t.lineTo(e, -3 * e), t.lineTo(e, -e), t.lineTo(3 * e, -e), t.lineTo(3 * e, e), t.lineTo(e, e), t.lineTo(e, 3 * e), t.lineTo(-e, 3 * e), t.lineTo(-e, e), t.lineTo(-3 * e, e), t.closePath() } }; const lx = Mm(1 / 3), hx = 2 * lx; var dx = { draw(t, n) { const e = Mm(n / hx), r = e * lx; t.moveTo(0, -e), t.lineTo(r, 0), t.lineTo(0, e), t.lineTo(-r, 0), t.closePath() } }, px = { draw(t, n) { const e = .62625 * Mm(n); t.moveTo(0, -e), t.lineTo(e, 0), t.lineTo(0, e), t.lineTo(-e, 0), t.closePath() } }, gx = { draw(t, n) { const e = .87559 * Mm(n - xm(n / 7, 2)); t.moveTo(-e, 0), t.lineTo(e, 0), t.moveTo(0, e), t.lineTo(0, -e) } }, yx = { draw(t, n) { const e = Mm(n), r = -e / 2; t.rect(r, r, e, e) } }, vx = { draw(t, n) { const e = .4431 * Mm(n); t.moveTo(e, e), t.lineTo(e, -e), t.lineTo(-e, -e), t.lineTo(-e, e), t.closePath() } }; const _x = wm(Am / 10) / wm(7 * Am / 10), bx = wm(Em / 10) * _x, mx = -bm(Em / 10) * _x; var xx = { draw(t, n) { const e = Mm(.8908130915292852 * n), r = bx * e, i = mx * e; t.moveTo(0, -e), t.lineTo(r, i); for (let n = 1; n < 5; ++n) { const o = Em * n / 5, a = bm(o), u = wm(o); t.lineTo(u * e, -a * e), t.lineTo(a * r - u * i, u * r + a * i) } t.closePath() } }; const wx = Mm(3); var Mx = { draw(t, n) { const e = -Mm(n / (3 * wx)); t.moveTo(0, 2 * e), t.lineTo(-wx * e, -e), t.lineTo(wx * e, -e), t.closePath() } }; const Tx = Mm(3); var Ax = { draw(t, n) { const e = .6824 * Mm(n), r = e / 2, i = e * Tx / 2; t.moveTo(0, -e), t.lineTo(i, r), t.lineTo(-i, r), t.closePath() } }; const Sx = -.5, Ex = Mm(3) / 2, Nx = 1 / Mm(12), kx = 3 * (Nx / 2 + 1); var Cx = { draw(t, n) { const e = Mm(n / kx), r = e / 2, i = e * Nx, o = r, a = e * Nx + e, u = -o, c = a; t.moveTo(r, i), t.lineTo(o, a), t.lineTo(u, c), t.lineTo(Sx * r - Ex * i, Ex * r + Sx * i), t.lineTo(Sx * o - Ex * a, Ex * o + Sx * a), t.lineTo(Sx * u - Ex * c, Ex * u + Sx * c), t.lineTo(Sx * r + Ex * i, Sx * i - Ex * r), t.lineTo(Sx * o + Ex * a, Sx * a - Ex * o), t.lineTo(Sx * u + Ex * c, Sx * c - Ex * u), t.closePath() } }, Px = { draw(t, n) { const e = .6189 * Mm(n - xm(n / 6, 1.7)); t.moveTo(-e, -e), t.lineTo(e, e), t.moveTo(-e, e), t.lineTo(e, -e) } }; const zx = [fx, sx, dx, yx, xx, Mx, Cx], $x = [fx, gx, Px, Ax, cx, vx, px]; function Dx() { } function Rx(t, n, e) { t._context.bezierCurveTo((2 * t._x0 + t._x1) / 3, (2 * t._y0 + t._y1) / 3, (t._x0 + 2 * t._x1) / 3, (t._y0 + 2 * t._y1) / 3, (t._x0 + 4 * t._x1 + n) / 6, (t._y0 + 4 * t._y1 + e) / 6) } function Fx(t) { this._context = t } function qx(t) { this._context = t } function Ux(t) { this._context = t } function Ix(t, n) { this._basis = new Fx(t), this._beta = n } Fx.prototype = { areaStart: function() { this._line = 0 }, areaEnd: function() { this._line = NaN }, lineStart: function() { this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0 }, lineEnd: function() { switch (this._point) { case 3: Rx(this, this._x1, this._y1); case 2: this._context.lineTo(this._x1, this._y1) }(this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line }, point: function(t, n) { switch (t = +t, n = +n, this._point) { case 0: this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n); break; case 1: this._point = 2; break; case 2: this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); default: Rx(this, t, n) }this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = n } }, qx.prototype = { areaStart: Dx, areaEnd: Dx, lineStart: function() { this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0 }, lineEnd: function() { switch (this._point) { case 1: this._context.moveTo(this._x2, this._y2), this._context.closePath(); break; case 2: this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath(); break; case 3: this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4) } }, point: function(t, n) { switch (t = +t, n = +n, this._point) { case 0: this._point = 1, this._x2 = t, this._y2 = n; break; case 1: this._point = 2, this._x3 = t, this._y3 = n; break; case 2: this._point = 3, this._x4 = t, this._y4 = n, this._context.moveTo((this._x0 + 4 * this._x1 + t) / 6, (this._y0 + 4 * this._y1 + n) / 6); break; default: Rx(this, t, n) }this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = n } }, Ux.prototype = { areaStart: function() { this._line = 0 }, areaEnd: function() { this._line = NaN }, lineStart: function() { this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0 }, lineEnd: function() { (this._line || 0 !== this._line && 3 === this._point) && this._context.closePath(), this._line = 1 - this._line }, point: function(t, n) { switch (t = +t, n = +n, this._point) { case 0: this._point = 1; break; case 1: this._point = 2; break; case 2: this._point = 3; var e = (this._x0 + 4 * this._x1 + t) / 6, r = (this._y0 + 4 * this._y1 + n) / 6; this._line ? this._context.lineTo(e, r) : this._context.moveTo(e, r); break; case 3: this._point = 4; default: Rx(this, t, n) }this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = n } }, Ix.prototype = { lineStart: function() { this._x = [], this._y = [], this._basis.lineStart() }, lineEnd: function() { var t = this._x, n = this._y, e = t.length - 1; if (e > 0) for (var r, i = t[0], o = n[0], a = t[e] - i, u = n[e] - o, c = -1; ++c <= e;)r = c / e, this._basis.point(this._beta * t[c] + (1 - this._beta) * (i + r * a), this._beta * n[c] + (1 - this._beta) * (o + r * u)); this._x = this._y = null, this._basis.lineEnd() }, point: function(t, n) { this._x.push(+t), this._y.push(+n) } }; var Ox = function t(n) { function e(t) { return 1 === n ? new Fx(t) : new Ix(t, n) } return e.beta = function(n) { return t(+n) }, e }(.85); function Bx(t, n, e) { t._context.bezierCurveTo(t._x1 + t._k * (t._x2 - t._x0), t._y1 + t._k * (t._y2 - t._y0), t._x2 + t._k * (t._x1 - n), t._y2 + t._k * (t._y1 - e), t._x2, t._y2) } function Yx(t, n) { this._context = t, this._k = (1 - n) / 6 } Yx.prototype = { areaStart: function() { this._line = 0 }, areaEnd: function() { this._line = NaN }, lineStart: function() { this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0 }, lineEnd: function() { switch (this._point) { case 2: this._context.lineTo(this._x2, this._y2); break; case 3: Bx(this, this._x1, this._y1) }(this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line }, point: function(t, n) { switch (t = +t, n = +n, this._point) { case 0: this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n); break; case 1: this._point = 2, this._x1 = t, this._y1 = n; break; case 2: this._point = 3; default: Bx(this, t, n) }this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n } }; var Lx = function t(n) { function e(t) { return new Yx(t, n) } return e.tension = function(n) { return t(+n) }, e }(0); function jx(t, n) { this._context = t, this._k = (1 - n) / 6 } jx.prototype = { areaStart: Dx, areaEnd: Dx, lineStart: function() { this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0 }, lineEnd: function() { switch (this._point) { case 1: this._context.moveTo(this._x3, this._y3), this._context.closePath(); break; case 2: this._context.lineTo(this._x3, this._y3), this._context.closePath(); break; case 3: this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5) } }, point: function(t, n) { switch (t = +t, n = +n, this._point) { case 0: this._point = 1, this._x3 = t, this._y3 = n; break; case 1: this._point = 2, this._context.moveTo(this._x4 = t, this._y4 = n); break; case 2: this._point = 3, this._x5 = t, this._y5 = n; break; default: Bx(this, t, n) }this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n } }; var Hx = function t(n) { function e(t) { return new jx(t, n) } return e.tension = function(n) { return t(+n) }, e }(0); function Xx(t, n) { this._context = t, this._k = (1 - n) / 6 } Xx.prototype = { areaStart: function() { this._line = 0 }, areaEnd: function() { this._line = NaN }, lineStart: function() { this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0 }, lineEnd: function() { (this._line || 0 !== this._line && 3 === this._point) && this._context.closePath(), this._line = 1 - this._line }, point: function(t, n) { switch (t = +t, n = +n, this._point) { case 0: this._point = 1; break; case 1: this._point = 2; break; case 2: this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break; case 3: this._point = 4; default: Bx(this, t, n) }this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n } }; var Gx = function t(n) { function e(t) { return new Xx(t, n) } return e.tension = function(n) { return t(+n) }, e }(0); function Vx(t, n, e) { var r = t._x1, i = t._y1, o = t._x2, a = t._y2; if (t._l01_a > Tm) { var u = 2 * t._l01_2a + 3 * t._l01_a * t._l12_a + t._l12_2a, c = 3 * t._l01_a * (t._l01_a + t._l12_a); r = (r * u - t._x0 * t._l12_2a + t._x2 * t._l01_2a) / c, i = (i * u - t._y0 * t._l12_2a + t._y2 * t._l01_2a) / c } if (t._l23_a > Tm) { var f = 2 * t._l23_2a + 3 * t._l23_a * t._l12_a + t._l12_2a, s = 3 * t._l23_a * (t._l23_a + t._l12_a); o = (o * f + t._x1 * t._l23_2a - n * t._l12_2a) / s, a = (a * f + t._y1 * t._l23_2a - e * t._l12_2a) / s } t._context.bezierCurveTo(r, i, o, a, t._x2, t._y2) } function Wx(t, n) { this._context = t, this._alpha = n } Wx.prototype = { areaStart: function() { this._line = 0 }, areaEnd: function() { this._line = NaN }, lineStart: function() { this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0 }, lineEnd: function() { switch (this._point) { case 2: this._context.lineTo(this._x2, this._y2); break; case 3: this.point(this._x2, this._y2) }(this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line }, point: function(t, n) { if (t = +t, n = +n, this._point) { var e = this._x2 - t, r = this._y2 - n; this._l23_a = Math.sqrt(this._l23_2a = Math.pow(e * e + r * r, this._alpha)) } switch (this._point) { case 0: this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n); break; case 1: this._point = 2; break; case 2: this._point = 3; default: Vx(this, t, n) }this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n } }; var Zx = function t(n) { function e(t) { return n ? new Wx(t, n) : new Yx(t, 0) } return e.alpha = function(n) { return t(+n) }, e }(.5); function Kx(t, n) { this._context = t, this._alpha = n } Kx.prototype = { areaStart: Dx, areaEnd: Dx, lineStart: function() { this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0 }, lineEnd: function() { switch (this._point) { case 1: this._context.moveTo(this._x3, this._y3), this._context.closePath(); break; case 2: this._context.lineTo(this._x3, this._y3), this._context.closePath(); break; case 3: this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5) } }, point: function(t, n) { if (t = +t, n = +n, this._point) { var e = this._x2 - t, r = this._y2 - n; this._l23_a = Math.sqrt(this._l23_2a = Math.pow(e * e + r * r, this._alpha)) } switch (this._point) { case 0: this._point = 1, this._x3 = t, this._y3 = n; break; case 1: this._point = 2, this._context.moveTo(this._x4 = t, this._y4 = n); break; case 2: this._point = 3, this._x5 = t, this._y5 = n; break; default: Vx(this, t, n) }this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n } }; var Qx = function t(n) { function e(t) { return n ? new Kx(t, n) : new jx(t, 0) } return e.alpha = function(n) { return t(+n) }, e }(.5); function Jx(t, n) { this._context = t, this._alpha = n } Jx.prototype = { areaStart: function() { this._line = 0 }, areaEnd: function() { this._line = NaN }, lineStart: function() { this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0 }, lineEnd: function() { (this._line || 0 !== this._line && 3 === this._point) && this._context.closePath(), this._line = 1 - this._line }, point: function(t, n) { if (t = +t, n = +n, this._point) { var e = this._x2 - t, r = this._y2 - n; this._l23_a = Math.sqrt(this._l23_2a = Math.pow(e * e + r * r, this._alpha)) } switch (this._point) { case 0: this._point = 1; break; case 1: this._point = 2; break; case 2: this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break; case 3: this._point = 4; default: Vx(this, t, n) }this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n } }; var tw = function t(n) { function e(t) { return n ? new Jx(t, n) : new Xx(t, 0) } return e.alpha = function(n) { return t(+n) }, e }(.5); function nw(t) { this._context = t } function ew(t) { return t < 0 ? -1 : 1 } function rw(t, n, e) { var r = t._x1 - t._x0, i = n - t._x1, o = (t._y1 - t._y0) / (r || i < 0 && -0), a = (e - t._y1) / (i || r < 0 && -0), u = (o * i + a * r) / (r + i); return (ew(o) + ew(a)) * Math.min(Math.abs(o), Math.abs(a), .5 * Math.abs(u)) || 0 } function iw(t, n) { var e = t._x1 - t._x0; return e ? (3 * (t._y1 - t._y0) / e - n) / 2 : n } function ow(t, n, e) { var r = t._x0, i = t._y0, o = t._x1, a = t._y1, u = (o - r) / 3; t._context.bezierCurveTo(r + u, i + u * n, o - u, a - u * e, o, a) } function aw(t) { this._context = t } function uw(t) { this._context = new cw(t) } function cw(t) { this._context = t } function fw(t) { this._context = t } function sw(t) { var n, e, r = t.length - 1, i = new Array(r), o = new Array(r), a = new Array(r); for (i[0] = 0, o[0] = 2, a[0] = t[0] + 2 * t[1], n = 1; n < r - 1; ++n)i[n] = 1, o[n] = 4, a[n] = 4 * t[n] + 2 * t[n + 1]; for (i[r - 1] = 2, o[r - 1] = 7, a[r - 1] = 8 * t[r - 1] + t[r], n = 1; n < r; ++n)e = i[n] / o[n - 1], o[n] -= e, a[n] -= e * a[n - 1]; for (i[r - 1] = a[r - 1] / o[r - 1], n = r - 2; n >= 0; --n)i[n] = (a[n] - i[n + 1]) / o[n]; for (o[r - 1] = (t[r] + i[r - 1]) / 2, n = 0; n < r - 1; ++n)o[n] = 2 * t[n + 1] - i[n + 1]; return [i, o] } function lw(t, n) { this._context = t, this._t = n } function hw(t, n) { if ((i = t.length) > 1) for (var e, r, i, o = 1, a = t[n[0]], u = a.length; o < i; ++o)for (r = a, a = t[n[o]], e = 0; e < u; ++e)a[e][1] += a[e][0] = isNaN(r[e][1]) ? r[e][0] : r[e][1] } function dw(t) { for (var n = t.length, e = new Array(n); --n >= 0;)e[n] = n; return e } function pw(t, n) { return t[n] } function gw(t) { const n = []; return n.key = t, n } function yw(t) { var n = t.map(vw); return dw(t).sort((function(t, e) { return n[t] - n[e] })) } function vw(t) { for (var n, e = -1, r = 0, i = t.length, o = -1 / 0; ++e < i;)(n = +t[e][1]) > o && (o = n, r = e); return r } function _w(t) { var n = t.map(bw); return dw(t).sort((function(t, e) { return n[t] - n[e] })) } function bw(t) { for (var n, e = 0, r = -1, i = t.length; ++r < i;)(n = +t[r][1]) && (e += n); return e } nw.prototype = { areaStart: Dx, areaEnd: Dx, lineStart: function() { this._point = 0 }, lineEnd: function() { this._point && this._context.closePath() }, point: function(t, n) { t = +t, n = +n, this._point ? this._context.lineTo(t, n) : (this._point = 1, this._context.moveTo(t, n)) } }, aw.prototype = { areaStart: function() { this._line = 0 }, areaEnd: function() { this._line = NaN }, lineStart: function() { this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0 }, lineEnd: function() { switch (this._point) { case 2: this._context.lineTo(this._x1, this._y1); break; case 3: ow(this, this._t0, iw(this, this._t0)) }(this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line }, point: function(t, n) { var e = NaN; if (n = +n, (t = +t) !== this._x1 || n !== this._y1) { switch (this._point) { case 0: this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n); break; case 1: this._point = 2; break; case 2: this._point = 3, ow(this, iw(this, e = rw(this, t, n)), e); break; default: ow(this, this._t0, e = rw(this, t, n)) }this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = n, this._t0 = e } } }, (uw.prototype = Object.create(aw.prototype)).point = function(t, n) { aw.prototype.point.call(this, n, t) }, cw.prototype = { moveTo: function(t, n) { this._context.moveTo(n, t) }, closePath: function() { this._context.closePath() }, lineTo: function(t, n) { this._context.lineTo(n, t) }, bezierCurveTo: function(t, n, e, r, i, o) { this._context.bezierCurveTo(n, t, r, e, o, i) } }, fw.prototype = { areaStart: function() { this._line = 0 }, areaEnd: function() { this._line = NaN }, lineStart: function() { this._x = [], this._y = [] }, lineEnd: function() { var t = this._x, n = this._y, e = t.length; if (e) if (this._line ? this._context.lineTo(t[0], n[0]) : this._context.moveTo(t[0], n[0]), 2 === e) this._context.lineTo(t[1], n[1]); else for (var r = sw(t), i = sw(n), o = 0, a = 1; a < e; ++o, ++a)this._context.bezierCurveTo(r[0][o], i[0][o], r[1][o], i[1][o], t[a], n[a]); (this._line || 0 !== this._line && 1 === e) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null }, point: function(t, n) { this._x.push(+t), this._y.push(+n) } }, lw.prototype = { areaStart: function() { this._line = 0 }, areaEnd: function() { this._line = NaN }, lineStart: function() { this._x = this._y = NaN, this._point = 0 }, lineEnd: function() { 0 < this._t && this._t < 1 && 2 === this._point && this._context.lineTo(this._x, this._y), (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line) }, point: function(t, n) { switch (t = +t, n = +n, this._point) { case 0: this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n); break; case 1: this._point = 2; default: if (this._t <= 0) this._context.lineTo(this._x, n), this._context.lineTo(t, n); else { var e = this._x * (1 - this._t) + t * this._t; this._context.lineTo(e, this._y), this._context.lineTo(e, n) } }this._x = t, this._y = n } }; var mw = t => () => t; function xw(t, { sourceEvent: n, target: e, transform: r, dispatch: i }) { Object.defineProperties(this, { type: { value: t, enumerable: !0, configurable: !0 }, sourceEvent: { value: n, enumerable: !0, configurable: !0 }, target: { value: e, enumerable: !0, configurable: !0 }, transform: { value: r, enumerable: !0, configurable: !0 }, _: { value: i } }) } function ww(t, n, e) { this.k = t, this.x = n, this.y = e } ww.prototype = { constructor: ww, scale: function(t) { return 1 === t ? this : new ww(this.k * t, this.x, this.y) }, translate: function(t, n) { return 0 === t & 0 === n ? this : new ww(this.k, this.x + this.k * t, this.y + this.k * n) }, apply: function(t) { return [t[0] * this.k + this.x, t[1] * this.k + this.y] }, applyX: function(t) { return t * this.k + this.x }, applyY: function(t) { return t * this.k + this.y }, invert: function(t) { return [(t[0] - this.x) / this.k, (t[1] - this.y) / this.k] }, invertX: function(t) { return (t - this.x) / this.k }, invertY: function(t) { return (t - this.y) / this.k }, rescaleX: function(t) { return t.copy().domain(t.range().map(this.invertX, this).map(t.invert, t)) }, rescaleY: function(t) { return t.copy().domain(t.range().map(this.invertY, this).map(t.invert, t)) }, toString: function() { return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")" } }; var Mw = new ww(1, 0, 0); function Tw(t) { for (; !t.__zoom;)if (!(t = t.parentNode)) return Mw; return t.__zoom } function Aw(t) { t.stopImmediatePropagation() } function Sw(t) { t.preventDefault(), t.stopImmediatePropagation() } function Ew(t) { return !(t.ctrlKey && "wheel" !== t.type || t.button) } function Nw() { var t = this; return t instanceof SVGElement ? (t = t.ownerSVGElement || t).hasAttribute("viewBox") ? [[(t = t.viewBox.baseVal).x, t.y], [t.x + t.width, t.y + t.height]] : [[0, 0], [t.width.baseVal.value, t.height.baseVal.value]] : [[0, 0], [t.clientWidth, t.clientHeight]] } function kw() { return this.__zoom || Mw } function Cw(t) { return -t.deltaY * (1 === t.deltaMode ? .05 : t.deltaMode ? 1 : .002) * (t.ctrlKey ? 10 : 1) } function Pw() { return navigator.maxTouchPoints || "ontouchstart" in this } function zw(t, n, e) { var r = t.invertX(n[0][0]) - e[0][0], i = t.invertX(n[1][0]) - e[1][0], o = t.invertY(n[0][1]) - e[0][1], a = t.invertY(n[1][1]) - e[1][1]; return t.translate(i > r ? (r + i) / 2 : Math.min(0, r) || Math.max(0, i), a > o ? (o + a) / 2 : Math.min(0, o) || Math.max(0, a)) } Tw.prototype = ww.prototype, t.Adder = T, t.Delaunay = Lu, t.FormatSpecifier = tf, t.InternMap = InternMap, t.InternSet = InternSet, t.Node = Qd, t.Path = Ua, t.Voronoi = qu, t.ZoomTransform = ww, t.active = function(t, n) { var e, r, i = t.__transition; if (i) for (r in n = null == n ? null : n + "", i) if ((e = i[r]).state > qi && e.name === n) return new po([[t]], Zo, n, +r); return null }, t.arc = function() { var t = Cm, n = Pm, e = ym(0), r = null, i = zm, o = $m, a = Dm, u = null, c = km(f); function f() { var f, s, l = +t.apply(this, arguments), h = +n.apply(this, arguments), d = i.apply(this, arguments) - Sm, p = o.apply(this, arguments) - Sm, g = vm(p - d), y = p > d; if (u || (u = f = c()), h < l && (s = h, h = l, l = s), h > Tm) if (g > Em - Tm) u.moveTo(h * bm(d), h * wm(d)), u.arc(0, 0, h, d, p, !y), l > Tm && (u.moveTo(l * bm(p), l * wm(p)), u.arc(0, 0, l, p, d, y)); else { var v, _, b = d, m = p, x = d, w = p, M = g, T = g, A = a.apply(this, arguments) / 2, S = A > Tm && (r ? +r.apply(this, arguments) : Mm(l * l + h * h)), E = xm(vm(h - l) / 2, +e.apply(this, arguments)), N = E, k = E; if (S > Tm) { var C = Nm(S / l * wm(A)), P = Nm(S / h * wm(A)); (M -= 2 * C) > Tm ? (x += C *= y ? 1 : -1, w -= C) : (M = 0, x = w = (d + p) / 2), (T -= 2 * P) > Tm ? (b += P *= y ? 1 : -1, m -= P) : (T = 0, b = m = (d + p) / 2) } var z = h * bm(b), $ = h * wm(b), D = l * bm(w), R = l * wm(w); if (E > Tm) { var F, q = h * bm(m), U = h * wm(m), I = l * bm(x), O = l * wm(x); if (g < Am) if (F = function(t, n, e, r, i, o, a, u) { var c = e - t, f = r - n, s = a - i, l = u - o, h = l * c - s * f; if (!(h * h < Tm)) return [t + (h = (s * (n - o) - l * (t - i)) / h) * c, n + h * f] }(z, $, I, O, q, U, D, R)) { var B = z - F[0], Y = $ - F[1], L = q - F[0], j = U - F[1], H = 1 / wm(function(t) { return t > 1 ? 0 : t < -1 ? Am : Math.acos(t) }((B * L + Y * j) / (Mm(B * B + Y * Y) * Mm(L * L + j * j))) / 2), X = Mm(F[0] * F[0] + F[1] * F[1]); N = xm(E, (l - X) / (H - 1)), k = xm(E, (h - X) / (H + 1)) } else N = k = 0 } T > Tm ? k > Tm ? (v = Rm(I, O, z, $, h, k, y), _ = Rm(q, U, D, R, h, k, y), u.moveTo(v.cx + v.x01, v.cy + v.y01), k < E ? u.arc(v.cx, v.cy, k, _m(v.y01, v.x01), _m(_.y01, _.x01), !y) : (u.arc(v.cx, v.cy, k, _m(v.y01, v.x01), _m(v.y11, v.x11), !y), u.arc(0, 0, h, _m(v.cy + v.y11, v.cx + v.x11), _m(_.cy + _.y11, _.cx + _.x11), !y), u.arc(_.cx, _.cy, k, _m(_.y11, _.x11), _m(_.y01, _.x01), !y))) : (u.moveTo(z, $), u.arc(0, 0, h, b, m, !y)) : u.moveTo(z, $), l > Tm && M > Tm ? N > Tm ? (v = Rm(D, R, q, U, l, -N, y), _ = Rm(z, $, I, O, l, -N, y), u.lineTo(v.cx + v.x01, v.cy + v.y01), N < E ? u.arc(v.cx, v.cy, N, _m(v.y01, v.x01), _m(_.y01, _.x01), !y) : (u.arc(v.cx, v.cy, N, _m(v.y01, v.x01), _m(v.y11, v.x11), !y), u.arc(0, 0, l, _m(v.cy + v.y11, v.cx + v.x11), _m(_.cy + _.y11, _.cx + _.x11), y), u.arc(_.cx, _.cy, N, _m(_.y11, _.x11), _m(_.y01, _.x01), !y))) : u.arc(0, 0, l, w, x, y) : u.lineTo(D, R) } else u.moveTo(0, 0); if (u.closePath(), f) return u = null, f + "" || null } return f.centroid = function() { var e = (+t.apply(this, arguments) + +n.apply(this, arguments)) / 2, r = (+i.apply(this, arguments) + +o.apply(this, arguments)) / 2 - Am / 2; return [bm(r) * e, wm(r) * e] }, f.innerRadius = function(n) { return arguments.length ? (t = "function" == typeof n ? n : ym(+n), f) : t }, f.outerRadius = function(t) { return arguments.length ? (n = "function" == typeof t ? t : ym(+t), f) : n }, f.cornerRadius = function(t) { return arguments.length ? (e = "function" == typeof t ? t : ym(+t), f) : e }, f.padRadius = function(t) { return arguments.length ? (r = null == t ? null : "function" == typeof t ? t : ym(+t), f) : r }, f.startAngle = function(t) { return arguments.length ? (i = "function" == typeof t ? t : ym(+t), f) : i }, f.endAngle = function(t) { return arguments.length ? (o = "function" == typeof t ? t : ym(+t), f) : o }, f.padAngle = function(t) { return arguments.length ? (a = "function" == typeof t ? t : ym(+t), f) : a }, f.context = function(t) { return arguments.length ? (u = null == t ? null : t, f) : u }, f }, t.area = Lm, t.areaRadial = Km, t.ascending = n, t.autoType = function(t) { for (var n in t) { var e, r, i = t[n].trim(); if (i) if ("true" === i) i = !0; else if ("false" === i) i = !1; else if ("NaN" === i) i = NaN; else if (isNaN(e = +i)) { if (!(r = i.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/))) continue; yc && r[4] && !r[7] && (i = i.replace(/-/g, "/").replace(/T/, " ")), i = new Date(i) } else i = e; else i = null; t[n] = i } return t }, t.axisBottom = function(t) { return Pt(Mt, t) }, t.axisLeft = function(t) { return Pt(Tt, t) }, t.axisRight = function(t) { return Pt(wt, t) }, t.axisTop = function(t) { return Pt(xt, t) }, t.bin = Q, t.bisect = s, t.bisectCenter = f, t.bisectLeft = c, t.bisectRight = u, t.bisector = r, t.blob = function(t, n) { return fetch(t, n).then(vc) }, t.blur = function(t, n) { if (!((n = +n) >= 0)) throw new RangeError("invalid r"); let e = t.length; if (!((e = Math.floor(e)) >= 0)) throw new RangeError("invalid length"); if (!e || !n) return t; const r = y(n), i = t.slice(); return r(t, i, 0, e, 1), r(i, t, 0, e, 1), r(t, i, 0, e, 1), t }, t.blur2 = l, t.blurImage = h, t.brush = function() { return wa(la) }, t.brushSelection = function(t) { var n = t.__brush; return n ? n.dim.output(n.selection) : null }, t.brushX = function() { return wa(fa) }, t.brushY = function() { return wa(sa) }, t.buffer = function(t, n) { return fetch(t, n).then(_c) }, t.chord = function() { return za(!1, !1) }, t.chordDirected = function() { return za(!0, !1) }, t.chordTranspose = function() { return za(!1, !0) }, t.cluster = function() { var t = Ld, n = 1, e = 1, r = !1; function i(i) { var o, a = 0; i.eachAfter((function(n) { var e = n.children; e ? (n.x = function(t) { return t.reduce(jd, 0) / t.length }(e), n.y = function(t) { return 1 + t.reduce(Hd, 0) }(e)) : (n.x = o ? a += t(n, o) : 0, n.y = 0, o = n) })); var u = function(t) { for (var n; n = t.children;)t = n[0]; return t }(i), c = function(t) { for (var n; n = t.children;)t = n[n.length - 1]; return t }(i), f = u.x - t(u, c) / 2, s = c.x + t(c, u) / 2; return i.eachAfter(r ? function(t) { t.x = (t.x - i.x) * n, t.y = (i.y - t.y) * e } : function(t) { t.x = (t.x - f) / (s - f) * n, t.y = (1 - (i.y ? t.y / i.y : 1)) * e }) } return i.separation = function(n) { return arguments.length ? (t = n, i) : t }, i.size = function(t) { return arguments.length ? (r = !1, n = +t[0], e = +t[1], i) : r ? null : [n, e] }, i.nodeSize = function(t) { return arguments.length ? (r = !0, n = +t[0], e = +t[1], i) : r ? [n, e] : null }, i }, t.color = ze, t.contourDensity = function() { var t = fu, n = su, e = lu, r = 960, i = 500, o = 20, a = 2, u = 3 * o, c = r + 2 * u >> a, f = i + 2 * u >> a, s = Qa(20); function h(r) { var i = new Float32Array(c * f), s = Math.pow(2, -a), h = -1; for (const o of r) { var d = (t(o, ++h, r) + u) * s, p = (n(o, h, r) + u) * s, g = +e(o, h, r); if (g && d >= 0 && d < c && p >= 0 && p < f) { var y = Math.floor(d), v = Math.floor(p), _ = d - y - .5, b = p - v - .5; i[y + v * c] += (1 - _) * (1 - b) * g, i[y + 1 + v * c] += _ * (1 - b) * g, i[y + 1 + (v + 1) * c] += _ * b * g, i[y + (v + 1) * c] += (1 - _) * b * g } } return l({ data: i, width: c, height: f }, o * s), i } function d(t) { var n = h(t), e = s(n), r = Math.pow(2, 2 * a); return Array.isArray(e) || (e = G(Number.MIN_VALUE, J(n) / r, e)), iu().size([c, f]).thresholds(e.map((t => t * r)))(n).map(((t, n) => (t.value = +e[n], p(t)))) } function p(t) { return t.coordinates.forEach(g), t } function g(t) { t.forEach(y) } function y(t) { t.forEach(v) } function v(t) { t[0] = t[0] * Math.pow(2, a) - u, t[1] = t[1] * Math.pow(2, a) - u } function _() { return c = r + 2 * (u = 3 * o) >> a, f = i + 2 * u >> a, d } return d.contours = function(t) { var n = h(t), e = iu().size([c, f]), r = Math.pow(2, 2 * a), i = t => { t = +t; var i = p(e.contour(n, t * r)); return i.value = t, i }; return Object.defineProperty(i, "max", { get: () => J(n) / r }), i }, d.x = function(n) { return arguments.length ? (t = "function" == typeof n ? n : Qa(+n), d) : t }, d.y = function(t) { return arguments.length ? (n = "function" == typeof t ? t : Qa(+t), d) : n }, d.weight = function(t) { return arguments.length ? (e = "function" == typeof t ? t : Qa(+t), d) : e }, d.size = function(t) { if (!arguments.length) return [r, i]; var n = +t[0], e = +t[1]; if (!(n >= 0 && e >= 0)) throw new Error("invalid size"); return r = n, i = e, _() }, d.cellSize = function(t) { if (!arguments.length) return 1 << a; if (!((t = +t) >= 1)) throw new Error("invalid cell size"); return a = Math.floor(Math.log(t) / Math.LN2), _() }, d.thresholds = function(t) { return arguments.length ? (s = "function" == typeof t ? t : Array.isArray(t) ? Qa(Za.call(t)) : Qa(t), d) : s }, d.bandwidth = function(t) { if (!arguments.length) return Math.sqrt(o * (o + 1)); if (!((t = +t) >= 0)) throw new Error("invalid bandwidth"); return o = (Math.sqrt(4 * t * t + 1) - 1) / 2, _() }, d }, t.contours = iu, t.count = v, t.create = function(t) { return Zn(Yt(t).call(document.documentElement)) }, t.creator = Yt, t.cross = function(...t) { const n = "function" == typeof t[t.length - 1] && function(t) { return n => t(...n) }(t.pop()), e = (t = t.map(m)).map(_), r = t.length - 1, i = new Array(r + 1).fill(0), o = []; if (r < 0 || e.some(b)) return o; for (; ;) { o.push(i.map(((n, e) => t[e][n]))); let a = r; for (; ++i[a] === e[a];) { if (0 === a) return n ? o.map(n) : o; i[a--] = 0 } } }, t.csv = wc, t.csvFormat = rc, t.csvFormatBody = ic, t.csvFormatRow = ac, t.csvFormatRows = oc, t.csvFormatValue = uc, t.csvParse = nc, t.csvParseRows = ec, t.cubehelix = Tr, t.cumsum = function(t, n) { var e = 0, r = 0; return Float64Array.from(t, void 0 === n ? t => e += +t || 0 : i => e += +n(i, r++, t) || 0) }, t.curveBasis = function(t) { return new Fx(t) }, t.curveBasisClosed = function(t) { return new qx(t) }, t.curveBasisOpen = function(t) { return new Ux(t) }, t.curveBumpX = nx, t.curveBumpY = ex, t.curveBundle = Ox, t.curveCardinal = Lx, t.curveCardinalClosed = Hx, t.curveCardinalOpen = Gx, t.curveCatmullRom = Zx, t.curveCatmullRomClosed = Qx, t.curveCatmullRomOpen = tw, t.curveLinear = Im, t.curveLinearClosed = function(t) { return new nw(t) }, t.curveMonotoneX = function(t) { return new aw(t) }, t.curveMonotoneY = function(t) { return new uw(t) }, t.curveNatural = function(t) { return new fw(t) }, t.curveStep = function(t) { return new lw(t, .5) }, t.curveStepAfter = function(t) { return new lw(t, 1) }, t.curveStepBefore = function(t) { return new lw(t, 0) }, t.descending = e, t.deviation = w, t.difference = function(t, ...n) { t = new InternSet(t); for (const e of n) for (const n of e) t.delete(n); return t }, t.disjoint = function(t, n) { const e = n[Symbol.iterator](), r = new InternSet; for (const n of t) { if (r.has(n)) return !1; let t, i; for (; ({ value: t, done: i } = e.next()) && !i;) { if (Object.is(n, t)) return !1; r.add(t) } } return !0 }, t.dispatch = $t, t.drag = function() { var t, n, e, r, i = se, o = le, a = he, u = de, c = {}, f = $t("start", "drag", "end"), s = 0, l = 0; function h(t) { t.on("mousedown.drag", d).filter(u).on("touchstart.drag", y).on("touchmove.drag", v, ee).on("touchend.drag touchcancel.drag", _).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)") } function d(a, u) { if (!r && i.call(this, a, u)) { var c = b(this, o.call(this, a, u), a, u, "mouse"); c && (Zn(a.view).on("mousemove.drag", p, re).on("mouseup.drag", g, re), ae(a.view), ie(a), e = !1, t = a.clientX, n = a.clientY, c("start", a)) } } function p(r) { if (oe(r), !e) { var i = r.clientX - t, o = r.clientY - n; e = i * i + o * o > l } c.mouse("drag", r) } function g(t) { Zn(t.view).on("mousemove.drag mouseup.drag", null), ue(t.view, e), oe(t), c.mouse("end", t) } function y(t, n) { if (i.call(this, t, n)) { var e, r, a = t.changedTouches, u = o.call(this, t, n), c = a.length; for (e = 0; e < c; ++e)(r = b(this, u, t, n, a[e].identifier, a[e])) && (ie(t), r("start", t, a[e])) } } function v(t) { var n, e, r = t.changedTouches, i = r.length; for (n = 0; n < i; ++n)(e = c[r[n].identifier]) && (oe(t), e("drag", t, r[n])) } function _(t) { var n, e, i = t.changedTouches, o = i.length; for (r && clearTimeout(r), r = setTimeout((function() { r = null }), 500), n = 0; n < o; ++n)(e = c[i[n].identifier]) && (ie(t), e("end", t, i[n])) } function b(t, n, e, r, i, o) { var u, l, d, p = f.copy(), g = ne(o || e, n); if (null != (d = a.call(t, new fe("beforestart", { sourceEvent: e, target: h, identifier: i, active: s, x: g[0], y: g[1], dx: 0, dy: 0, dispatch: p }), r))) return u = d.x - g[0] || 0, l = d.y - g[1] || 0, function e(o, a, f) { var y, v = g; switch (o) { case "start": c[i] = e, y = s++; break; case "end": delete c[i], --s; case "drag": g = ne(f || a, n), y = s }p.call(o, t, new fe(o, { sourceEvent: a, subject: d, target: h, identifier: i, active: y, x: g[0] + u, y: g[1] + l, dx: g[0] - v[0], dy: g[1] - v[1], dispatch: p }), r) } } return h.filter = function(t) { return arguments.length ? (i = "function" == typeof t ? t : ce(!!t), h) : i }, h.container = function(t) { return arguments.length ? (o = "function" == typeof t ? t : ce(t), h) : o }, h.subject = function(t) { return arguments.length ? (a = "function" == typeof t ? t : ce(t), h) : a }, h.touchable = function(t) { return arguments.length ? (u = "function" == typeof t ? t : ce(!!t), h) : u }, h.on = function() { var t = f.on.apply(f, arguments); return t === f ? h : t }, h.clickDistance = function(t) { return arguments.length ? (l = (t = +t) * t, h) : Math.sqrt(l) }, h }, t.dragDisable = ae, t.dragEnable = ue, t.dsv = function(t, n, e, r) { 3 === arguments.length && "function" == typeof e && (r = e, e = void 0); var i = Ju(t); return mc(n, e).then((function(t) { return i.parse(t, r) })) }, t.dsvFormat = Ju, t.easeBack = Lo, t.easeBackIn = Bo, t.easeBackInOut = Lo, t.easeBackOut = Yo, t.easeBounce = Io, t.easeBounceIn = function(t) { return 1 - Io(1 - t) }, t.easeBounceInOut = function(t) { return ((t *= 2) <= 1 ? 1 - Io(1 - t) : Io(t - 1) + 1) / 2 }, t.easeBounceOut = Io, t.easeCircle = No, t.easeCircleIn = function(t) { return 1 - Math.sqrt(1 - t * t) }, t.easeCircleInOut = No, t.easeCircleOut = function(t) { return Math.sqrt(1 - --t * t) }, t.easeCubic = bo, t.easeCubicIn = function(t) { return t * t * t }, t.easeCubicInOut = bo, t.easeCubicOut = function(t) { return --t * t * t + 1 }, t.easeElastic = Xo, t.easeElasticIn = Ho, t.easeElasticInOut = Go, t.easeElasticOut = Xo, t.easeExp = Eo, t.easeExpIn = function(t) { return So(1 - +t) }, t.easeExpInOut = Eo, t.easeExpOut = function(t) { return 1 - So(t) }, t.easeLinear = t => +t, t.easePoly = wo, t.easePolyIn = mo, t.easePolyInOut = wo, t.easePolyOut = xo, t.easeQuad = _o, t.easeQuadIn = function(t) { return t * t }, t.easeQuadInOut = _o, t.easeQuadOut = function(t) { return t * (2 - t) }, t.easeSin = Ao, t.easeSinIn = function(t) { return 1 == +t ? 1 : 1 - Math.cos(t * To) }, t.easeSinInOut = Ao, t.easeSinOut = function(t) { return Math.sin(t * To) }, t.every = function(t, n) { if ("function" != typeof n) throw new TypeError("test is not a function"); let e = -1; for (const r of t) if (!n(r, ++e, t)) return !1; return !0 }, t.extent = M, t.fcumsum = function(t, n) { const e = new T; let r = -1; return Float64Array.from(t, void 0 === n ? t => e.add(+t || 0) : i => e.add(+n(i, ++r, t) || 0)) }, t.filter = function(t, n) { if ("function" != typeof n) throw new TypeError("test is not a function"); const e = []; let r = -1; for (const i of t) n(i, ++r, t) && e.push(i); return e }, t.flatGroup = function(t, ...n) { return z(P(t, ...n), n) }, t.flatRollup = function(t, n, ...e) { return z(D(t, n, ...e), e) }, t.forceCenter = function(t, n) { var e, r = 1; function i() { var i, o, a = e.length, u = 0, c = 0; for (i = 0; i < a; ++i)u += (o = e[i]).x, c += o.y; for (u = (u / a - t) * r, c = (c / a - n) * r, i = 0; i < a; ++i)(o = e[i]).x -= u, o.y -= c } return null == t && (t = 0), null == n && (n = 0), i.initialize = function(t) { e = t }, i.x = function(n) { return arguments.length ? (t = +n, i) : t }, i.y = function(t) { return arguments.length ? (n = +t, i) : n }, i.strength = function(t) { return arguments.length ? (r = +t, i) : r }, i }, t.forceCollide = function(t) { var n, e, r, i = 1, o = 1; function a() { for (var t, a, c, f, s, l, h, d = n.length, p = 0; p < o; ++p)for (a = $c(n, Ic, Oc).visitAfter(u), t = 0; t < d; ++t)c = n[t], l = e[c.index], h = l * l, f = c.x + c.vx, s = c.y + c.vy, a.visit(g); function g(t, n, e, o, a) { var u = t.data, d = t.r, p = l + d; if (!u) return n > f + p || o < f - p || e > s + p || a < s - p; if (u.index > c.index) { var g = f - u.x - u.vx, y = s - u.y - u.vy, v = g * g + y * y; v < p * p && (0 === g && (v += (g = Uc(r)) * g), 0 === y && (v += (y = Uc(r)) * y), v = (p - (v = Math.sqrt(v))) / v * i, c.vx += (g *= v) * (p = (d *= d) / (h + d)), c.vy += (y *= v) * p, u.vx -= g * (p = 1 - p), u.vy -= y * p) } } } function u(t) { if (t.data) return t.r = e[t.data.index]; for (var n = t.r = 0; n < 4; ++n)t[n] && t[n].r > t.r && (t.r = t[n].r) } function c() { if (n) { var r, i, o = n.length; for (e = new Array(o), r = 0; r < o; ++r)i = n[r], e[i.index] = +t(i, r, n) } } return "function" != typeof t && (t = qc(null == t ? 1 : +t)), a.initialize = function(t, e) { n = t, r = e, c() }, a.iterations = function(t) { return arguments.length ? (o = +t, a) : o }, a.strength = function(t) { return arguments.length ? (i = +t, a) : i }, a.radius = function(n) { return arguments.length ? (t = "function" == typeof n ? n : qc(+n), c(), a) : t }, a }, t.forceLink = function(t) { var n, e, r, i, o, a, u = Bc, c = function(t) { return 1 / Math.min(i[t.source.index], i[t.target.index]) }, f = qc(30), s = 1; function l(r) { for (var i = 0, u = t.length; i < s; ++i)for (var c, f, l, h, d, p, g, y = 0; y < u; ++y)f = (c = t[y]).source, h = (l = c.target).x + l.vx - f.x - f.vx || Uc(a), d = l.y + l.vy - f.y - f.vy || Uc(a), h *= p = ((p = Math.sqrt(h * h + d * d)) - e[y]) / p * r * n[y], d *= p, l.vx -= h * (g = o[y]), l.vy -= d * g, f.vx += h * (g = 1 - g), f.vy += d * g } function h() { if (r) { var a, c, f = r.length, s = t.length, l = new Map(r.map(((t, n) => [u(t, n, r), t]))); for (a = 0, i = new Array(f); a < s; ++a)(c = t[a]).index = a, "object" != typeof c.source && (c.source = Yc(l, c.source)), "object" != typeof c.target && (c.target = Yc(l, c.target)), i[c.source.index] = (i[c.source.index] || 0) + 1, i[c.target.index] = (i[c.target.index] || 0) + 1; for (a = 0, o = new Array(s); a < s; ++a)c = t[a], o[a] = i[c.source.index] / (i[c.source.index] + i[c.target.index]); n = new Array(s), d(), e = new Array(s), p() } } function d() { if (r) for (var e = 0, i = t.length; e < i; ++e)n[e] = +c(t[e], e, t) } function p() { if (r) for (var n = 0, i = t.length; n < i; ++n)e[n] = +f(t[n], n, t) } return null == t && (t = []), l.initialize = function(t, n) { r = t, a = n, h() }, l.links = function(n) { return arguments.length ? (t = n, h(), l) : t }, l.id = function(t) { return arguments.length ? (u = t, l) : u }, l.iterations = function(t) { return arguments.length ? (s = +t, l) : s }, l.strength = function(t) { return arguments.length ? (c = "function" == typeof t ? t : qc(+t), d(), l) : c }, l.distance = function(t) { return arguments.length ? (f = "function" == typeof t ? t : qc(+t), p(), l) : f }, l }, t.forceManyBody = function() { var t, n, e, r, i, o = qc(-30), a = 1, u = 1 / 0, c = .81; function f(e) { var i, o = t.length, a = $c(t, Xc, Gc).visitAfter(l); for (r = e, i = 0; i < o; ++i)n = t[i], a.visit(h) } function s() { if (t) { var n, e, r = t.length; for (i = new Array(r), n = 0; n < r; ++n)e = t[n], i[e.index] = +o(e, n, t) } } function l(t) { var n, e, r, o, a, u = 0, c = 0; if (t.length) { for (r = o = a = 0; a < 4; ++a)(n = t[a]) && (e = Math.abs(n.value)) && (u += n.value, c += e, r += e * n.x, o += e * n.y); t.x = r / c, t.y = o / c } else { (n = t).x = n.data.x, n.y = n.data.y; do { u += i[n.data.index] } while (n = n.next) } t.value = u } function h(t, o, f, s) { if (!t.value) return !0; var l = t.x - n.x, h = t.y - n.y, d = s - o, p = l * l + h * h; if (d * d / c < p) return p < u && (0 === l && (p += (l = Uc(e)) * l), 0 === h && (p += (h = Uc(e)) * h), p < a && (p = Math.sqrt(a * p)), n.vx += l * t.value * r / p, n.vy += h * t.value * r / p), !0; if (!(t.length || p >= u)) { (t.data !== n || t.next) && (0 === l && (p += (l = Uc(e)) * l), 0 === h && (p += (h = Uc(e)) * h), p < a && (p = Math.sqrt(a * p))); do { t.data !== n && (d = i[t.data.index] * r / p, n.vx += l * d, n.vy += h * d) } while (t = t.next) } } return f.initialize = function(n, r) { t = n, e = r, s() }, f.strength = function(t) { return arguments.length ? (o = "function" == typeof t ? t : qc(+t), s(), f) : o }, f.distanceMin = function(t) { return arguments.length ? (a = t * t, f) : Math.sqrt(a) }, f.distanceMax = function(t) { return arguments.length ? (u = t * t, f) : Math.sqrt(u) }, f.theta = function(t) { return arguments.length ? (c = t * t, f) : Math.sqrt(c) }, f }, t.forceRadial = function(t, n, e) { var r, i, o, a = qc(.1); function u(t) { for (var a = 0, u = r.length; a < u; ++a) { var c = r[a], f = c.x - n || 1e-6, s = c.y - e || 1e-6, l = Math.sqrt(f * f + s * s), h = (o[a] - l) * i[a] * t / l; c.vx += f * h, c.vy += s * h } } function c() { if (r) { var n, e = r.length; for (i = new Array(e), o = new Array(e), n = 0; n < e; ++n)o[n] = +t(r[n], n, r), i[n] = isNaN(o[n]) ? 0 : +a(r[n], n, r) } } return "function" != typeof t && (t = qc(+t)), null == n && (n = 0), null == e && (e = 0), u.initialize = function(t) { r = t, c() }, u.strength = function(t) { return arguments.length ? (a = "function" == typeof t ? t : qc(+t), c(), u) : a }, u.radius = function(n) { return arguments.length ? (t = "function" == typeof n ? n : qc(+n), c(), u) : t }, u.x = function(t) { return arguments.length ? (n = +t, u) : n }, u.y = function(t) { return arguments.length ? (e = +t, u) : e }, u }, t.forceSimulation = function(t) { var n, e = 1, r = .001, i = 1 - Math.pow(r, 1 / 300), o = 0, a = .6, u = new Map, c = Ni(l), f = $t("tick", "end"), s = function() { let t = 1; return () => (t = (Lc * t + jc) % Hc) / Hc }(); function l() { h(), f.call("tick", n), e < r && (c.stop(), f.call("end", n)) } function h(r) { var c, f, s = t.length; void 0 === r && (r = 1); for (var l = 0; l < r; ++l)for (e += (o - e) * i, u.forEach((function(t) { t(e) })), c = 0; c < s; ++c)null == (f = t[c]).fx ? f.x += f.vx *= a : (f.x = f.fx, f.vx = 0), null == f.fy ? f.y += f.vy *= a : (f.y = f.fy, f.vy = 0); return n } function d() { for (var n, e = 0, r = t.length; e < r; ++e) { if ((n = t[e]).index = e, null != n.fx && (n.x = n.fx), null != n.fy && (n.y = n.fy), isNaN(n.x) || isNaN(n.y)) { var i = 10 * Math.sqrt(.5 + e), o = e * Vc; n.x = i * Math.cos(o), n.y = i * Math.sin(o) } (isNaN(n.vx) || isNaN(n.vy)) && (n.vx = n.vy = 0) } } function p(n) { return n.initialize && n.initialize(t, s), n } return null == t && (t = []), d(), n = { tick: h, restart: function() { return c.restart(l), n }, stop: function() { return c.stop(), n }, nodes: function(e) { return arguments.length ? (t = e, d(), u.forEach(p), n) : t }, alpha: function(t) { return arguments.length ? (e = +t, n) : e }, alphaMin: function(t) { return arguments.length ? (r = +t, n) : r }, alphaDecay: function(t) { return arguments.length ? (i = +t, n) : +i }, alphaTarget: function(t) { return arguments.length ? (o = +t, n) : o }, velocityDecay: function(t) { return arguments.length ? (a = 1 - t, n) : 1 - a }, randomSource: function(t) { return arguments.length ? (s = t, u.forEach(p), n) : s }, force: function(t, e) { return arguments.length > 1 ? (null == e ? u.delete(t) : u.set(t, p(e)), n) : u.get(t) }, find: function(n, e, r) { var i, o, a, u, c, f = 0, s = t.length; for (null == r ? r = 1 / 0 : r *= r, f = 0; f < s; ++f)(a = (i = n - (u = t[f]).x) * i + (o = e - u.y) * o) < r && (c = u, r = a); return c }, on: function(t, e) { return arguments.length > 1 ? (f.on(t, e), n) : f.on(t) } } }, t.forceX = function(t) { var n, e, r, i = qc(.1); function o(t) { for (var i, o = 0, a = n.length; o < a; ++o)(i = n[o]).vx += (r[o] - i.x) * e[o] * t } function a() { if (n) { var o, a = n.length; for (e = new Array(a), r = new Array(a), o = 0; o < a; ++o)e[o] = isNaN(r[o] = +t(n[o], o, n)) ? 0 : +i(n[o], o, n) } } return "function" != typeof t && (t = qc(null == t ? 0 : +t)), o.initialize = function(t) { n = t, a() }, o.strength = function(t) { return arguments.length ? (i = "function" == typeof t ? t : qc(+t), a(), o) : i }, o.x = function(n) { return arguments.length ? (t = "function" == typeof n ? n : qc(+n), a(), o) : t }, o }, t.forceY = function(t) { var n, e, r, i = qc(.1); function o(t) { for (var i, o = 0, a = n.length; o < a; ++o)(i = n[o]).vy += (r[o] - i.y) * e[o] * t } function a() { if (n) { var o, a = n.length; for (e = new Array(a), r = new Array(a), o = 0; o < a; ++o)e[o] = isNaN(r[o] = +t(n[o], o, n)) ? 0 : +i(n[o], o, n) } } return "function" != typeof t && (t = qc(null == t ? 0 : +t)), o.initialize = function(t) { n = t, a() }, o.strength = function(t) { return arguments.length ? (i = "function" == typeof t ? t : qc(+t), a(), o) : i }, o.y = function(n) { return arguments.length ? (t = "function" == typeof n ? n : qc(+n), a(), o) : t }, o }, t.formatDefaultLocale = ff, t.formatLocale = cf, t.formatSpecifier = Jc, t.fsum = function(t, n) { const e = new T; if (void 0 === n) for (let n of t) (n = +n) && e.add(n); else { let r = -1; for (let i of t) (i = +n(i, ++r, t)) && e.add(i) } return +e }, t.geoAlbers = xd, t.geoAlbersUsa = function() { var t, n, e, r, i, o, a = xd(), u = md().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), c = md().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), f = { point: function(t, n) { o = [t, n] } }; function s(t) { var n = t[0], a = t[1]; return o = null, e.point(n, a), o || (r.point(n, a), o) || (i.point(n, a), o) } function l() { return t = n = null, s } return s.invert = function(t) { var n = a.scale(), e = a.translate(), r = (t[0] - e[0]) / n, i = (t[1] - e[1]) / n; return (i >= .12 && i < .234 && r >= -.425 && r < -.214 ? u : i >= .166 && i < .234 && r >= -.214 && r < -.115 ? c : a).invert(t) }, s.stream = function(e) { return t && n === e ? t : (r = [a.stream(n = e), u.stream(e), c.stream(e)], i = r.length, t = { point: function(t, n) { for (var e = -1; ++e < i;)r[e].point(t, n) }, sphere: function() { for (var t = -1; ++t < i;)r[t].sphere() }, lineStart: function() { for (var t = -1; ++t < i;)r[t].lineStart() }, lineEnd: function() { for (var t = -1; ++t < i;)r[t].lineEnd() }, polygonStart: function() { for (var t = -1; ++t < i;)r[t].polygonStart() }, polygonEnd: function() { for (var t = -1; ++t < i;)r[t].polygonEnd() } }); var r, i }, s.precision = function(t) { return arguments.length ? (a.precision(t), u.precision(t), c.precision(t), l()) : a.precision() }, s.scale = function(t) { return arguments.length ? (a.scale(t), u.scale(.35 * t), c.scale(t), s.translate(a.translate())) : a.scale() }, s.translate = function(t) { if (!arguments.length) return a.translate(); var n = a.scale(), o = +t[0], s = +t[1]; return e = a.translate(t).clipExtent([[o - .455 * n, s - .238 * n], [o + .455 * n, s + .238 * n]]).stream(f), r = u.translate([o - .307 * n, s + .201 * n]).clipExtent([[o - .425 * n + df, s + .12 * n + df], [o - .214 * n - df, s + .234 * n - df]]).stream(f), i = c.translate([o - .205 * n, s + .212 * n]).clipExtent([[o - .214 * n + df, s + .166 * n + df], [o - .115 * n - df, s + .234 * n - df]]).stream(f), l() }, s.fitExtent = function(t, n) { return ud(s, t, n) }, s.fitSize = function(t, n) { return cd(s, t, n) }, s.fitWidth = function(t, n) { return fd(s, t, n) }, s.fitHeight = function(t, n) { return sd(s, t, n) }, s.scale(1070) }, t.geoArea = function(t) { return us = new T, Lf(t, cs), 2 * us }, t.geoAzimuthalEqualArea = function() { return yd(Td).scale(124.75).clipAngle(179.999) }, t.geoAzimuthalEqualAreaRaw = Td, t.geoAzimuthalEquidistant = function() { return yd(Ad).scale(79.4188).clipAngle(179.999) }, t.geoAzimuthalEquidistantRaw = Ad, t.geoBounds = function(t) { var n, e, r, i, o, a, u; if (Qf = Kf = -(Wf = Zf = 1 / 0), is = [], Lf(t, Fs), e = is.length) { for (is.sort(Hs), n = 1, o = [r = is[0]]; n < e; ++n)Xs(r, (i = is[n])[0]) || Xs(r, i[1]) ? (js(r[0], i[1]) > js(r[0], r[1]) && (r[1] = i[1]), js(i[0], r[1]) > js(r[0], r[1]) && (r[0] = i[0])) : o.push(r = i); for (a = -1 / 0, n = 0, r = o[e = o.length - 1]; n <= e; r = i, ++n)i = o[n], (u = js(r[1], i[0])) > a && (a = u, Wf = i[0], Kf = r[1]) } return is = os = null, Wf === 1 / 0 || Zf === 1 / 0 ? [[NaN, NaN], [NaN, NaN]] : [[Wf, Zf], [Kf, Qf]] }, t.geoCentroid = function(t) { ms = xs = ws = Ms = Ts = As = Ss = Es = 0, Ns = new T, ks = new T, Cs = new T, Lf(t, Gs); var n = +Ns, e = +ks, r = +Cs, i = Ef(n, e, r); return i < pf && (n = As, e = Ss, r = Es, xs < df && (n = ws, e = Ms, r = Ts), (i = Ef(n, e, r)) < pf) ? [NaN, NaN] : [Mf(e, n) * bf, Rf(r / i) * bf] }, t.geoCircle = function() { var t, n, e = il([0, 0]), r = il(90), i = il(2), o = { point: function(e, r) { t.push(e = n(e, r)), e[0] *= bf, e[1] *= bf } }; function a() { var a = e.apply(this, arguments), u = r.apply(this, arguments) * mf, c = i.apply(this, arguments) * mf; return t = [], n = ul(-a[0] * mf, -a[1] * mf, 0).invert, hl(o, u, c, 1), a = { type: "Polygon", coordinates: [t] }, t = n = null, a } return a.center = function(t) { return arguments.length ? (e = "function" == typeof t ? t : il([+t[0], +t[1]]), a) : e }, a.radius = function(t) { return arguments.length ? (r = "function" == typeof t ? t : il(+t), a) : r }, a.precision = function(t) { return arguments.length ? (i = "function" == typeof t ? t : il(+t), a) : i }, a }, t.geoClipAntimeridian = Tl, t.geoClipCircle = Al, t.geoClipExtent = function() { var t, n, e, r = 0, i = 0, o = 960, a = 500; return e = { stream: function(e) { return t && n === e ? t : t = zl(r, i, o, a)(n = e) }, extent: function(u) { return arguments.length ? (r = +u[0][0], i = +u[0][1], o = +u[1][0], a = +u[1][1], t = n = null, e) : [[r, i], [o, a]] } } }, t.geoClipRectangle = zl, t.geoConicConformal = function() { return _d(kd).scale(109.5).parallels([30, 30]) }, t.geoConicConformalRaw = kd, t.geoConicEqualArea = md, t.geoConicEqualAreaRaw = bd, t.geoConicEquidistant = function() { return _d(Pd).scale(131.154).center([0, 13.9389]) }, t.geoConicEquidistantRaw = Pd, t.geoContains = function(t, n) { return (t && Bl.hasOwnProperty(t.type) ? Bl[t.type] : Ll)(t, n) }, t.geoDistance = Ol, t.geoEqualEarth = function() { return yd(qd).scale(177.158) }, t.geoEqualEarthRaw = qd, t.geoEquirectangular = function() { return yd(Cd).scale(152.63) }, t.geoEquirectangularRaw = Cd, t.geoGnomonic = function() { return yd(Ud).scale(144.049).clipAngle(60) }, t.geoGnomonicRaw = Ud, t.geoGraticule = Kl, t.geoGraticule10 = function() { return Kl()() }, t.geoIdentity = function() { var t, n, e, r, i, o, a, u = 1, c = 0, f = 0, s = 1, l = 1, h = 0, d = null, p = 1, g = 1, y = id({ point: function(t, n) { var e = b([t, n]); this.stream.point(e[0], e[1]) } }), v = eh; function _() { return p = u * s, g = u * l, o = a = null, b } function b(e) { var r = e[0] * p, i = e[1] * g; if (h) { var o = i * t - r * n; r = r * t + i * n, i = o } return [r + c, i + f] } return b.invert = function(e) { var r = e[0] - c, i = e[1] - f; if (h) { var o = i * t + r * n; r = r * t - i * n, i = o } return [r / p, i / g] }, b.stream = function(t) { return o && a === t ? o : o = y(v(a = t)) }, b.postclip = function(t) { return arguments.length ? (v = t, d = e = r = i = null, _()) : v }, b.clipExtent = function(t) { return arguments.length ? (v = null == t ? (d = e = r = i = null, eh) : zl(d = +t[0][0], e = +t[0][1], r = +t[1][0], i = +t[1][1]), _()) : null == d ? null : [[d, e], [r, i]] }, b.scale = function(t) { return arguments.length ? (u = +t, _()) : u }, b.translate = function(t) { return arguments.length ? (c = +t[0], f = +t[1], _()) : [c, f] }, b.angle = function(e) { return arguments.length ? (n = Cf(h = e % 360 * mf), t = Tf(h), _()) : h * bf }, b.reflectX = function(t) { return arguments.length ? (s = t ? -1 : 1, _()) : s < 0 }, b.reflectY = function(t) { return arguments.length ? (l = t ? -1 : 1, _()) : l < 0 }, b.fitExtent = function(t, n) { return ud(b, t, n) }, b.fitSize = function(t, n) { return cd(b, t, n) }, b.fitWidth = function(t, n) { return fd(b, t, n) }, b.fitHeight = function(t, n) { return sd(b, t, n) }, b }, t.geoInterpolate = function(t, n) { var e = t[0] * mf, r = t[1] * mf, i = n[0] * mf, o = n[1] * mf, a = Tf(r), u = Cf(r), c = Tf(o), f = Cf(o), s = a * Tf(e), l = a * Cf(e), h = c * Tf(i), d = c * Cf(i), p = 2 * Rf(zf(Ff(o - r) + a * c * Ff(i - e))), g = Cf(p), y = p ? function(t) { var n = Cf(t *= p) / g, e = Cf(p - t) / g, r = e * s + n * h, i = e * l + n * d, o = e * u + n * f; return [Mf(i, r) * bf, Mf(o, zf(r * r + i * i)) * bf] } : function() { return [e * bf, r * bf] }; return y.distance = p, y }, t.geoLength = ql, t.geoMercator = function() { return Ed(Sd).scale(961 / _f) }, t.geoMercatorRaw = Sd, t.geoNaturalEarth1 = function() { return yd(Id).scale(175.295) }, t.geoNaturalEarth1Raw = Id, t.geoOrthographic = function() { return yd(Od).scale(249.5).clipAngle(90 + df) }, t.geoOrthographicRaw = Od, t.geoPath = function(t, n) { let e, r, i = 3, o = 4.5; function a(t) { return t && ("function" == typeof o && r.pointRadius(+o.apply(this, arguments)), Lf(t, e(r))), r.result() } return a.area = function(t) { return Lf(t, e(sh)), sh.result() }, a.measure = function(t) { return Lf(t, e(Kh)), Kh.result() }, a.bounds = function(t) { return Lf(t, e(mh)), mh.result() }, a.centroid = function(t) { return Lf(t, e(Oh)), Oh.result() }, a.projection = function(n) { return arguments.length ? (e = null == n ? (t = null, eh) : (t = n).stream, a) : t }, a.context = function(t) { return arguments.length ? (r = null == t ? (n = null, new ed(i)) : new Bh(n = t), "function" != typeof o && r.pointRadius(o), a) : n }, a.pointRadius = function(t) { return arguments.length ? (o = "function" == typeof t ? t : (r.pointRadius(+t), +t), a) : o }, a.digits = function(t) { if (!arguments.length) return i; if (null == t) i = null; else { const n = Math.floor(t); if (!(n >= 0)) throw new RangeError(`invalid digits: ${t}`); i = n } return null === n && (r = new ed(i)), a }, a.projection(t).digits(i).context(n) }, t.geoProjection = yd, t.geoProjectionMutator = vd, t.geoRotation = ll, t.geoStereographic = function() { return yd(Bd).scale(250).clipAngle(142) }, t.geoStereographicRaw = Bd, t.geoStream = Lf, t.geoTransform = function(t) { return { stream: id(t) } }, t.geoTransverseMercator = function() { var t = Ed(Yd), n = t.center, e = t.rotate; return t.center = function(t) { return arguments.length ? n([-t[1], t[0]]) : [(t = n())[1], -t[0]] }, t.rotate = function(t) { return arguments.length ? e([t[0], t[1], t.length > 2 ? t[2] + 90 : 90]) : [(t = e())[0], t[1], t[2] - 90] }, e([0, 0, 90]).scale(159.155) }, t.geoTransverseMercatorRaw = Yd, t.gray = function(t, n) { return new ur(t, 0, 0, null == n ? 1 : n) }, t.greatest = ot, t.greatestIndex = function(t, e = n) { if (1 === e.length) return tt(t, e); let r, i = -1, o = -1; for (const n of t) ++o, (i < 0 ? 0 === e(n, n) : e(n, r) > 0) && (r = n, i = o); return i }, t.group = C, t.groupSort = function(t, e, r) { return (2 !== e.length ? U($(t, e, r), (([t, e], [r, i]) => n(e, i) || n(t, r))) : U(C(t, r), (([t, r], [i, o]) => e(r, o) || n(t, i)))).map((([t]) => t)) }, t.groups = P, t.hcl = dr, t.hierarchy = Gd, t.histogram = Q, t.hsl = He, t.html = Ec, t.image = function(t, n) { return new Promise((function(e, r) { var i = new Image; for (var o in n) i[o] = n[o]; i.onerror = r, i.onload = function() { e(i) }, i.src = t })) }, t.index = function(t, ...n) { return F(t, k, R, n) }, t.indexes = function(t, ...n) { return F(t, Array.from, R, n) }, t.interpolate = Gr, t.interpolateArray = function(t, n) { return (Ir(n) ? Ur : Or)(t, n) }, t.interpolateBasis = Er, t.interpolateBasisClosed = Nr, t.interpolateBlues = Gb, t.interpolateBrBG = ob, t.interpolateBuGn = Mb, t.interpolateBuPu = Ab, t.interpolateCividis = function(t) { return t = Math.max(0, Math.min(1, t)), "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - 2710.57 * t))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - 67.37 * t))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - 2475.67 * t))))))) + ")" }, t.interpolateCool = am, t.interpolateCubehelix = li, t.interpolateCubehelixDefault = im, t.interpolateCubehelixLong = hi, t.interpolateDate = Br, t.interpolateDiscrete = function(t) { var n = t.length; return function(e) { return t[Math.max(0, Math.min(n - 1, Math.floor(e * n)))] } }, t.interpolateGnBu = Eb, t.interpolateGreens = Wb, t.interpolateGreys = Kb, t.interpolateHcl = ci, t.interpolateHclLong = fi, t.interpolateHsl = oi, t.interpolateHslLong = ai, t.interpolateHue = function(t, n) { var e = Pr(+t, +n); return function(t) { var n = e(t); return n - 360 * Math.floor(n / 360) } }, t.interpolateInferno = pm, t.interpolateLab = function(t, n) { var e = $r((t = ar(t)).l, (n = ar(n)).l), r = $r(t.a, n.a), i = $r(t.b, n.b), o = $r(t.opacity, n.opacity); return function(n) { return t.l = e(n), t.a = r(n), t.b = i(n), t.opacity = o(n), t + "" } }, t.interpolateMagma = dm, t.interpolateNumber = Yr, t.interpolateNumberArray = Ur, t.interpolateObject = Lr, t.interpolateOrRd = kb, t.interpolateOranges = rm, t.interpolatePRGn = ub, t.interpolatePiYG = fb, t.interpolatePlasma = gm, t.interpolatePuBu = $b, t.interpolatePuBuGn = Pb, t.interpolatePuOr = lb, t.interpolatePuRd = Rb, t.interpolatePurples = Jb, t.interpolateRainbow = function(t) { (t < 0 || t > 1) && (t -= Math.floor(t)); var n = Math.abs(t - .5); return um.h = 360 * t - 100, um.s = 1.5 - 1.5 * n, um.l = .8 - .9 * n, um + "" }, t.interpolateRdBu = db, t.interpolateRdGy = gb, t.interpolateRdPu = qb, t.interpolateRdYlBu = vb, t.interpolateRdYlGn = bb, t.interpolateReds = nm, t.interpolateRgb = Dr, t.interpolateRgbBasis = Fr, t.interpolateRgbBasisClosed = qr, t.interpolateRound = Vr, t.interpolateSinebow = function(t) { var n; return t = (.5 - t) * Math.PI, cm.r = 255 * (n = Math.sin(t)) * n, cm.g = 255 * (n = Math.sin(t + fm)) * n, cm.b = 255 * (n = Math.sin(t + sm)) * n, cm + "" }, t.interpolateSpectral = xb, t.interpolateString = Xr, t.interpolateTransformCss = ti, t.interpolateTransformSvg = ni, t.interpolateTurbo = function(t) { return t = Math.max(0, Math.min(1, t)), "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - 14825.05 * t))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + 707.56 * t))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - 6838.66 * t))))))) + ")" }, t.interpolateViridis = hm, t.interpolateWarm = om, t.interpolateYlGn = Bb, t.interpolateYlGnBu = Ib, t.interpolateYlOrBr = Lb, t.interpolateYlOrRd = Hb, t.interpolateZoom = ri, t.interrupt = Gi, t.intersection = function(t, ...n) { t = new InternSet(t), n = n.map(vt); t: for (const e of t) for (const r of n) if (!r.has(e)) { t.delete(e); continue t } return t }, t.interval = function(t, n, e) { var r = new Ei, i = n; return null == n ? (r.restart(t, n, e), r) : (r._restart = r.restart, r.restart = function(t, n, e) { n = +n, e = null == e ? Ai() : +e, r._restart((function o(a) { a += i, r._restart(o, i += n, e), t(a) }), n, e) }, r.restart(t, n, e), r) }, t.isoFormat = D_, t.isoParse = F_, t.json = function(t, n) { return fetch(t, n).then(Tc) }, t.lab = ar, t.lch = function(t, n, e, r) { return 1 === arguments.length ? hr(t) : new pr(e, n, t, null == r ? 1 : r) }, t.least = function(t, e = n) { let r, i = !1; if (1 === e.length) { let o; for (const a of t) { const t = e(a); (i ? n(t, o) < 0 : 0 === n(t, t)) && (r = a, o = t, i = !0) } } else for (const n of t) (i ? e(n, r) < 0 : 0 === e(n, n)) && (r = n, i = !0); return r }, t.leastIndex = ht, t.line = Ym, t.lineRadial = Zm, t.link = ax, t.linkHorizontal = function() { return ax(nx) }, t.linkRadial = function() { const t = ax(rx); return t.angle = t.x, delete t.x, t.radius = t.y, delete t.y, t }, t.linkVertical = function() { return ax(ex) }, t.local = Qn, t.map = function(t, n) { if ("function" != typeof t[Symbol.iterator]) throw new TypeError("values is not iterable"); if ("function" != typeof n) throw new TypeError("mapper is not a function"); return Array.from(t, ((e, r) => n(e, r, t))) }, t.matcher = Vt, t.max = J, t.maxIndex = tt, t.mean = function(t, n) { let e = 0, r = 0; if (void 0 === n) for (let n of t) null != n && (n = +n) >= n && (++e, r += n); else { let i = -1; for (let o of t) null != (o = n(o, ++i, t)) && (o = +o) >= o && (++e, r += o) } if (e) return r / e }, t.median = function(t, n) { return at(t, .5, n) }, t.medianIndex = function(t, n) { return ct(t, .5, n) }, t.merge = ft, t.min = nt, t.minIndex = et, t.mode = function(t, n) { const e = new InternMap; if (void 0 === n) for (let n of t) null != n && n >= n && e.set(n, (e.get(n) || 0) + 1); else { let r = -1; for (let i of t) null != (i = n(i, ++r, t)) && i >= i && e.set(i, (e.get(i) || 0) + 1) } let r, i = 0; for (const [t, n] of e) n > i && (i = n, r = t); return r }, t.namespace = It, t.namespaces = Ut, t.nice = Z, t.now = Ai, t.pack = function() { var t = null, n = 1, e = 1, r = np; function i(i) { const o = ap(); return i.x = n / 2, i.y = e / 2, t ? i.eachBefore(xp(t)).eachAfter(wp(r, .5, o)).eachBefore(Mp(1)) : i.eachBefore(xp(mp)).eachAfter(wp(np, 1, o)).eachAfter(wp(r, i.r / Math.min(n, e), o)).eachBefore(Mp(Math.min(n, e) / (2 * i.r))), i } return i.radius = function(n) { return arguments.length ? (t = Jd(n), i) : t }, i.size = function(t) { return arguments.length ? (n = +t[0], e = +t[1], i) : [n, e] }, i.padding = function(t) { return arguments.length ? (r = "function" == typeof t ? t : ep(+t), i) : r }, i }, t.packEnclose = function(t) { return up(t, ap()) }, t.packSiblings = function(t) { return bp(t, ap()), t }, t.pairs = function(t, n = st) { const e = []; let r, i = !1; for (const o of t) i && e.push(n(r, o)), r = o, i = !0; return e }, t.partition = function() { var t = 1, n = 1, e = 0, r = !1; function i(i) { var o = i.height + 1; return i.x0 = i.y0 = e, i.x1 = t, i.y1 = n / o, i.eachBefore(function(t, n) { return function(r) { r.children && Ap(r, r.x0, t * (r.depth + 1) / n, r.x1, t * (r.depth + 2) / n); var i = r.x0, o = r.y0, a = r.x1 - e, u = r.y1 - e; a < i && (i = a = (i + a) / 2), u < o && (o = u = (o + u) / 2), r.x0 = i, r.y0 = o, r.x1 = a, r.y1 = u } }(n, o)), r && i.eachBefore(Tp), i } return i.round = function(t) { return arguments.length ? (r = !!t, i) : r }, i.size = function(e) { return arguments.length ? (t = +e[0], n = +e[1], i) : [t, n] }, i.padding = function(t) { return arguments.length ? (e = +t, i) : e }, i }, t.path = Ia, t.pathRound = function(t = 3) { return new Ua(+t) }, t.permute = q, t.pie = function() { var t = Hm, n = jm, e = null, r = ym(0), i = ym(Em), o = ym(0); function a(a) { var u, c, f, s, l, h = (a = qm(a)).length, d = 0, p = new Array(h), g = new Array(h), y = +r.apply(this, arguments), v = Math.min(Em, Math.max(-Em, i.apply(this, arguments) - y)), _ = Math.min(Math.abs(v) / h, o.apply(this, arguments)), b = _ * (v < 0 ? -1 : 1); for (u = 0; u < h; ++u)(l = g[p[u] = u] = +t(a[u], u, a)) > 0 && (d += l); for (null != n ? p.sort((function(t, e) { return n(g[t], g[e]) })) : null != e && p.sort((function(t, n) { return e(a[t], a[n]) })), u = 0, f = d ? (v - h * b) / d : 0; u < h; ++u, y = s)c = p[u], s = y + ((l = g[c]) > 0 ? l * f : 0) + b, g[c] = { data: a[c], index: u, value: l, startAngle: y, endAngle: s, padAngle: _ }; return g } return a.value = function(n) { return arguments.length ? (t = "function" == typeof n ? n : ym(+n), a) : t }, a.sortValues = function(t) { return arguments.length ? (n = t, e = null, a) : n }, a.sort = function(t) { return arguments.length ? (e = t, n = null, a) : e }, a.startAngle = function(t) { return arguments.length ? (r = "function" == typeof t ? t : ym(+t), a) : r }, a.endAngle = function(t) { return arguments.length ? (i = "function" == typeof t ? t : ym(+t), a) : i }, a.padAngle = function(t) { return arguments.length ? (o = "function" == typeof t ? t : ym(+t), a) : o }, a }, t.piecewise = di, t.pointRadial = Qm, t.pointer = ne, t.pointers = function(t, n) { return t.target && (t = te(t), void 0 === n && (n = t.currentTarget), t = t.touches || [t]), Array.from(t, (t => ne(t, n))) }, t.polygonArea = function(t) { for (var n, e = -1, r = t.length, i = t[r - 1], o = 0; ++e < r;)n = i, i = t[e], o += n[1] * i[0] - n[0] * i[1]; return o / 2 }, t.polygonCentroid = function(t) { for (var n, e, r = -1, i = t.length, o = 0, a = 0, u = t[i - 1], c = 0; ++r < i;)n = u, u = t[r], c += e = n[0] * u[1] - u[0] * n[1], o += (n[0] + u[0]) * e, a += (n[1] + u[1]) * e; return [o / (c *= 3), a / c] }, t.polygonContains = function(t, n) { for (var e, r, i = t.length, o = t[i - 1], a = n[0], u = n[1], c = o[0], f = o[1], s = !1, l = 0; l < i; ++l)e = (o = t[l])[0], (r = o[1]) > u != f > u && a < (c - e) * (u - r) / (f - r) + e && (s = !s), c = e, f = r; return s }, t.polygonHull = function(t) { if ((e = t.length) < 3) return null; var n, e, r = new Array(e), i = new Array(e); for (n = 0; n < e; ++n)r[n] = [+t[n][0], +t[n][1], n]; for (r.sort(Hp), n = 0; n < e; ++n)i[n] = [r[n][0], -r[n][1]]; var o = Xp(r), a = Xp(i), u = a[0] === o[0], c = a[a.length - 1] === o[o.length - 1], f = []; for (n = o.length - 1; n >= 0; --n)f.push(t[r[o[n]][2]]); for (n = +u; n < a.length - c; ++n)f.push(t[r[a[n]][2]]); return f }, t.polygonLength = function(t) { for (var n, e, r = -1, i = t.length, o = t[i - 1], a = o[0], u = o[1], c = 0; ++r < i;)n = a, e = u, n -= a = (o = t[r])[0], e -= u = o[1], c += Math.hypot(n, e); return c }, t.precisionFixed = sf, t.precisionPrefix = lf, t.precisionRound = hf, t.quadtree = $c, t.quantile = at, t.quantileIndex = ct, t.quantileSorted = ut, t.quantize = function(t, n) { for (var e = new Array(n), r = 0; r < n; ++r)e[r] = t(r / (n - 1)); return e }, t.quickselect = rt, t.radialArea = Km, t.radialLine = Zm, t.randomBates = Jp, t.randomBernoulli = eg, t.randomBeta = og, t.randomBinomial = ag, t.randomCauchy = cg, t.randomExponential = tg, t.randomGamma = ig, t.randomGeometric = rg, t.randomInt = Wp, t.randomIrwinHall = Qp, t.randomLcg = function(t = Math.random()) { let n = 0 | (0 <= t && t < 1 ? t / lg : Math.abs(t)); return () => (n = 1664525 * n + 1013904223 | 0, lg * (n >>> 0)) }, t.randomLogNormal = Kp, t.randomLogistic = fg, t.randomNormal = Zp, t.randomPareto = ng, t.randomPoisson = sg, t.randomUniform = Vp, t.randomWeibull = ug, t.range = lt, t.rank = function(t, e = n) { if ("function" != typeof t[Symbol.iterator]) throw new TypeError("values is not iterable"); let r = Array.from(t); const i = new Float64Array(r.length); 2 !== e.length && (r = r.map(e), e = n); const o = (t, n) => e(r[t], r[n]); let a, u; return (t = Uint32Array.from(r, ((t, n) => n))).sort(e === n ? (t, n) => O(r[t], r[n]) : I(o)), t.forEach(((t, n) => { const e = o(t, void 0 === a ? t : a); e >= 0 ? ((void 0 === a || e > 0) && (a = t, u = n), i[t] = u) : i[t] = NaN })), i }, t.reduce = function(t, n, e) { if ("function" != typeof n) throw new TypeError("reducer is not a function"); const r = t[Symbol.iterator](); let i, o, a = -1; if (arguments.length < 3) { if (({ done: i, value: e } = r.next()), i) return; ++a } for (; ({ done: i, value: o } = r.next()), !i;)e = n(e, o, ++a, t); return e }, t.reverse = function(t) { if ("function" != typeof t[Symbol.iterator]) throw new TypeError("values is not iterable"); return Array.from(t).reverse() }, t.rgb = Fe, t.ribbon = function() { return Wa() }, t.ribbonArrow = function() { return Wa(Va) }, t.rollup = $, t.rollups = D, t.scaleBand = yg, t.scaleDiverging = function t() { var n = Ng(L_()(mg)); return n.copy = function() { return B_(n, t()) }, dg.apply(n, arguments) }, t.scaleDivergingLog = function t() { var n = Fg(L_()).domain([.1, 1, 10]); return n.copy = function() { return B_(n, t()).base(n.base()) }, dg.apply(n, arguments) }, t.scaleDivergingPow = j_, t.scaleDivergingSqrt = function() { return j_.apply(null, arguments).exponent(.5) }, t.scaleDivergingSymlog = function t() { var n = Ig(L_()); return n.copy = function() { return B_(n, t()).constant(n.constant()) }, dg.apply(n, arguments) }, t.scaleIdentity = function t(n) { var e; function r(t) { return null == t || isNaN(t = +t) ? e : t } return r.invert = r, r.domain = r.range = function(t) { return arguments.length ? (n = Array.from(t, _g), r) : n.slice() }, r.unknown = function(t) { return arguments.length ? (e = t, r) : e }, r.copy = function() { return t(n).unknown(e) }, n = arguments.length ? Array.from(n, _g) : [0, 1], Ng(r) }, t.scaleImplicit = pg, t.scaleLinear = function t() { var n = Sg(); return n.copy = function() { return Tg(n, t()) }, hg.apply(n, arguments), Ng(n) }, t.scaleLog = function t() { const n = Fg(Ag()).domain([1, 10]); return n.copy = () => Tg(n, t()).base(n.base()), hg.apply(n, arguments), n }, t.scaleOrdinal = gg, t.scalePoint = function() { return vg(yg.apply(null, arguments).paddingInner(1)) }, t.scalePow = jg, t.scaleQuantile = function t() { var e, r = [], i = [], o = []; function a() { var t = 0, n = Math.max(1, i.length); for (o = new Array(n - 1); ++t < n;)o[t - 1] = ut(r, t / n); return u } function u(t) { return null == t || isNaN(t = +t) ? e : i[s(o, t)] } return u.invertExtent = function(t) { var n = i.indexOf(t); return n < 0 ? [NaN, NaN] : [n > 0 ? o[n - 1] : r[0], n < o.length ? o[n] : r[r.length - 1]] }, u.domain = function(t) { if (!arguments.length) return r.slice(); r = []; for (let n of t) null == n || isNaN(n = +n) || r.push(n); return r.sort(n), a() }, u.range = function(t) { return arguments.length ? (i = Array.from(t), a()) : i.slice() }, u.unknown = function(t) { return arguments.length ? (e = t, u) : e }, u.quantiles = function() { return o.slice() }, u.copy = function() { return t().domain(r).range(i).unknown(e) }, hg.apply(u, arguments) }, t.scaleQuantize = function t() { var n, e = 0, r = 1, i = 1, o = [.5], a = [0, 1]; function u(t) { return null != t && t <= t ? a[s(o, t, 0, i)] : n } function c() { var t = -1; for (o = new Array(i); ++t < i;)o[t] = ((t + 1) * r - (t - i) * e) / (i + 1); return u } return u.domain = function(t) { return arguments.length ? ([e, r] = t, e = +e, r = +r, c()) : [e, r] }, u.range = function(t) { return arguments.length ? (i = (a = Array.from(t)).length - 1, c()) : a.slice() }, u.invertExtent = function(t) { var n = a.indexOf(t); return n < 0 ? [NaN, NaN] : n < 1 ? [e, o[0]] : n >= i ? [o[i - 1], r] : [o[n - 1], o[n]] }, u.unknown = function(t) { return arguments.length ? (n = t, u) : u }, u.thresholds = function() { return o.slice() }, u.copy = function() { return t().domain([e, r]).range(a).unknown(n) }, hg.apply(Ng(u), arguments) }, t.scaleRadial = function t() { var n, e = Sg(), r = [0, 1], i = !1; function o(t) { var r = function(t) { return Math.sign(t) * Math.sqrt(Math.abs(t)) }(e(t)); return isNaN(r) ? n : i ? Math.round(r) : r } return o.invert = function(t) { return e.invert(Hg(t)) }, o.domain = function(t) { return arguments.length ? (e.domain(t), o) : e.domain() }, o.range = function(t) { return arguments.length ? (e.range((r = Array.from(t, _g)).map(Hg)), o) : r.slice() }, o.rangeRound = function(t) { return o.range(t).round(!0) }, o.round = function(t) { return arguments.length ? (i = !!t, o) : i }, o.clamp = function(t) { return arguments.length ? (e.clamp(t), o) : e.clamp() }, o.unknown = function(t) { return arguments.length ? (n = t, o) : n }, o.copy = function() { return t(e.domain(), r).round(i).clamp(e.clamp()).unknown(n) }, hg.apply(o, arguments), Ng(o) }, t.scaleSequential = function t() { var n = Ng(O_()(mg)); return n.copy = function() { return B_(n, t()) }, dg.apply(n, arguments) }, t.scaleSequentialLog = function t() { var n = Fg(O_()).domain([1, 10]); return n.copy = function() { return B_(n, t()).base(n.base()) }, dg.apply(n, arguments) }, t.scaleSequentialPow = Y_, t.scaleSequentialQuantile = function t() { var e = [], r = mg; function i(t) { if (null != t && !isNaN(t = +t)) return r((s(e, t, 1) - 1) / (e.length - 1)) } return i.domain = function(t) { if (!arguments.length) return e.slice(); e = []; for (let n of t) null == n || isNaN(n = +n) || e.push(n); return e.sort(n), i }, i.interpolator = function(t) { return arguments.length ? (r = t, i) : r }, i.range = function() { return e.map(((t, n) => r(n / (e.length - 1)))) }, i.quantiles = function(t) { return Array.from({ length: t + 1 }, ((n, r) => at(e, r / t))) }, i.copy = function() { return t(r).domain(e) }, dg.apply(i, arguments) }, t.scaleSequentialSqrt = function() { return Y_.apply(null, arguments).exponent(.5) }, t.scaleSequentialSymlog = function t() { var n = Ig(O_()); return n.copy = function() { return B_(n, t()).constant(n.constant()) }, dg.apply(n, arguments) }, t.scaleSqrt = function() { return jg.apply(null, arguments).exponent(.5) }, t.scaleSymlog = function t() { var n = Ig(Ag()); return n.copy = function() { return Tg(n, t()).constant(n.constant()) }, hg.apply(n, arguments) }, t.scaleThreshold = function t() { var n, e = [.5], r = [0, 1], i = 1; function o(t) { return null != t && t <= t ? r[s(e, t, 0, i)] : n } return o.domain = function(t) { return arguments.length ? (e = Array.from(t), i = Math.min(e.length, r.length - 1), o) : e.slice() }, o.range = function(t) { return arguments.length ? (r = Array.from(t), i = Math.min(e.length, r.length - 1), o) : r.slice() }, o.invertExtent = function(t) { var n = r.indexOf(t); return [e[n - 1], e[n]] }, o.unknown = function(t) { return arguments.length ? (n = t, o) : n }, o.copy = function() { return t().domain(e).range(r).unknown(n) }, hg.apply(o, arguments) }, t.scaleTime = function() { return hg.apply(I_(uv, cv, tv, Zy, xy, py, sy, ay, iy, t.timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments) }, t.scaleUtc = function() { return hg.apply(I_(ov, av, ev, Qy, Fy, yy, hy, cy, iy, t.utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments) }, t.scan = function(t, n) { const e = ht(t, n); return e < 0 ? void 0 : e }, t.schemeAccent = G_, t.schemeBlues = Xb, t.schemeBrBG = ib, t.schemeBuGn = wb, t.schemeBuPu = Tb, t.schemeCategory10 = X_, t.schemeDark2 = V_, t.schemeGnBu = Sb, t.schemeGreens = Vb, t.schemeGreys = Zb, t.schemeObservable10 = W_, t.schemeOrRd = Nb, t.schemeOranges = em, t.schemePRGn = ab, t.schemePaired = Z_, t.schemePastel1 = K_, t.schemePastel2 = Q_, t.schemePiYG = cb, t.schemePuBu = zb, t.schemePuBuGn = Cb, t.schemePuOr = sb, t.schemePuRd = Db, t.schemePurples = Qb, t.schemeRdBu = hb, t.schemeRdGy = pb, t.schemeRdPu = Fb, t.schemeRdYlBu = yb, t.schemeRdYlGn = _b, t.schemeReds = tm, t.schemeSet1 = J_, t.schemeSet2 = tb, t.schemeSet3 = nb, t.schemeSpectral = mb, t.schemeTableau10 = eb, t.schemeYlGn = Ob, t.schemeYlGnBu = Ub, t.schemeYlOrBr = Yb, t.schemeYlOrRd = jb, t.select = Zn, t.selectAll = function(t) { return "string" == typeof t ? new Vn([document.querySelectorAll(t)], [document.documentElement]) : new Vn([Ht(t)], Gn) }, t.selection = Wn, t.selector = jt, t.selectorAll = Gt, t.shuffle = dt, t.shuffler = pt, t.some = function(t, n) { if ("function" != typeof n) throw new TypeError("test is not a function"); let e = -1; for (const r of t) if (n(r, ++e, t)) return !0; return !1 }, t.sort = U, t.stack = function() { var t = ym([]), n = dw, e = hw, r = pw; function i(i) { var o, a, u = Array.from(t.apply(this, arguments), gw), c = u.length, f = -1; for (const t of i) for (o = 0, ++f; o < c; ++o)(u[o][f] = [0, +r(t, u[o].key, f, i)]).data = t; for (o = 0, a = qm(n(u)); o < c; ++o)u[a[o]].index = o; return e(u, a), u } return i.keys = function(n) { return arguments.length ? (t = "function" == typeof n ? n : ym(Array.from(n)), i) : t }, i.value = function(t) { return arguments.length ? (r = "function" == typeof t ? t : ym(+t), i) : r }, i.order = function(t) { return arguments.length ? (n = null == t ? dw : "function" == typeof t ? t : ym(Array.from(t)), i) : n }, i.offset = function(t) { return arguments.length ? (e = null == t ? hw : t, i) : e }, i }, t.stackOffsetDiverging = function(t, n) { if ((u = t.length) > 0) for (var e, r, i, o, a, u, c = 0, f = t[n[0]].length; c < f; ++c)for (o = a = 0, e = 0; e < u; ++e)(i = (r = t[n[e]][c])[1] - r[0]) > 0 ? (r[0] = o, r[1] = o += i) : i < 0 ? (r[1] = a, r[0] = a += i) : (r[0] = 0, r[1] = i) }, t.stackOffsetExpand = function(t, n) { if ((r = t.length) > 0) { for (var e, r, i, o = 0, a = t[0].length; o < a; ++o) { for (i = e = 0; e < r; ++e)i += t[e][o][1] || 0; if (i) for (e = 0; e < r; ++e)t[e][o][1] /= i } hw(t, n) } }, t.stackOffsetNone = hw, t.stackOffsetSilhouette = function(t, n) { if ((e = t.length) > 0) { for (var e, r = 0, i = t[n[0]], o = i.length; r < o; ++r) { for (var a = 0, u = 0; a < e; ++a)u += t[a][r][1] || 0; i[r][1] += i[r][0] = -u / 2 } hw(t, n) } }, t.stackOffsetWiggle = function(t, n) { if ((i = t.length) > 0 && (r = (e = t[n[0]]).length) > 0) { for (var e, r, i, o = 0, a = 1; a < r; ++a) { for (var u = 0, c = 0, f = 0; u < i; ++u) { for (var s = t[n[u]], l = s[a][1] || 0, h = (l - (s[a - 1][1] || 0)) / 2, d = 0; d < u; ++d) { var p = t[n[d]]; h += (p[a][1] || 0) - (p[a - 1][1] || 0) } c += l, f += h * l } e[a - 1][1] += e[a - 1][0] = o, c && (o -= f / c) } e[a - 1][1] += e[a - 1][0] = o, hw(t, n) } }, t.stackOrderAppearance = yw, t.stackOrderAscending = _w, t.stackOrderDescending = function(t) { return _w(t).reverse() }, t.stackOrderInsideOut = function(t) { var n, e, r = t.length, i = t.map(bw), o = yw(t), a = 0, u = 0, c = [], f = []; for (n = 0; n < r; ++n)e = o[n], a < u ? (a += i[e], c.push(e)) : (u += i[e], f.push(e)); return f.reverse().concat(c) }, t.stackOrderNone = dw, t.stackOrderReverse = function(t) { return dw(t).reverse() }, t.stratify = function() { var t, n = kp, e = Cp; function r(r) { var i, o, a, u, c, f, s, l, h = Array.from(r), d = n, p = e, g = new Map; if (null != t) { const n = h.map(((n, e) => function(t) { t = `${t}`; let n = t.length; zp(t, n - 1) && !zp(t, n - 2) && (t = t.slice(0, -1)); return "/" === t[0] ? t : `/${t}` }(t(n, e, r)))), e = n.map(Pp), i = new Set(n).add(""); for (const t of e) i.has(t) || (i.add(t), n.push(t), e.push(Pp(t)), h.push(Np)); d = (t, e) => n[e], p = (t, n) => e[n] } for (a = 0, i = h.length; a < i; ++a)o = h[a], f = h[a] = new Qd(o), null != (s = d(o, a, r)) && (s += "") && (l = f.id = s, g.set(l, g.has(l) ? Ep : f)), null != (s = p(o, a, r)) && (s += "") && (f.parent = s); for (a = 0; a < i; ++a)if (s = (f = h[a]).parent) { if (!(c = g.get(s))) throw new Error("missing: " + s); if (c === Ep) throw new Error("ambiguous: " + s); c.children ? c.children.push(f) : c.children = [f], f.parent = c } else { if (u) throw new Error("multiple roots"); u = f } if (!u) throw new Error("no root"); if (null != t) { for (; u.data === Np && 1 === u.children.length;)u = u.children[0], --i; for (let t = h.length - 1; t >= 0 && (f = h[t]).data === Np; --t)f.data = null } if (u.parent = Sp, u.eachBefore((function(t) { t.depth = t.parent.depth + 1, --i })).eachBefore(Kd), u.parent = null, i > 0) throw new Error("cycle"); return u } return r.id = function(t) { return arguments.length ? (n = Jd(t), r) : n }, r.parentId = function(t) { return arguments.length ? (e = Jd(t), r) : e }, r.path = function(n) { return arguments.length ? (t = Jd(n), r) : t }, r }, t.style = _n, t.subset = function(t, n) { return _t(n, t) }, t.sum = function(t, n) { let e = 0; if (void 0 === n) for (let n of t) (n = +n) && (e += n); else { let r = -1; for (let i of t) (i = +n(i, ++r, t)) && (e += i) } return e }, t.superset = _t, t.svg = Nc, t.symbol = function(t, n) { let e = null, r = km(i); function i() { let i; if (e || (e = i = r()), t.apply(this, arguments).draw(e, +n.apply(this, arguments)), i) return e = null, i + "" || null } return t = "function" == typeof t ? t : ym(t || fx), n = "function" == typeof n ? n : ym(void 0 === n ? 64 : +n), i.type = function(n) { return arguments.length ? (t = "function" == typeof n ? n : ym(n), i) : t }, i.size = function(t) { return arguments.length ? (n = "function" == typeof t ? t : ym(+t), i) : n }, i.context = function(t) { return arguments.length ? (e = null == t ? null : t, i) : e }, i }, t.symbolAsterisk = cx, t.symbolCircle = fx, t.symbolCross = sx, t.symbolDiamond = dx, t.symbolDiamond2 = px, t.symbolPlus = gx, t.symbolSquare = yx, t.symbolSquare2 = vx, t.symbolStar = xx, t.symbolTimes = Px, t.symbolTriangle = Mx, t.symbolTriangle2 = Ax, t.symbolWye = Cx, t.symbolX = Px, t.symbols = zx, t.symbolsFill = zx, t.symbolsStroke = $x, t.text = mc, t.thresholdFreedmanDiaconis = function(t, n, e) { const r = v(t), i = at(t, .75) - at(t, .25); return r && i ? Math.ceil((e - n) / (2 * i * Math.pow(r, -1 / 3))) : 1 }, t.thresholdScott = function(t, n, e) { const r = v(t), i = w(t); return r && i ? Math.ceil((e - n) * Math.cbrt(r) / (3.49 * i)) : 1 }, t.thresholdSturges = K, t.tickFormat = Eg, t.tickIncrement = V, t.tickStep = W, t.ticks = G, t.timeDay = py, t.timeDays = gy, t.timeFormatDefaultLocale = P_, t.timeFormatLocale = hv, t.timeFriday = Sy, t.timeFridays = $y, t.timeHour = sy, t.timeHours = ly, t.timeInterval = Vg, t.timeMillisecond = Wg, t.timeMilliseconds = Zg, t.timeMinute = ay, t.timeMinutes = uy, t.timeMonday = wy, t.timeMondays = ky, t.timeMonth = Zy, t.timeMonths = Ky, t.timeSaturday = Ey, t.timeSaturdays = Dy, t.timeSecond = iy, t.timeSeconds = oy, t.timeSunday = xy, t.timeSundays = Ny, t.timeThursday = Ay, t.timeThursdays = zy, t.timeTickInterval = cv, t.timeTicks = uv, t.timeTuesday = My, t.timeTuesdays = Cy, t.timeWednesday = Ty, t.timeWednesdays = Py, t.timeWeek = xy, t.timeWeeks = Ny, t.timeYear = tv, t.timeYears = nv, t.timeout = $i, t.timer = Ni, t.timerFlush = ki, t.transition = go, t.transpose = gt, t.tree = function() { var t = $p, n = 1, e = 1, r = null; function i(i) { var c = function(t) { for (var n, e, r, i, o, a = new Up(t, 0), u = [a]; n = u.pop();)if (r = n._.children) for (n.children = new Array(o = r.length), i = o - 1; i >= 0; --i)u.push(e = n.children[i] = new Up(r[i], i)), e.parent = n; return (a.parent = new Up(null, 0)).children = [a], a }(i); if (c.eachAfter(o), c.parent.m = -c.z, c.eachBefore(a), r) i.eachBefore(u); else { var f = i, s = i, l = i; i.eachBefore((function(t) { t.x < f.x && (f = t), t.x > s.x && (s = t), t.depth > l.depth && (l = t) })); var h = f === s ? 1 : t(f, s) / 2, d = h - f.x, p = n / (s.x + h + d), g = e / (l.depth || 1); i.eachBefore((function(t) { t.x = (t.x + d) * p, t.y = t.depth * g })) } return i } function o(n) { var e = n.children, r = n.parent.children, i = n.i ? r[n.i - 1] : null; if (e) { !function(t) { for (var n, e = 0, r = 0, i = t.children, o = i.length; --o >= 0;)(n = i[o]).z += e, n.m += e, e += n.s + (r += n.c) }(n); var o = (e[0].z + e[e.length - 1].z) / 2; i ? (n.z = i.z + t(n._, i._), n.m = n.z - o) : n.z = o } else i && (n.z = i.z + t(n._, i._)); n.parent.A = function(n, e, r) { if (e) { for (var i, o = n, a = n, u = e, c = o.parent.children[0], f = o.m, s = a.m, l = u.m, h = c.m; u = Rp(u), o = Dp(o), u && o;)c = Dp(c), (a = Rp(a)).a = n, (i = u.z + l - o.z - f + t(u._, o._)) > 0 && (Fp(qp(u, n, r), n, i), f += i, s += i), l += u.m, f += o.m, h += c.m, s += a.m; u && !Rp(a) && (a.t = u, a.m += l - s), o && !Dp(c) && (c.t = o, c.m += f - h, r = n) } return r }(n, i, n.parent.A || r[0]) } function a(t) { t._.x = t.z + t.parent.m, t.m += t.parent.m } function u(t) { t.x *= n, t.y = t.depth * e } return i.separation = function(n) { return arguments.length ? (t = n, i) : t }, i.size = function(t) { return arguments.length ? (r = !1, n = +t[0], e = +t[1], i) : r ? null : [n, e] }, i.nodeSize = function(t) { return arguments.length ? (r = !0, n = +t[0], e = +t[1], i) : r ? [n, e] : null }, i }, t.treemap = function() { var t = Yp, n = !1, e = 1, r = 1, i = [0], o = np, a = np, u = np, c = np, f = np; function s(t) { return t.x0 = t.y0 = 0, t.x1 = e, t.y1 = r, t.eachBefore(l), i = [0], n && t.eachBefore(Tp), t } function l(n) { var e = i[n.depth], r = n.x0 + e, s = n.y0 + e, l = n.x1 - e, h = n.y1 - e; l < r && (r = l = (r + l) / 2), h < s && (s = h = (s + h) / 2), n.x0 = r, n.y0 = s, n.x1 = l, n.y1 = h, n.children && (e = i[n.depth + 1] = o(n) / 2, r += f(n) - e, s += a(n) - e, (l -= u(n) - e) < r && (r = l = (r + l) / 2), (h -= c(n) - e) < s && (s = h = (s + h) / 2), t(n, r, s, l, h)) } return s.round = function(t) { return arguments.length ? (n = !!t, s) : n }, s.size = function(t) { return arguments.length ? (e = +t[0], r = +t[1], s) : [e, r] }, s.tile = function(n) { return arguments.length ? (t = tp(n), s) : t }, s.padding = function(t) { return arguments.length ? s.paddingInner(t).paddingOuter(t) : s.paddingInner() }, s.paddingInner = function(t) { return arguments.length ? (o = "function" == typeof t ? t : ep(+t), s) : o }, s.paddingOuter = function(t) { return arguments.length ? s.paddingTop(t).paddingRight(t).paddingBottom(t).paddingLeft(t) : s.paddingTop() }, s.paddingTop = function(t) { return arguments.length ? (a = "function" == typeof t ? t : ep(+t), s) : a }, s.paddingRight = function(t) { return arguments.length ? (u = "function" == typeof t ? t : ep(+t), s) : u }, s.paddingBottom = function(t) { return arguments.length ? (c = "function" == typeof t ? t : ep(+t), s) : c }, s.paddingLeft = function(t) { return arguments.length ? (f = "function" == typeof t ? t : ep(+t), s) : f }, s }, t.treemapBinary = function(t, n, e, r, i) { var o, a, u = t.children, c = u.length, f = new Array(c + 1); for (f[0] = a = o = 0; o < c; ++o)f[o + 1] = a += u[o].value; !function t(n, e, r, i, o, a, c) { if (n >= e - 1) { var s = u[n]; return s.x0 = i, s.y0 = o, s.x1 = a, void (s.y1 = c) } var l = f[n], h = r / 2 + l, d = n + 1, p = e - 1; for (; d < p;) { var g = d + p >>> 1; f[g] < h ? d = g + 1 : p = g } h - f[d - 1] < f[d] - h && n + 1 < d && --d; var y = f[d] - l, v = r - y; if (a - i > c - o) { var _ = r ? (i * v + a * y) / r : a; t(n, d, y, i, o, _, c), t(d, e, v, _, o, a, c) } else { var b = r ? (o * v + c * y) / r : c; t(n, d, y, i, o, a, b), t(d, e, v, i, b, a, c) } }(0, c, t.value, n, e, r, i) }, t.treemapDice = Ap, t.treemapResquarify = Lp, t.treemapSlice = Ip, t.treemapSliceDice = function(t, n, e, r, i) { (1 & t.depth ? Ip : Ap)(t, n, e, r, i) }, t.treemapSquarify = Yp, t.tsv = Mc, t.tsvFormat = lc, t.tsvFormatBody = hc, t.tsvFormatRow = pc, t.tsvFormatRows = dc, t.tsvFormatValue = gc, t.tsvParse = fc, t.tsvParseRows = sc, t.union = function(...t) { const n = new InternSet; for (const e of t) for (const t of e) n.add(t); return n }, t.unixDay = _y, t.unixDays = by, t.utcDay = yy, t.utcDays = vy, t.utcFriday = By, t.utcFridays = Vy, t.utcHour = hy, t.utcHours = dy, t.utcMillisecond = Wg, t.utcMilliseconds = Zg, t.utcMinute = cy, t.utcMinutes = fy, t.utcMonday = qy, t.utcMondays = jy, t.utcMonth = Qy, t.utcMonths = Jy, t.utcSaturday = Yy, t.utcSaturdays = Wy, t.utcSecond = iy, t.utcSeconds = oy, t.utcSunday = Fy, t.utcSundays = Ly, t.utcThursday = Oy, t.utcThursdays = Gy, t.utcTickInterval = av, t.utcTicks = ov, t.utcTuesday = Uy, t.utcTuesdays = Hy, t.utcWednesday = Iy, t.utcWednesdays = Xy, t.utcWeek = Fy, t.utcWeeks = Ly, t.utcYear = ev, t.utcYears = rv, t.variance = x, t.version = "7.9.0", t.window = pn, t.xml = Sc, t.zip = function() { return gt(arguments) }, t.zoom = function() { var t, n, e, r = Ew, i = Nw, o = zw, a = Cw, u = Pw, c = [0, 1 / 0], f = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], s = 250, l = ri, h = $t("start", "zoom", "end"), d = 500, p = 150, g = 0, y = 10; function v(t) { t.property("__zoom", kw).on("wheel.zoom", T, { passive: !1 }).on("mousedown.zoom", A).on("dblclick.zoom", S).filter(u).on("touchstart.zoom", E).on("touchmove.zoom", N).on("touchend.zoom touchcancel.zoom", k).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)") } function _(t, n) { return (n = Math.max(c[0], Math.min(c[1], n))) === t.k ? t : new ww(n, t.x, t.y) } function b(t, n, e) { var r = n[0] - e[0] * t.k, i = n[1] - e[1] * t.k; return r === t.x && i === t.y ? t : new ww(t.k, r, i) } function m(t) { return [(+t[0][0] + +t[1][0]) / 2, (+t[0][1] + +t[1][1]) / 2] } function x(t, n, e, r) { t.on("start.zoom", (function() { w(this, arguments).event(r).start() })).on("interrupt.zoom end.zoom", (function() { w(this, arguments).event(r).end() })).tween("zoom", (function() { var t = this, o = arguments, a = w(t, o).event(r), u = i.apply(t, o), c = null == e ? m(u) : "function" == typeof e ? e.apply(t, o) : e, f = Math.max(u[1][0] - u[0][0], u[1][1] - u[0][1]), s = t.__zoom, h = "function" == typeof n ? n.apply(t, o) : n, d = l(s.invert(c).concat(f / s.k), h.invert(c).concat(f / h.k)); return function(t) { if (1 === t) t = h; else { var n = d(t), e = f / n[2]; t = new ww(e, c[0] - n[0] * e, c[1] - n[1] * e) } a.zoom(null, t) } })) } function w(t, n, e) { return !e && t.__zooming || new M(t, n) } function M(t, n) { this.that = t, this.args = n, this.active = 0, this.sourceEvent = null, this.extent = i.apply(t, n), this.taps = 0 } function T(t, ...n) { if (r.apply(this, arguments)) { var e = w(this, n).event(t), i = this.__zoom, u = Math.max(c[0], Math.min(c[1], i.k * Math.pow(2, a.apply(this, arguments)))), s = ne(t); if (e.wheel) e.mouse[0][0] === s[0] && e.mouse[0][1] === s[1] || (e.mouse[1] = i.invert(e.mouse[0] = s)), clearTimeout(e.wheel); else { if (i.k === u) return; e.mouse = [s, i.invert(s)], Gi(this), e.start() } Sw(t), e.wheel = setTimeout((function() { e.wheel = null, e.end() }), p), e.zoom("mouse", o(b(_(i, u), e.mouse[0], e.mouse[1]), e.extent, f)) } } function A(t, ...n) { if (!e && r.apply(this, arguments)) { var i = t.currentTarget, a = w(this, n, !0).event(t), u = Zn(t.view).on("mousemove.zoom", (function(t) { if (Sw(t), !a.moved) { var n = t.clientX - s, e = t.clientY - l; a.moved = n * n + e * e > g } a.event(t).zoom("mouse", o(b(a.that.__zoom, a.mouse[0] = ne(t, i), a.mouse[1]), a.extent, f)) }), !0).on("mouseup.zoom", (function(t) { u.on("mousemove.zoom mouseup.zoom", null), ue(t.view, a.moved), Sw(t), a.event(t).end() }), !0), c = ne(t, i), s = t.clientX, l = t.clientY; ae(t.view), Aw(t), a.mouse = [c, this.__zoom.invert(c)], Gi(this), a.start() } } function S(t, ...n) { if (r.apply(this, arguments)) { var e = this.__zoom, a = ne(t.changedTouches ? t.changedTouches[0] : t, this), u = e.invert(a), c = e.k * (t.shiftKey ? .5 : 2), l = o(b(_(e, c), a, u), i.apply(this, n), f); Sw(t), s > 0 ? Zn(this).transition().duration(s).call(x, l, a, t) : Zn(this).call(v.transform, l, a, t) } } function E(e, ...i) { if (r.apply(this, arguments)) { var o, a, u, c, f = e.touches, s = f.length, l = w(this, i, e.changedTouches.length === s).event(e); for (Aw(e), a = 0; a < s; ++a)c = [c = ne(u = f[a], this), this.__zoom.invert(c), u.identifier], l.touch0 ? l.touch1 || l.touch0[2] === c[2] || (l.touch1 = c, l.taps = 0) : (l.touch0 = c, o = !0, l.taps = 1 + !!t); t && (t = clearTimeout(t)), o && (l.taps < 2 && (n = c[0], t = setTimeout((function() { t = null }), d)), Gi(this), l.start()) } } function N(t, ...n) { if (this.__zooming) { var e, r, i, a, u = w(this, n).event(t), c = t.changedTouches, s = c.length; for (Sw(t), e = 0; e < s; ++e)i = ne(r = c[e], this), u.touch0 && u.touch0[2] === r.identifier ? u.touch0[0] = i : u.touch1 && u.touch1[2] === r.identifier && (u.touch1[0] = i); if (r = u.that.__zoom, u.touch1) { var l = u.touch0[0], h = u.touch0[1], d = u.touch1[0], p = u.touch1[1], g = (g = d[0] - l[0]) * g + (g = d[1] - l[1]) * g, y = (y = p[0] - h[0]) * y + (y = p[1] - h[1]) * y; r = _(r, Math.sqrt(g / y)), i = [(l[0] + d[0]) / 2, (l[1] + d[1]) / 2], a = [(h[0] + p[0]) / 2, (h[1] + p[1]) / 2] } else { if (!u.touch0) return; i = u.touch0[0], a = u.touch0[1] } u.zoom("touch", o(b(r, i, a), u.extent, f)) } } function k(t, ...r) { if (this.__zooming) { var i, o, a = w(this, r).event(t), u = t.changedTouches, c = u.length; for (Aw(t), e && clearTimeout(e), e = setTimeout((function() { e = null }), d), i = 0; i < c; ++i)o = u[i], a.touch0 && a.touch0[2] === o.identifier ? delete a.touch0 : a.touch1 && a.touch1[2] === o.identifier && delete a.touch1; if (a.touch1 && !a.touch0 && (a.touch0 = a.touch1, delete a.touch1), a.touch0) a.touch0[1] = this.__zoom.invert(a.touch0[0]); else if (a.end(), 2 === a.taps && (o = ne(o, this), Math.hypot(n[0] - o[0], n[1] - o[1]) < y)) { var f = Zn(this).on("dblclick.zoom"); f && f.apply(this, arguments) } } } return v.transform = function(t, n, e, r) { var i = t.selection ? t.selection() : t; i.property("__zoom", kw), t !== i ? x(t, n, e, r) : i.interrupt().each((function() { w(this, arguments).event(r).start().zoom(null, "function" == typeof n ? n.apply(this, arguments) : n).end() })) }, v.scaleBy = function(t, n, e, r) { v.scaleTo(t, (function() { return this.__zoom.k * ("function" == typeof n ? n.apply(this, arguments) : n) }), e, r) }, v.scaleTo = function(t, n, e, r) { v.transform(t, (function() { var t = i.apply(this, arguments), r = this.__zoom, a = null == e ? m(t) : "function" == typeof e ? e.apply(this, arguments) : e, u = r.invert(a), c = "function" == typeof n ? n.apply(this, arguments) : n; return o(b(_(r, c), a, u), t, f) }), e, r) }, v.translateBy = function(t, n, e, r) { v.transform(t, (function() { return o(this.__zoom.translate("function" == typeof n ? n.apply(this, arguments) : n, "function" == typeof e ? e.apply(this, arguments) : e), i.apply(this, arguments), f) }), null, r) }, v.translateTo = function(t, n, e, r, a) { v.transform(t, (function() { var t = i.apply(this, arguments), a = this.__zoom, u = null == r ? m(t) : "function" == typeof r ? r.apply(this, arguments) : r; return o(Mw.translate(u[0], u[1]).scale(a.k).translate("function" == typeof n ? -n.apply(this, arguments) : -n, "function" == typeof e ? -e.apply(this, arguments) : -e), t, f) }), r, a) }, M.prototype = { event: function(t) { return t && (this.sourceEvent = t), this }, start: function() { return 1 == ++this.active && (this.that.__zooming = this, this.emit("start")), this }, zoom: function(t, n) { return this.mouse && "mouse" !== t && (this.mouse[1] = n.invert(this.mouse[0])), this.touch0 && "touch" !== t && (this.touch0[1] = n.invert(this.touch0[0])), this.touch1 && "touch" !== t && (this.touch1[1] = n.invert(this.touch1[0])), this.that.__zoom = n, this.emit("zoom"), this }, end: function() { return 0 == --this.active && (delete this.that.__zooming, this.emit("end")), this }, emit: function(t) { var n = Zn(this.that).datum(); h.call(t, this.that, new xw(t, { sourceEvent: this.sourceEvent, target: v, type: t, transform: this.that.__zoom, dispatch: h }), n) } }, v.wheelDelta = function(t) { return arguments.length ? (a = "function" == typeof t ? t : mw(+t), v) : a }, v.filter = function(t) { return arguments.length ? (r = "function" == typeof t ? t : mw(!!t), v) : r }, v.touchable = function(t) { return arguments.length ? (u = "function" == typeof t ? t : mw(!!t), v) : u }, v.extent = function(t) { return arguments.length ? (i = "function" == typeof t ? t : mw([[+t[0][0], +t[0][1]], [+t[1][0], +t[1][1]]]), v) : i }, v.scaleExtent = function(t) { return arguments.length ? (c[0] = +t[0], c[1] = +t[1], v) : [c[0], c[1]] }, v.translateExtent = function(t) { return arguments.length ? (f[0][0] = +t[0][0], f[1][0] = +t[1][0], f[0][1] = +t[0][1], f[1][1] = +t[1][1], v) : [[f[0][0], f[0][1]], [f[1][0], f[1][1]]] }, v.constrain = function(t) { return arguments.length ? (o = t, v) : o }, v.duration = function(t) { return arguments.length ? (s = +t, v) : s }, v.interpolate = function(t) { return arguments.length ? (l = t, v) : l }, v.on = function() { var t = h.on.apply(h, arguments); return t === h ? v : t }, v.clickDistance = function(t) { return arguments.length ? (g = (t = +t) * t, v) : Math.sqrt(g) }, v.tapDistance = function(t) { return arguments.length ? (y = +t, v) : y }, v }, t.zoomIdentity = Mw, t.zoomTransform = Tw }));